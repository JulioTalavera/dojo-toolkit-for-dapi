<javascript version="1"><object location="dojo/AdapterRegistry" type="function"><properties><property name="pairs" scope="normal" type="Array" from="dojo/AdapterRegistry"/><property name="returnWrappers" scope="normal" type="boolean" from="dojo/AdapterRegistry"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="returnWrappers" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>A registry to make contextual calling/searching easier.&lt;/p>
</summary><description>&lt;p>Objects of this class keep list of arrays in the form [name, check,
wrap, directReturn] that are used to determine what the contextual
result of a set of checked arguments is. All check/wrap functions
in this registry should be of the same arity.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // create a new registry
  var reg = new dojo.AdapterRegistry();
  reg.register(&amp;quot;handleString&amp;quot;,
    dojo.isString,
    function(str){
      // do something with the string here
    }
  );
  reg.register(&amp;quot;handleArr&amp;quot;,
    dojo.isArray,
    function(arr){
      // do something with the array here
    }
  );

  // now we can pass reg.match() *either* an array or a string and
  // the value we pass will get handled by the right function
  reg.match(&amp;quot;someValue&amp;quot;); // will call the first function
  reg.match([&amp;quot;someValue&amp;quot;]); // will call the second&lt;/code>&lt;/pre>
</example></examples></method><method name="register" scope="prototype" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>a way to identify this matcher.&lt;/p>
</summary></parameter><parameter name="check" type="Function" usage="required"><summary>&lt;p>a function that arguments are passed to from the adapter&amp;#39;s
match() function.  The check function should return true if the
given arguments are appropriate for the wrap function.&lt;/p>
</summary></parameter><parameter name="wrap" type="Function" usage="required"/><parameter name="directReturn" type="Boolean" usage="optional"><summary>&lt;p>If directReturn is true, the value passed in for wrap will be
returned instead of being called. Alternately, the
AdapterRegistry can be set globally to &amp;quot;return not call&amp;quot; using
the returnWrappers property. Either way, this behavior allows
the registry to act as a &amp;quot;search&amp;quot; function instead of a
function interception library.&lt;/p>
</summary></parameter><parameter name="override" type="Boolean" usage="optional"><summary>&lt;p>If override is given and true, the check function will be given
highest priority. Otherwise, it will be the lowest priority
adapter.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>register a check function to determine if the wrap function or
object gets selected&lt;/p>
</summary></method><method name="match" scope="prototype" type="function" from="dojo/AdapterRegistry"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Find an adapter for the given arguments. If no suitable adapter
is found, throws an exception. match() accepts any number of
arguments, all of which are passed to all matching functions
from the registered pairs.&lt;/p>
</summary></method><method name="unregister" scope="prototype" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The name of the adapter.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><return-description>Returns true if operation is successful.
Returns false if operation fails.</return-description><summary>&lt;p>Remove a named adapter from the registry&lt;/p>
</summary></method></methods><parameters><parameter name="returnWrappers" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>A registry to make contextual calling/searching easier.&lt;/p>
</summary><description>&lt;p>Objects of this class keep list of arrays in the form [name, check,
wrap, directReturn] that are used to determine what the contextual
result of a set of checked arguments is. All check/wrap functions
in this registry should be of the same arity.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // create a new registry
  var reg = new dojo.AdapterRegistry();
  reg.register(&amp;quot;handleString&amp;quot;,
    dojo.isString,
    function(str){
      // do something with the string here
    }
  );
  reg.register(&amp;quot;handleArr&amp;quot;,
    dojo.isArray,
    function(arr){
      // do something with the array here
    }
  );

  // now we can pass reg.match() *either* an array or a string and
  // the value we pass will get handled by the right function
  reg.match(&amp;quot;someValue&amp;quot;); // will call the first function
  reg.match([&amp;quot;someValue&amp;quot;]); // will call the second&lt;/code>&lt;/pre>
</example></examples></object>


<object location="dojo/_base/kernel" type="object"><properties><property name="config" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>This module defines the user configuration during bootstrap.&lt;/p>
</summary><description>&lt;p>By defining user configuration as a module value, an entire configuration can be specified in a build,
thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
Also, when multiple instances of dojo exist in a single application, each will necessarily be located
at an unique absolute module identifier as given by the package configuration. Implementing configuration
as a module allows for specifying unique, per-instance configurations.&lt;/p>
</description><examples><example>&lt;p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
dojo.js are already loaded).&lt;/p>
&lt;pre>&lt;code>  // specify a configuration that creates a new instance of dojo at the absolute module identifier &amp;quot;myDojo&amp;quot;
  require({
    packages:[{
      name:&amp;quot;myDojo&amp;quot;,
      location:&amp;quot;.&amp;quot;, //assume baseUrl points to dojo.js
    }]
  });

  // specify a configuration for the myDojo instance
  define(&amp;quot;myDojo/config&amp;quot;, {
    // normal configuration variables go here, e.g.,
    locale:&amp;quot;fr-ca&amp;quot;
  });

  // load and use the new instance of dojo
  require([&amp;quot;myDojo&amp;quot;], function(dojo){
    // dojo is the new instance of dojo
    // use as required
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="global" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current window. &amp;#39;global&amp;#39; can be modified
for temporary context shifting. See also withGlobal().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description></property><property name="dijit" scope="normal" type="object" from="dojo/_base/kernel"/><property name="dojox" scope="normal" type="object" from="dojo/_base/kernel"/><property name="scopeMap" scope="normal" type="object" from="dojo/_base/kernel"/><property name="baseUrl" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isAsync" scope="normal" type="boolean" from="dojo/_base/kernel"/><property name="locale" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="version" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>Version number of the Dojo Toolkit&lt;/p>
</summary><description>&lt;p>Hash about the version, including

&lt;/p>
&lt;ul>
&lt;li>major: Integer: Major version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 1&lt;/li>
&lt;li>minor: Integer: Minor version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 2&lt;/li>
&lt;li>patch: Integer: Patch version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 0&lt;/li>
&lt;li>flag: String: Descriptor flag. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be &amp;quot;beta1&amp;quot;&lt;/li>
&lt;li>revision: Number: The SVN rev from which dojo was pulled&lt;/li>
&lt;/ul>
</description></property><property name="_hasResource" scope="normal" type="object" from="dojo/_base/kernel"/><property name="doc" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current document. &amp;#39;doc&amp;#39; can be modified
for temporary context shifting. See also withDoc().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window.document&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  n.appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></property><property name="isQuirks" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isIE" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
major detected IE version (6, 7, 8, etc.)&lt;/p>
</summary></property><property name="query" scope="normal" type="undefined" from="dojo/query"/><property name="mouseButtons" scope="normal" type="object" from="dojo/mouse"/><property name="_name" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isBrowser" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isFF" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isKhtml" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
detected version.&lt;/p>
</summary></property><property name="isWebKit" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a WebKit-derived browser (Konqueror,
Safari, Chrome, etc.). undefined otherwise.&lt;/p>
</summary></property><property name="isMozilla" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isMoz" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isOpera" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Opera. undefined otherwise. Corresponds to
major detected version.&lt;/p>
</summary></property><property name="isSafari" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Safari or iPhone. undefined otherwise.&lt;/p>
</summary></property><property name="isChrome" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Chrome browser. undefined otherwise.&lt;/p>
</summary></property><property name="isMac" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if the client runs on Mac&lt;/p>
</summary></property><property name="isIos" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is iPhone, iPod, or iPad&lt;/p>
</summary></property><property name="isAndroid" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is android browser. undefined otherwise.&lt;/p>
</summary></property><property name="isWii" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Wii&lt;/p>
</summary></property><property name="isAir" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Adobe Air&lt;/p>
</summary></property><property name="keys" scope="normal" type="object" from="dojo/keys"><summary>&lt;p>Definitions for common key values.  Client code should test keyCode against these named constants,
as the actual codes can vary by browser.&lt;/p>
</summary></property><property name="subscribe" scope="normal" type="undefined" from="dojo/robotx"/><property name="publish" scope="normal" type="undefined" from="dojo/robotx"/><property name="connectPublisher" scope="normal" type="undefined" from="dojo/robotx"/><property name="_nodeDataCache" scope="normal" type="object" from="dojo/NodeList-data"/><property name="_postLoad" scope="normal" type="boolean" from="dojo/ready"/><property name="fx" scope="normal" type="object" from="dojo/fx"><summary>&lt;p>Effects library on top of Base animations&lt;/p>
</summary></property><property name="toJsonIndentStr" scope="normal" type="string" from="dojo/_base/json"/><property name="date" scope="normal" type="object" from="dojo/date/stamp"/><property name="parser" scope="normal" type="object" from="dojo/parser"><summary>&lt;p>The Dom/Widget parsing package&lt;/p>
</summary></property><property name="html" scope="normal" type="object" from="dojo/html"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="_blockAsync" scope="normal" type="boolean" from="dojo/_base/xhr"/><property name="contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_windowUnloaders" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_defaultContext" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_initFired" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isSpidermonkey" scope="normal" type="boolean" from="dojo/_base/configSpidermonkey"/><property name="back" scope="normal" type="object" from="dojo/back"><summary>&lt;p>Browser history management resources&lt;/p>
</summary></property><property name="behavior" scope="normal" type="instance" from="dojo/behavior"/><property name="cldr" scope="normal" type="object" from="dojo/cldr/monetary"/><property name="i18n" scope="normal" type="object" from="dojo/i18n"><summary>&lt;p>This module implements the dojo/i18n! plugin and the v1.6- i18n API&lt;/p>
</summary><description>&lt;p>We choose to include our own plugin to leverage functionality already contained in dojo
and thereby reduce the size of the plugin compared to various loader implementations. Also, this
allows foreign AMD loaders to be used without their plugins.&lt;/p>
</description></property><property name="colors" scope="normal" type="object" from="dojo/colors"/><property name="regexp" scope="normal" type="object" from="dojo/regexp"><summary>&lt;p>Regular expressions and Builder resources&lt;/p>
</summary></property><property name="string" scope="normal" type="object" from="dojo/string"><summary>&lt;p>String utilities for Dojo&lt;/p>
</summary></property><property name="number" scope="normal" type="object" from="dojo/number"><summary>&lt;p>localized formatting and parsing routines for Number&lt;/p>
</summary></property><property name="currency" scope="normal" type="object" from="dojo/currency"><summary>&lt;p>localized formatting and parsing routines for currencies&lt;/p>
</summary><description>&lt;p>extends dojo.number to provide culturally-appropriate formatting of values
in various world currencies, including use of a currency symbol.  The currencies are specified
by a three-letter international symbol in all uppercase, and support for the currencies is
provided by the data in &lt;code>dojo.cldr&lt;/code>.  The scripts generating dojo.cldr specify which
currency support is included.  A fixed number of decimal places is determined based
on the currency type and is not determined by the &amp;#39;pattern&amp;#39; argument.  The fractional
portion is optional, by default, and variable length decimals are not supported.&lt;/p>
</description></property><property name="data" scope="normal" type="object" from="dojo/data/util/filter"/><property name="dnd" scope="normal" type="object" from="dojo/dnd/common"/><property name="touch" scope="normal" type="object" from="dojo/touch"><summary>&lt;p>This module provides unified touch event handlers by exporting
press, move, release and cancel which can also run well on desktop.
Based on &lt;a href=&quot;http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&quot;>http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&lt;/a>
&lt;/p>
</summary><examples><example>&lt;p>Used with dojo.on&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/touch&amp;quot;], function(on, touch){
    on(node, touch.press, function(e){});
    on(node, touch.move, function(e){});
    on(node, touch.release, function(e){});
    on(node, touch.cancel, function(e){});&lt;/code>&lt;/pre>
</example><example>&lt;p>Used with touch.* directly&lt;/p>
&lt;pre>&lt;code>  touch.press(node, function(e){});
  touch.move(node, function(e){});
  touch.release(node, function(e){});
  touch.cancel(node, function(e){});&lt;/code>&lt;/pre>
</example></examples></property><property name="window" scope="normal" type="object" from="dojo/window"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="gears" scope="normal" type="object" from="dojo/gears"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="io" scope="normal" type="object" from="dojo/io/iframe"/><property name="rpc" scope="normal" type="object" from="dojo/rpc/RpcService"/><property name="store" scope="normal" type="object" from="dojo/store/Cache"/><property name="tests" scope="normal" type="object" from="dojo/tests"><summary>&lt;p>D.O.H. Test files for Dojo unit testing.&lt;/p>
</summary></property></properties><methods><method name="eval" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="scriptText" type="undefined" usage="required"><summary>&lt;p>The text to evaluation.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The result of the evaluation. Often `undefined`</return-description><summary>&lt;p>A legacy method created for use exclusively by internal Dojo methods. Do not use this method
directly unless you understand its possibly-different implications on the platforms your are targeting.&lt;/p>
</summary><description>&lt;p>Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
that support indirect eval.

&lt;/p>
&lt;p>As usual, IE does not. On IE, the only way to implement global eval is to
use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
This implementation uses the technique of executing eval in the scope of a function that is a single scope
frame below the global scope; thereby coming close to the global scope. Note carefully that

&lt;/p>
&lt;p>dojo.eval(&amp;quot;var pi = 3.14;&amp;quot;);

&lt;/p>
&lt;p>will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
to define a global variable using dojo.eval, write something like

&lt;/p>
&lt;p>dojo.eval(&amp;quot;window.pi = 3.14;&amp;quot;)&lt;/p>
</description></method><method name="exit" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="exitcode" type="undefined" usage="required"/></parameters><return-types/></method><method name="experimental" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>The name of a module, or the name of a module file or a specific
function&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>some additional message for the user&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Marks code as experimental.&lt;/p>
</summary><description>&lt;p>This can be used to mark a function, file, or module as
experimental.   Experimental code is not ready to be used, and the
APIs are subject to change without notice.  Experimental code may be
completed deleted without going through the normal deprecation
process.&lt;/p>
</description><examples><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.data.Result&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.weather.toKelvin()&amp;quot;, &amp;quot;PENDING approval from NOAA&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="deprecated" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="behaviour" type="String" usage="required"><summary>&lt;p>The API or behavior being deprecated. Usually in the form
of &amp;quot;myApp.someFunction()&amp;quot;.&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>Text to append to the message. Often provides advice on a
new function or facility to achieve the same goal during
the deprecation period.&lt;/p>
</summary></parameter><parameter name="removal" type="String" usage="optional"><summary>&lt;p>Text to indicate when in the future the behavior will be
removed. Usually a version number.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Log a debug message to indicate that a behavior has been
deprecated.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> dojo.deprecated(&amp;quot;myApp.getTemp()&amp;quot;, &amp;quot;use myApp.getLocaleTemp() instead&amp;quot;, &amp;quot;1.0&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="moduleUrl" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="module" type="String" usage="required"><summary>&lt;p>dojo/dom-class&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Returns a URL relative to a module.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var pngPath = dojo.moduleUrl(&amp;quot;acme&amp;quot;,&amp;quot;images/small.png&amp;quot;);
  console.dir(pngPath); // list the object properties
  // create an image and set it&amp;#39;s source to pngPath&amp;#39;s value:
  var img = document.createElement(&amp;quot;img&amp;quot;);
  img.src = pngPath;
  // add our image to the document
  dojo.body().appendChild(img);&lt;/code>&lt;/pre>
</example><example>&lt;p>you may de-reference as far as you like down the package
hierarchy.  This is sometimes handy to avoid lenghty relative
urls or for building portable sub-packages. In this example,
the &lt;code>acme.widget&lt;/code> and &lt;code>acme.util&lt;/code> directories may be located
under different roots (see &lt;code>dojo.registerModulePath&lt;/code>) but the
the modules which reference them can be unaware of their
relative locations on the filesystem:&lt;/p>
&lt;pre>&lt;code>  // somewhere in a configuration block
  dojo.registerModulePath(&amp;quot;acme.widget&amp;quot;, &amp;quot;../../acme/widget&amp;quot;);
  dojo.registerModulePath(&amp;quot;acme.util&amp;quot;, &amp;quot;../../util&amp;quot;);

  // ...

  // code in a module using acme resources
  var tmpltPath = dojo.moduleUrl(&amp;quot;acme.widget&amp;quot;,&amp;quot;templates/template.html&amp;quot;);
  var dataPath = dojo.moduleUrl(&amp;quot;acme.util&amp;quot;,&amp;quot;resources/data.json&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="AdapterRegistry" scope="normal" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="returnWrappers" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>A registry to make contextual calling/searching easier.&lt;/p>
</summary><description>&lt;p>Objects of this class keep list of arrays in the form [name, check,
wrap, directReturn] that are used to determine what the contextual
result of a set of checked arguments is. All check/wrap functions
in this registry should be of the same arity.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // create a new registry
  var reg = new dojo.AdapterRegistry();
  reg.register(&amp;quot;handleString&amp;quot;,
    dojo.isString,
    function(str){
      // do something with the string here
    }
  );
  reg.register(&amp;quot;handleArr&amp;quot;,
    dojo.isArray,
    function(arr){
      // do something with the array here
    }
  );

  // now we can pass reg.match() *either* an array or a string and
  // the value we pass will get handled by the right function
  reg.match(&amp;quot;someValue&amp;quot;); // will call the first function
  reg.match([&amp;quot;someValue&amp;quot;]); // will call the second&lt;/code>&lt;/pre>
</example></examples></method><method name="Deferred" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="canceller" type="Function" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.
New code should use dojo/Deferred instead.&lt;/p>
</summary><description>&lt;p>The Deferred API is based on the concept of promises that provide a
generic interface into the eventual completion of an asynchronous action.
The motivation for promises fundamentally is about creating a
separation of concerns that allows one to achieve the same type of
call patterns and logical data flow in asynchronous code as can be
achieved in synchronous code. Promises allows one
to be able to call a function purely with arguments needed for
execution, without conflating the call with concerns of whether it is
sync or async. One shouldn&amp;#39;t need to alter a call&amp;#39;s arguments if the
implementation switches from sync to async (or vice versa). By having
async functions return promises, the concerns of making the call are
separated from the concerns of asynchronous interaction (which are
handled by the promise).

&lt;/p>
&lt;p>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&amp;#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

&lt;/p>
&lt;pre>&lt;code>  var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
  },
  function(error){
    ... handle error ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

&lt;/p>
&lt;p>The Deferred instances also provide the following functions for backwards compatibility:

&lt;/p>
&lt;ul>
&lt;li>addCallback(handler)&lt;/li>
&lt;li>addErrback(handler)&lt;/li>
&lt;li>callback(result)&lt;/li>
&lt;li>errback(result)&lt;/li>
&lt;/ul>
&lt;p>Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

&lt;/p>
&lt;p>The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var deferred = new Deferred();
  setTimeout(function(){ deferred.callback({success: true}); }, 1000);
  return deferred;&lt;/code>&lt;/pre>
</example><example>&lt;p>Deferred objects are often used when making code asynchronous. It
may be easiest to write functions in a synchronous manner and then
split code using a deferred to trigger a response to a long-lived
operation. For example, instead of register a callback function to
denote when a rendering operation completes, the function can
simply return a deferred:

&lt;/p>
&lt;pre>&lt;code>  // callback style:
  function renderLotsOfData(data, callback){
    var success = false
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      success = true;
    }catch(e){ }
    if(callback){
      callback(success);
    }
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using callback style
  renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
      promptUserToRecover();
    }
  });
  // NOTE: no way to add another callback here!!&lt;/code>&lt;/pre>
</example><example>&lt;p>Using a Deferred doesn&amp;#39;t simplify the sending code any, but it
provides a standard interface for callers and senders alike,
providing both with a simple way to service multiple callbacks for
an operation and freeing both sides from worrying about details
such as &amp;quot;did this get called already?&amp;quot;. With Deferreds, new
callbacks can be added at any time.

&lt;/p>
&lt;pre>&lt;code>  // Deferred style:
  function renderLotsOfData(data){
    var d = new Deferred();
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      d.callback(true);
    }catch(e){
      d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
    }
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });
  // NOTE: addErrback and addCallback both return the Deferred
  // again, so we could chain adding callbacks or save the
  // deferred for later should we need to be notified again.&lt;/code>&lt;/pre>
</example><example>&lt;p>In this example, renderLotsOfData is synchronous and so both
versions are pretty artificial. Putting the data display on a
timeout helps show why Deferreds rock:

&lt;/p>
&lt;pre>&lt;code>  // Deferred style and async func
  function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
      try{
        for(var x in data){
          renderDataitem(data[x]);
        }
        d.callback(true);
      }catch(e){
        d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
      }
    }, 100);
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that the caller doesn&amp;#39;t have to change his code at all to
handle the asynchronous case.&lt;/p>
</example></examples></method><method name="when" scope="normal" type="function" from="dojo/when"><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></method><method name="every" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not every item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s every skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // returns false
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // returns true
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;0; });&lt;/code>&lt;/pre>
</example></examples></method><method name="some" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate over. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not any item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s some skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // is true
 array.some([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // is false
 array.some([1, 2, 3, 4], function(item){ return item&amp;lt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="indexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"/><parameter name="value" type="Object" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/><parameter name="findLast" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the first index of the provided value in the
passed array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s indexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&lt;/a>&lt;/p>
</description></method><method name="lastIndexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="undefined" usage="required"/><parameter name="value" type="undefined" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the last index of the provided value in the passed
array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s lastIndexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&lt;/a>&lt;/p>
</description></method><method name="forEach" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"/><parameter name="callback" type="Function|String" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>for every item in arr, callback is invoked. Return values are ignored.
If you want to break out of the loop, consider using array.every() or array.some().
forEach does not allow breaking out of the loop over the items in arr.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s forEach skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // log out all members of the array:
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item){
      console.log(item);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // log out the members and their indexes
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item, idx, arr){
      console.log(item, &amp;quot;at index:&amp;quot;, idx);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // use a scoped object member as the callback

 var obj = {
    prefix: &amp;quot;logged via obj.callback:&amp;quot;,
    callback: function(item){
      console.log(this.prefix, item);
    }
 };

 // specifying the scope function executes the callback in that scope
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    obj.callback,
    obj
 );

 // alternately, we can accomplish the same thing with lang.hitch()
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    lang.hitch(obj, &amp;quot;callback&amp;quot;)
 );&lt;/code>&lt;/pre>
</example></examples></method><method name="map" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on
individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments, (item, index,
array),   and returns a value&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter><parameter name="Ctr" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="instance"/></return-types><summary>&lt;p>applies callback to each element of arr and returns
an Array with the results&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s map skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4, 5]
 array.map([1, 2, 3, 4], function(item){ return item+1 });&lt;/code>&lt;/pre>
</example></examples></method><method name="filter" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"><summary>&lt;p>the array to iterate over.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function that is invoked with three arguments (item,
index, array). The return of this function is expected to
be a boolean which determines whether the passed-in item
will be included in the returned array.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns a new Array with those items from arr that match the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s filter skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4]
 array.filter([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="clearCache" scope="normal" type="function" from="dojo/_base/array"><parameters/><return-types/></method><method name="DeferredList" scope="normal" type="function" from="dojo/DeferredList"><parameters><parameter name="list" type="Array" usage="required"><summary>&lt;p>The list of deferreds to be synchronizied with this DeferredList&lt;/p>
</summary></parameter><parameter name="fireOnOneCallback" type="Boolean" usage="optional"><summary>&lt;p>Will cause the DeferredLists callback to be fired as soon as any
of the deferreds in its list have been fired instead of waiting until
the entire list has finished&lt;/p>
</summary></parameter><parameter name="fireOnOneErrback" type="Boolean" usage="optional"/><parameter name="consumeErrors" type="Boolean" usage="optional"/><parameter name="canceller" type="Function" usage="optional"><summary>&lt;p>A deferred canceller function, see dojo.Deferred&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deprecated, use dojo/promise/all instead.
Provides event handling for a group of Deferred objects.&lt;/p>
</summary><description>&lt;p>DeferredList takes an array of existing deferreds and returns a new deferred of its own
this new deferred will typically have its callback fired when all of the deferreds in
the given list have fired their own deferreds.  The parameters &lt;code>fireOnOneCallback&lt;/code> and
fireOnOneErrback, will fire before all the deferreds as appropriate&lt;/p>
</description></method><method name="body" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the body element of the specified document or of dojo/_base/window::doc.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  win.body().appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></method><method name="setContext" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="globalDocument" type="DocumentElement" usage="required"/></parameters><return-types/><summary>&lt;p>changes the behavior of many core Dojo functions that deal with
namespace and DOM lookup, changing them to work in a new global
context (e.g., an iframe). The varibles dojo.global and dojo.doc
are modified as a result of calling this function and the result of
&lt;code>dojo.body()&lt;/code> likewise differs.&lt;/p>
</summary></method><method name="withGlobal" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc. If provided, globalObject
will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo.global
and dojo.doc will be restored to its previous state.&lt;/p>
</description></method><method name="withDoc" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="documentObject" type="DocumentElement" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,
callback will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo/_base/window::doc will
be restored to its previous state.&lt;/p>
</description></method><method name="_filterQueryResult" scope="normal" type="function" from="dojo/query"><parameters><parameter name="nodes" type="undefined" usage="required"/><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/><return-type type="undefined"/></return-types></method><method name="NodeList" scope="normal" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method><method name="fixEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>native event object&lt;/p>
</summary></parameter><parameter name="sender" type="DOMNode" usage="required"><summary>&lt;p>node to treat as &amp;quot;currentTarget&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Event"/></return-types><return-description>&lt;p>native event object&lt;/p>
</return-description><summary>&lt;p>normalizes properties on the event object including event
bubbling methods, keystroke normalization, and x/y positions&lt;/p>
</summary></method><method name="stopEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>The event object. If omitted, window.event is used on IE.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>prevents propagation and clobbers the default action of the
passed event&lt;/p>
</summary></method><method name="_keypress" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="object" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="connect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>The source object for the event function.
Defaults to &lt;code>kernel.global&lt;/code> if null.
If obj is a DOM node, the connection is delegated
to the DOM event manager (unless dontFix is true).
&lt;/p>
</summary></parameter><parameter name="event" type="String" usage="required"><summary>&lt;p>String name of the event function in obj.
I.e. identifies a property &lt;code>obj[event]&lt;/code>.
&lt;/p>
</summary></parameter><parameter name="context" type="Object|null" usage="required"><summary>&lt;p>The object that method will receive as &amp;quot;this&amp;quot;.

&lt;/p>
&lt;p>If context is null and method is a function, then method
inherits the context of event.

&lt;/p>
&lt;p>If method is a string then context must be the source
object object for method (context[method]). If context is null,
kernel.global is used.
&lt;/p>
</summary></parameter><parameter name="method" type="String|Function" usage="required"><summary>&lt;p>A function reference, or name of a function in context.
The function identified by method fires after event does.
method receives the same arguments as the event.
See context argument comments for information on method&amp;#39;s scope.
&lt;/p>
</summary></parameter><parameter name="dontFix" type="Boolean" usage="optional"><summary>&lt;p>If obj is a DOM node, set dontFix to true to prevent delegation
of this connection to the DOM event manager.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>&lt;code>dojo.connect&lt;/code> is a deprecated event handling and delegation method in
Dojo. It allows one function to &amp;quot;listen in&amp;quot; on the execution of
any other, triggering the second whenever the first is called. Many
listeners may be attached to a function, and source functions may
be either regular function calls or DOM events.
&lt;/p>
</summary><description>&lt;p>Connects listeners to actions, so that after event fires, a
listener is called with the same arguments passed to the original
function.

&lt;/p>
&lt;p>Since &lt;code>dojo.connect&lt;/code> allows the source of events to be either a
&amp;quot;regular&amp;quot; JavaScript function or a DOM event, it provides a uniform
interface for listening to all the types of events that an
application is likely to deal with though a single, unified
interface. DOM programmers may want to think of it as
&amp;quot;addEventListener for everything and anything&amp;quot;.

&lt;/p>
&lt;p>When setting up a connection, the &lt;code>event&lt;/code> parameter must be a
string that is the name of the method/event to be listened for. If
&lt;code>obj&lt;/code> is null, &lt;code>kernel.global&lt;/code> is assumed, meaning that connections
to global methods are supported but also that you may inadvertently
connect to a global by passing an incorrect object name or invalid
reference.

&lt;/p>
&lt;p>&lt;code>dojo.connect&lt;/code> generally is forgiving. If you pass the name of a
function or method that does not yet exist on &lt;code>obj&lt;/code>, connect will
not fail, but will instead set up a stub method. Similarly, null
arguments may simply be omitted such that fewer than 4 arguments
may be required to set up a connection See the examples for details.

&lt;/p>
&lt;p>The return value is a handle that is needed to
remove this connection with &lt;code>dojo.disconnect&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>When obj.onchange(), do ui.update():&lt;/p>
&lt;pre>&lt;code>  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, ui.update); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using return value for disconnect:&lt;/p>
&lt;pre>&lt;code>  var link = dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  ...
  dojo.disconnect(link);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When onglobalevent executes, watcher.handler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;onglobalevent&amp;quot;, watcher, &amp;quot;handler&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, &amp;quot;customEventHandler&amp;quot;);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, &amp;quot;customEventHandler&amp;quot;); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, customEventHandler);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, customEventHandler); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When globalEvent executes, globalHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;globalEvent&amp;quot;, null, globalHandler);
  dojo.connect(&amp;quot;globalEvent&amp;quot;, globalHandler); // same&lt;/code>&lt;/pre>
</example></examples></method><method name="disconnect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>the return value of the dojo.connect call that created the connection.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a link created by dojo.connect.&lt;/p>
</summary><description>&lt;p>Removes the connection between event and the method referenced by handle.&lt;/p>
</description></method><method name="isCopyKey" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>Event object to examine&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)&lt;/p>
</summary></method><method name="unsubscribe" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>The handle returned from a call to subscribe.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a topic listener.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var alerter = dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); };
  ...
  dojo.unsubscribe(alerter);&lt;/code>&lt;/pre>
</example></examples></method><method name="_nodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="Object|String" usage="optional"><summary>&lt;p>If an object, act as a setter and iterate over said object setting data items as defined.
If a string, and &lt;code>value&lt;/code> present, set the data for defined &lt;code>key&lt;/code> to &lt;code>value&lt;/code>
If a string, and &lt;code>value&lt;/code> absent, act as a getter, returning the data associated with said &lt;code>key&lt;/code>
&lt;/p>
</summary></parameter><parameter name="value" type="Anything" usage="optional"><summary>&lt;p>The value to set for said &lt;code>key&lt;/code>, provided &lt;code>key&lt;/code> is a string (and not an object)
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Private helper for dojo/NodeList.data for single node data access. Refer to NodeList.data
documentation for more information.
&lt;/p>
</summary></method><method name="_removeNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="String" usage="optional"><summary>&lt;p>If omitted, remove all data in this dataset.
If passed, remove only the passed &lt;code>key&lt;/code> in the associated dataset&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove some data from this node&lt;/p>
</summary></method><method name="_gcNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters/><return-types/><summary>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.&lt;/p>
</summary><description>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.
MUCH safer to do this yourself, manually, on a per-node basis (via &lt;code>NodeList.removeData()&lt;/code>)
provided as a stop-gap for exceptionally large/complex applications with constantly changing
content regions (eg: a dijit/layout/ContentPane with replacing data)
There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
prior to destruction.&lt;/p>
</description></method><method name="safeMixin" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>Target object to accept new properties.&lt;/p>
</summary></parameter><parameter name="source" type="Object" usage="required"><summary>&lt;p>Source object for new properties.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Target object to accept new properties.&lt;/p>
</return-description><summary>&lt;p>Mix in properties skipping a constructor and decorating functions
like it is done by declare().&lt;/p>
</summary><description>&lt;p>This function is used to mix in properties like lang.mixin does,
but it skips a constructor property and decorates functions like
declare() does.

&lt;/p>
&lt;p>It is meant to be used with classes and objects produced with
declare. Functions mixed in with dojo.safeMixin can use
this.inherited() like normal methods.

&lt;/p>
&lt;p>This function is used to implement extend() method of a constructor
produced with declare().
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var A = declare(null, {
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m1&amp;quot;);
    }
  });
  B.extend({
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  dojo.safeMixin(x, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m1&amp;quot;);
    },
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m2&amp;quot;);
    }
  });
  x.m2();
  // prints:
  // A.m1
  // B.m1
  // X.m1&lt;/code>&lt;/pre>
</example></examples></method><method name="declare" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="className" type="String" usage="optional"><summary>&lt;p>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
It will be used as a global name for a created constructor.&lt;/p>
</summary></parameter><parameter name="superclass" type="Function|Function[]" usage="required"><summary>&lt;p>May be null, a Function, or an Array of Functions. This argument
specifies a list of bases (the left-most one is the most deepest
base).&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>An object whose properties are copied to the created prototype.
Add an instance-initialization function by making it a property
named &amp;quot;constructor&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/declare.__DeclareCreatedObject"/><return-type type="undefined"/></return-types><return-description>New constructor function.</return-description><summary>&lt;p>Create a feature-rich constructor from compact notation.&lt;/p>
</summary><description>&lt;p>Create a constructor using a compact notation for inheritance and
prototype extension.

&lt;/p>
&lt;p>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

&lt;/p>
&lt;p>Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see &lt;a href=&quot;http://www.python.org/download/releases/2.3/mro/&quot;>http://www.python.org/download/releases/2.3/mro/&lt;/a> for more
details).

&lt;/p>
&lt;p>&amp;quot;className&amp;quot; is cached in &amp;quot;declaredClass&amp;quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&amp;quot;superclass&amp;quot; property of the new class.

&lt;/p>
&lt;p>Methods in &amp;quot;props&amp;quot; will be copied and modified: &amp;quot;nom&amp;quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

&lt;/p>
&lt;p>It is possible to use constructors created &amp;quot;manually&amp;quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &amp;quot;this.inherited()&amp;quot;.

&lt;/p>
&lt;p>Special property &amp;quot;-chains-&amp;quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &amp;quot;after&amp;quot;, this method will be
called after methods of its base classes. If a hint string is
&amp;quot;before&amp;quot;, this method will be called before methods of its base
classes.

&lt;/p>
&lt;p>If &amp;quot;constructor&amp;quot; is not mentioned in &amp;quot;-chains-&amp;quot; property, it will
be chained using the legacy mode: using &amp;quot;after&amp;quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &amp;quot;after&amp;quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&amp;quot;constructor&amp;quot; cannot be chained &amp;quot;before&amp;quot;, but it allows
a special hint string: &amp;quot;manual&amp;quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

&lt;/p>
&lt;p>All chaining hints are &amp;quot;inherited&amp;quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

&lt;/p>
&lt;p>Once a method was chained, it is impossible to unchain it. The
only exception is &amp;quot;constructor&amp;quot;. You don&amp;#39;t need to define a
method in order to supply a chaining hint.

&lt;/p>
&lt;p>If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

&lt;/p>
&lt;p>Usually constructors and initializers of any kind are chained
using &amp;quot;after&amp;quot; and destructors of any kind are chained as
&amp;quot;before&amp;quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  declare(&amp;quot;my.classes.bar&amp;quot;, my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
      this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
      doStuff();
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var F = function(){ console.log(&amp;quot;raw constructor&amp;quot;); };
  F.prototype.method = function(){
    console.log(&amp;quot;raw method&amp;quot;);
  };
  var A = declare(F, {
    constructor: function(){
      console.log(&amp;quot;A.constructor&amp;quot;);
    },
    method: function(){
      console.log(&amp;quot;before calling F.method...&amp;quot;);
      this.inherited(arguments);
      console.log(&amp;quot;...back in A&amp;quot;);
    }
  });
  new A().method();
  // will print:
  // raw constructor
  // A.constructor
  // before calling F.method...
  // raw method
  // ...back in A&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      destroy: &amp;quot;before&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      console.log(&amp;quot;B.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;B.destroy&amp;quot;);
    }
  });
  var C = declare(B, {
    constructor: function(){
      console.log(&amp;quot;C.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;C.destroy&amp;quot;);
    }
  });
  new C().destroy();
  // prints:
  // B.constructor
  // C.constructor
  // C.destroy
  // B.destroy&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      constructor: &amp;quot;manual&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      // ...
      // call the base constructor with new parameters
      this.inherited(arguments, [1, 2, 3]);
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      m1: &amp;quot;before&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    &amp;quot;-chains-&amp;quot;: {
      m2: &amp;quot;after&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;B.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  x.m1();
  // prints:
  // B.m1
  // A.m1
  x.m2();
  // prints:
  // A.m2
  // B.m2&lt;/code>&lt;/pre>
</example></examples></method><method name="Color" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types/><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and creates a new Color instance to work from.
&lt;/p>
</summary><examples><example>&lt;p>Work with a Color instance:&lt;/p>
&lt;pre>&lt;code> var c = new Color();
 c.setColor([0,0,0]); // black
 var hex = c.toHex(); // #000000&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Work with a node&amp;#39;s color:&lt;/p>
&lt;pre>&lt;code> var color = dojo.style(&amp;quot;someNode&amp;quot;, &amp;quot;backgroundColor&amp;quot;);
 var n = new Color(color);
 // adjust the color some
 n.r *= .5;
 console.log(n.toString()); // rgb(128, 255, 255);&lt;/code>&lt;/pre>
</example></examples></method><method name="blendColors" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="start" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="end" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="weight" type="Number" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>
</summary></method><method name="colorFromRgb" scope="normal" type="function" from="dojo/colors"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="dojo/_base/Color" usage="optional"/></parameters><return-types/><summary>&lt;p>get rgb(a) array from css-style color declarations&lt;/p>
</summary><description>&lt;p>this function can handle all 4 CSS3 Color Module formats: rgb,
rgba, hsl, hsla, including rgb(a) with percentage values.&lt;/p>
</description></method><method name="colorFromHex" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.
</return-description><summary>&lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#ededed&amp;quot;); // grey, longhand&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#000&amp;quot;); // black, shorthand&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromArray" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="a" type="Array" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromString" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="str" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromArray: &lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Parses &lt;code>str&lt;/code> for a color value. Accepts hex, rgb, and rgba
style color values.&lt;/p>
</summary><description>&lt;p>Acceptable input values for str may include arrays of any form
accepted by dojo.colorFromArray, hex strings such as &amp;quot;#aaaaaa&amp;quot;, or
rgb or rgba strings such as &amp;quot;rgb(133, 200, 16)&amp;quot; or &amp;quot;rgba(10, 10,
10, 50)&amp;quot;&lt;/p>
</description></method><method name="_Line" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="start" type="int" usage="required"><summary>&lt;p>Beginning value for range&lt;/p>
</summary></parameter><parameter name="end" type="int" usage="required"><summary>&lt;p>Ending value for range&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Object used to generate values from a start value to an end value&lt;/p>
</summary></method><method name="Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="_fade" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns an animation that will fade the node defined by
args.node from the start to end values passed (args.start
args.end) (end is mandatory, start is optional)&lt;/p>
</summary></method><method name="fadeIn" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to show the node&lt;/p>
</summary></method><method name="fadeOut" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to hide the node&lt;/p>
</summary></method><method name="_defaultEasing" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types/><summary>&lt;p>The default easing function for Animation(s)&lt;/p>
</summary></method><method name="animateProperty" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>properties (Object, optional): &lt;p>A hash map of style properties to Objects describing the transition,
such as the properties of _Line with an additional &amp;#39;units&amp;#39; property&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns an animation that will transition the properties of
node defined in &lt;code>args&lt;/code> depending how they are defined in
&lt;code>args.properties&lt;/code>
&lt;/p>
</summary><description>&lt;p>Foundation of most &lt;code>dojo/_base/fx&lt;/code>
animations. It takes an object of &amp;quot;properties&amp;quot; corresponding to
style properties, and animates them in parallel over a set
duration.
&lt;/p>
</description><examples><example>&lt;p>A simple animation that changes the width of the specified node.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    properties: { width: 400 },
  }).play();&lt;/code>&lt;/pre>
&lt;p>Dojo figures out the start value for the width and converts the
integer specified for the width to the more expressive but
verbose form &lt;code>{ width: { end: &amp;#39;400&amp;#39;, units: &amp;#39;px&amp;#39; } }&lt;/code> which you
can also specify directly. Defaults to &amp;#39;px&amp;#39; if omitted.
&lt;/p>
</example><example>&lt;p>Animate width, height, and padding over 2 seconds... the
pedantic way:&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({ node: node, duration:2000,
    properties: {
      width: { start: &amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      height: { start:&amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      paddingTop: { start:&amp;#39;5&amp;#39;, end:&amp;#39;50&amp;#39;, units:&amp;quot;px&amp;quot; }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>Note &amp;#39;paddingTop&amp;#39; is used over &amp;#39;padding-top&amp;#39;. Multi-name CSS properties
are written using &amp;quot;mixed case&amp;quot;, as the hyphen is illegal as an object key.
&lt;/p>
</example><example>&lt;p>Plug in a different easing function and register a callback for
when the animation ends. Easing functions accept values between
zero and one and return a value on that basis. In this case, an
exponential-in curve.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    // dojo figures out the start value
    properties: { width: { end: 400 } },
    easing: function(n){
      return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
    },
    onEnd: function(node){
      // called when the animation finishes. The animation
      // target is passed to this function
    }
  }).play(500); // delay playing half a second&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Like all &lt;code>Animation&lt;/code>s, animateProperty returns a handle to the
Animation instance, which fires the events common to Dojo FX. Use &lt;code>aspect.after&lt;/code>
to access these events outside of the Animation definition:&lt;/p>
&lt;pre>&lt;code>  var anim = basefx.animateProperty({
    node:&amp;quot;someId&amp;quot;,
    properties:{
      width:400, height:500
    }
  });
  aspect.after(anim, &amp;quot;onEnd&amp;quot;, function(){
    console.log(&amp;quot;animation ended&amp;quot;);
  }, true);
  // play the animation now:
  anim.play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Each property can be a function whose return value is substituted along.
Additionally, each measurement (eg: start, end) can be a function. The node
reference is passed directly to callbacks.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node:&amp;quot;mine&amp;quot;,
    properties:{
      height:function(node){
        // shrink this node by 50%
        return domGeom.position(node).h / 2
      },
      width:{
        start:function(node){ return 100; },
        end:function(node){ return 200; }
      }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="anim" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>a DOM node or the id of a node to animate CSS properties on&lt;/p>
</summary></parameter><parameter name="properties" type="Object" usage="required"/><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds over which the animation
should run. Defaults to the global animation default duration
(350ms).&lt;/p>
</summary></parameter><parameter name="easing" type="Function" usage="optional"><summary>&lt;p>An easing function over which to calculate acceleration
and deceleration of the animation through its duration.
A default easing algorithm is provided, but you may
plug in any you wish. A large selection of easing algorithms
are available in &lt;code>dojo/fx/easing&lt;/code>.&lt;/p>
</summary></parameter><parameter name="onEnd" type="Function" usage="optional"><summary>&lt;p>A function to be called when the animation finishes
running.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds to delay beginning the
animation by. The default is 0.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A simpler interface to &lt;code>animateProperty()&lt;/code>, also returns
an instance of &lt;code>Animation&lt;/code> but begins the animation
immediately, unlike nearly every other Dojo animation API.&lt;/p>
</summary><description>&lt;p>Simpler (but somewhat less powerful) version
of &lt;code>animateProperty&lt;/code>.  It uses defaults for many basic properties
and allows for positional parameters to be used in place of the
packed &amp;quot;property bag&amp;quot; which is used for other Dojo animation
methods.

&lt;/p>
&lt;p>The &lt;code>Animation&lt;/code> object returned will be already playing, so
calling play() on it again is (usually) a no-op.&lt;/p>
</description><examples><example>&lt;p>Fade out a node&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 });&lt;/code>&lt;/pre>
</example><example>&lt;p>Fade out a node over a full second&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 }, 1000);&lt;/code>&lt;/pre>
</example></examples></method><method name="_Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="addOnLoad" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="ready" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="byId" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="id" type="String|DOMNode" usage="required"><summary>&lt;p>A string to match an HTML id attribute or a reference to a DOM Node
&lt;/p>
</summary></parameter><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Document to work in. Defaults to the current value of
dojo.doc.  Can be used to retrieve
node references from other documents.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns DOM node with matching &lt;code>id&lt;/code> attribute or falsy value (ex: null or undefined)
if not found.  If &lt;code>id&lt;/code> is a DomNode, this function is a no-op.
&lt;/p>
</summary><examples><example>&lt;p>Look up a node by ID:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Check if a node exists, and use it.&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;bar&amp;quot;);
  if(n){ doStuff() ... }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Allow string or DomNode references to be passed to a custom function:&lt;/p>
&lt;pre>&lt;code>  var foo = function(nodeOrId){
    nodeOrId = dojo.byId(nodeOrId);
    // ... more stuff
  }&lt;/code>&lt;/pre>
</example></examples></method><method name="isDescendant" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference to test&lt;/p>
</summary></parameter><parameter name="ancestor" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference of potential parent to test against
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if node is a descendant of ancestor&lt;/p>
</summary><examples><example>&lt;p>Test is node id=&amp;quot;bar&amp;quot; is a descendant of node id=&amp;quot;foo&amp;quot;&lt;/p>
&lt;pre>&lt;code>  if(dojo.isDescendant(&amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="setSelectable" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="selectable" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/><return-type type="null"/></return-types><return-description>the value of the requested attribute or null if that attribute does not have a specified or
default value;
</return-description><summary>&lt;p>Gets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of attributes on DOM Nodes.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.getAttr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to set, or a hash of key-value pairs to set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>the value to set for the attribute, if the name is a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of attributes on DOM Nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.setAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setAttr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.setStyle(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to check&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>true if the requested attribute is specified on the
given element, and false otherwise</return-description><summary>&lt;p>Returns true if the requested attribute is specified on the
given element, and false otherwise.&lt;/p>
</summary></method><method name="removeAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to remove&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes an attribute from an HTML element.&lt;/p>
</summary></method><method name="getNodeProp" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the attribute</return-description><summary>&lt;p>Returns an effective value of a property or an attribute.&lt;/p>
</summary></method><method name="attr" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested attribute
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of attributes on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.attr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.attr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to check the class for.&lt;/p>
</summary></parameter><parameter name="classStr" type="String" usage="required"><summary>&lt;p>A string class name to look for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Returns whether or not the specified classes are a portion of the
class list currently applied to the node.&lt;/p>
</summary><examples><example>&lt;p>Do something if a node with id=&amp;quot;someNode&amp;quot; has class=&amp;quot;aSillyClassName&amp;quot; present&lt;/p>
&lt;pre>&lt;code>  if(dojo.hasClass(&amp;quot;someNode&amp;quot;,&amp;quot;aSillyClassName&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="addClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to add a class string too
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds the specified classes to the end of the class list on the
passed node. Will not re-apply duplicate classes.
&lt;/p>
</summary><examples><example>&lt;p>Add a class to some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;anewClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple additions&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).addClass(&amp;quot;firstLevel&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="removeClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="optional"><summary>&lt;p>An optional String class name to remove, or several space-separated
class names, or an array of class names. If omitted, all class names
will be deleted.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes the specified classes from node. No &lt;code>contains()&lt;/code>
check is required.
&lt;/p>
</summary><examples><example>&lt;p>Remove a class from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove all classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple removal&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).removeClass(&amp;quot;foo&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toggleClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to toggle a class string
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to toggle, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="condition" type="Boolean" usage="optional"><summary>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</return-description><summary>&lt;p>Adds a class to node if not present, or removes if present.
Pass a boolean condition if you want to explicitly add or remove.
Returns the condition that was specified directly or indirectly.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Forcefully add a class&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;, true);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.toggleMe&amp;quot;).toggleClass(&amp;quot;toggleMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="replaceClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="addClassStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="removeClassStr" type="String|Array" usage="optional"><summary>&lt;p>A String class name to remove, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Replaces one or more classes on a node if not present.
Operates more quickly than calling dojo.removeClass and dojo.addClass
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;add1 add2&amp;quot;, &amp;quot;remove1 remove2&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Replace all classes with addMe&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;addMe&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.findMe&amp;quot;).replaceClass(&amp;quot;addMe&amp;quot;, &amp;quot;removeMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="_toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="place" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference to use as basis for placement&lt;/p>
</summary></parameter><parameter name="position" type="String|Number" usage="optional"><summary>&lt;p>string noting the position of node relative to refNode or a
number indicating the location in the childNodes collection of refNode.
Accepted string values are:

&lt;/p>
&lt;ul>
&lt;li>before&lt;/li>
&lt;li>after&lt;/li>
&lt;li>replace&lt;/li>
&lt;li>only&lt;/li>
&lt;li>first&lt;/li>
&lt;li>last&lt;/li>
&lt;/ul>
&lt;p>&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified&lt;/p>
</summary></parameter></parameters><return-types><return-type type="DOMNode"/><return-type type="undefined"/></return-types><return-description>Returned values is the first argument resolved to a DOM node.

.place() is also a method of `dojo/NodeList`, allowing `dojo.query` node lookups.</return-description><summary>&lt;p>Attempt to insert node into the DOM, choosing from various positioning options.
Returns the first argument resolved to a DOM node.&lt;/p>
</summary><examples><example>&lt;p>Place a node by string id as the last child of another node by string id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Place a node by string id before another node by string id&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;, &amp;quot;before&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Create a Node, and place it in the body element (last child):&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;, dojo.body());&lt;/code>&lt;/pre>
</example><example>&lt;p>Put a new LI as the first child of a list by id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;, &amp;quot;someUl&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="create" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="tag" type="DOMNode|String" usage="required"><summary>&lt;p>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
or an existing DOM node to process.&lt;/p>
</summary></parameter><parameter name="attrs" type="Object" usage="required"><summary>&lt;p>An object-hash of attributes to set on the newly created node.
Can be null, if you don&amp;#39;t want to set any attributes/styles.
See: &lt;code>dojo.setAttr&lt;/code> for a description of available attributes.&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="optional"><summary>&lt;p>Optional reference node. Used by &lt;code>dojo.place&lt;/code> to place the newly created
node somewhere in the dom relative to refNode. Can be a DomNode reference
or String ID of a node.&lt;/p>
</summary></parameter><parameter name="pos" type="String" usage="optional"><summary>&lt;p>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code>dojo.place&lt;/code>,
though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
to further control the placement of the new node relative to the refNode.
&amp;#39;refNode&amp;#39; is required if a &amp;#39;pos&amp;#39; is specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create an element, allowing for optional attribute decoration
and placement.&lt;/p>
</summary><description>&lt;p>A DOM Element creation function. A shorthand method for creating a node or
a fragment, and allowing for a convenient optional attribute setting step,
as well as an optional DOM placement reference.

&lt;/p>
&lt;p>Attributes are set by passing the optional object through &lt;code>dojo.setAttr&lt;/code>.
See &lt;code>dojo.setAttr&lt;/code> for noted caveats and nuances, and API if applicable.

&lt;/p>
&lt;p>Placement is done via &lt;code>dojo.place&lt;/code>, assuming the new node to be the action
node, passing along the optional reference node and position.&lt;/p>
</description><examples><example>&lt;p>Create a DIV:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a DIV with content:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, { innerHTML:&amp;quot;&amp;lt;p&amp;gt;hi&amp;lt;/p&amp;gt;&amp;quot; });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Place a new DIV in the BODY, with no attributes set&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, null, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an UL, and populate it with LI&amp;#39;s. Place the list as the first-child of a
node with id=&amp;quot;someId&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  var ul = dojo.create(&amp;quot;ul&amp;quot;, null, &amp;quot;someId&amp;quot;, &amp;quot;first&amp;quot;);
  var items = [&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;];
  dojo.forEach(items, function(data){
    dojo.create(&amp;quot;li&amp;quot;, { innerHTML: data }, ul);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an anchor, with an href. Place in BODY:&lt;/p>
&lt;pre>&lt;code>  dojo.create(&amp;quot;a&amp;quot;, { href:&amp;quot;foo.html&amp;quot;, title:&amp;quot;Goto FOO!&amp;quot; }, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a &lt;code>dojo/NodeList()&lt;/code> from a new element (for syntactic sugar):&lt;/p>
&lt;pre>&lt;code>  dojo.query(dojo.create(&amp;#39;div&amp;#39;))
    .addClass(&amp;quot;newDiv&amp;quot;)
    .onclick(function(e){ console.log(&amp;#39;clicked&amp;#39;, e.target) })
    .place(&amp;quot;#someNode&amp;quot;); // redundant, but cleaner.&lt;/code>&lt;/pre>
</example></examples></method><method name="empty" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="destroy" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="_destroyElement" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="_getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="_getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="_getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="setMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;l&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>sets the size of the node&amp;#39;s margin box and placement
(left/top), irrespective of box model. Think of it as a
passthrough to setBox that handles box-model vagaries for
you.&lt;/p>
</summary></method><method name="getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="_getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="setContentSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the size of the node&amp;#39;s contents, irrespective of margins,
padding, or borders.&lt;/p>
</summary></method><method name="isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="_isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="_docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="_getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="_fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="position" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Object"/><return-type type="object"/></return-types><summary>&lt;p>Gets the position and size of the passed element relative to
the viewport (if includeScroll==false), or relative to the
document root (if includeScroll==true).
&lt;/p>
</summary><description>&lt;p>Returns an object of the form:
&lt;code>{ x: 100, y: 300, w: 20, h: 15 }&lt;/code>.
If includeScroll==true, the x and y values will include any
document offsets that may affect the position relative to the
viewport.
Uses the border-box model (inclusive of border and padding but
not margin).  Does not act as a setter.&lt;/p>
</description></method><method name="marginBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.marginBox() should
update/set the margin box for node. Box is an object in the
above format. All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the margin-box of node.&lt;/p>
</summary><description>&lt;p>Getter/setter for the margin-box of node.
Returns an object in the expected format of box (regardless
if box is passed). The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a margin width of 300px and a margin-height of
150px.&lt;/p>
</description><examples><example>&lt;p>Retrieve the margin box of a passed node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  console.dir(box);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set a node&amp;#39;s margin box to the size of another node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  dojo.marginBox(&amp;quot;someOtherNode&amp;quot;, box);&lt;/code>&lt;/pre>
</example></examples></method><method name="contentBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.contentBox() should
update/set the content box for node. Box is an object in the
above format, but only w (width) and h (height) are supported.
All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the content-box of node.&lt;/p>
</summary><description>&lt;p>Returns an object in the expected format of box (regardless if box is passed).
The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a content width of 300px and a content-height of
150px. Note that the content box may have a much larger border
or margin box, depending on the box model currently in use and
CSS values set/inherited for node.
While the getter will return top and left values, the
setter only accepts setting the width and height.&lt;/p>
</description></method><method name="coords" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated: Use position() for border-box x/y/w/h
or marginBox() for margin-box w/h/l/t.

&lt;/p>
&lt;p>Returns an object that measures margin-box (w)idth/(h)eight
and absolute position x/y of the border-box. Also returned
is computed (l)eft and (t)op values in pixels from the
node&amp;#39;s offsetParent as returned from marginBox().
Return value will be in the form:&lt;/p>
&lt;pre>&lt;code>      { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }&lt;/code>&lt;/pre>
&lt;p>Does not act as a setter. If includeScroll is passed, the x and
y params are affected as one would expect in dojo.position().&lt;/p>
</summary></method><method name="getProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the property on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the property to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the requested property or its default value
</return-description><summary>&lt;p>Gets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of properties on DOM nodes.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.getProp(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getProp(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to set, or a hash object to set
multiple properties at once.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of properties on DOM nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.setProp(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setProp(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="prop" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested property
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of properties on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.prop(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.prop(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="getStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get style for&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="optional"><summary>&lt;p>the style property to get&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Accesses styles on a node.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
</example></examples></method><method name="setStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><return-description>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</return-description><summary>&lt;p>Sets styles on a node.&lt;/p>
</summary><examples><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo.query()&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="getComputedStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>A reference to a DOM node. Does NOT support taking an
ID string for speed reasons.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &amp;quot;computed style&amp;quot; object.
&lt;/p>
</summary><description>&lt;p>Gets a &amp;quot;computed style&amp;quot; object which can be used to gather
information about the current state of the rendered node.

&lt;/p>
&lt;p>Note that this may behave differently on different browsers.
Values may have different formats and value encodings across
browsers.

&lt;/p>
&lt;p>Note also that this method is expensive.  Wherever possible,
reuse the returned object.

&lt;/p>
&lt;p>Use the dojo.style() method for more consistent (pixelized)
return values.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.getComputedStyle(dojo.byId(&amp;#39;foo&amp;#39;)).borderWidth;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Reusing the returned object, avoiding multiple lookups:&lt;/p>
&lt;pre>&lt;code>  var cs = dojo.getComputedStyle(dojo.byId(&amp;quot;someNode&amp;quot;));
  var w = cs.width, h = cs.height;&lt;/code>&lt;/pre>
</example></examples></method><method name="toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="__toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="style" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get/set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="optional"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, return the computed style of the node if passing in an ID or node,
or return the normalized, computed value for the property when passing in a node and a style property</return-description><summary>&lt;p>Accesses styles on a node. If 2 arguments are
passed, acts as a getter. If 3 arguments are passed, acts
as a setter.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo/query&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_Url" scope="normal" type="function" from="dojo/_base/url"><parameters/><return-types/></method><method name="fromJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="js" type="String" usage="required"><summary>&lt;p>a string literal of a JavaScript expression, for instance:
&lt;code>&amp;#39;{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }&amp;#39;&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Parses a JavaScript expression and returns a JavaScript value.&lt;/p>
</summary><description>&lt;p>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
always delegates to eval(). The content passed to this method must therefore come
from a trusted source.
It is recommend that you use dojo/json&amp;#39;s parse function for an
implementation uses the (faster) native JSON parse when available.&lt;/p>
</description></method><method name="_escapeString" scope="normal" type="function" from="dojo/json"><parameters><parameter name="value" type="undefined" usage="required"><summary>&lt;p>A value to be serialized.&lt;/p>
</summary></parameter><parameter name="replacer" type="undefined" usage="required"><summary>&lt;p>A replacer function that is called for each value and can return a replacement&lt;/p>
</summary></parameter><parameter name="spacer" type="undefined" usage="required"><summary>&lt;p>A spacer string to be used for pretty printing of JSON&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
This function follows &lt;a href=&quot;https://developer.mozilla.org/en/JSON&quot;>native JSON API&lt;/a>
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/json&amp;quot;], function(JSON){
    var jsonStr = JSON.stringify({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
    doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example></examples></method><method name="toJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="it" type="Object" usage="required"><summary>&lt;p>an object to be serialized. Objects may define their own
serialization via a special &amp;quot;&lt;strong>json&lt;/strong>&amp;quot; or &amp;quot;json&amp;quot; function
property. If a specialized serializer has been defined, it will
be used as a fallback.
Note that in 1.6, toJson would serialize undefined, but this no longer supported
since it is not supported by native JSON serializer.&lt;/p>
</summary></parameter><parameter name="prettyPrint" type="Boolean" usage="optional"><summary>&lt;p>if true, we indent objects and arrays to make the output prettier.
The variable &lt;code>dojo.toJsonIndentStr&lt;/code> is used as the indent string --
to use something other than the default (tab), change that variable
before calling dojo.toJson().
Note that if native JSON support is available, it will be used for serialization,
and native implementations vary on the exact spacing used in pretty printing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A JSON string serialization of the passed-in object.</return-description><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!
It is recommend that you use dojo/json&amp;#39;s stringify function for an lighter
and faster implementation that matches the native JSON API and uses the
native JSON serializer when available.&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  var jsonStr = dojo.toJson({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
  doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example><example>&lt;p>a custom serializer for an objects of a particular class:&lt;/p>
&lt;pre>&lt;code>  dojo.declare(&amp;quot;Furby&amp;quot;, null, {
    furbies: &amp;quot;are strange&amp;quot;,
    furbyCount: 10,
    __json__: function(){
    },
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="Stateful" scope="normal" type="constructor" from="dojo/Stateful"><parameters/><return-types/></method><method name="windowUnloaded" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>signal fired by impending window destruction. You may use
dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
page/application cleanup methods. See dojo.addOnWindowUnload for more info.&lt;/p>
</summary></method><method name="addOnWindowUnload" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="obj" type="Object" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when window.onunload fires.
Be careful trying to modify the DOM or access JavaScript properties
during this phase of page unloading: they may not always be available.
Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
JavaScript work.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.addOnWindowUnload(functionPointer)
  dojo.addOnWindowUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnWindowUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="addOnUnload" scope="normal" type="function" from="dojo/_base/unload"><parameters><parameter name="obj" type="Object?|Function" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when the page unloads.&lt;/p>
</summary><description>&lt;p>The first time that addOnUnload is called Dojo will
register a page listener to trigger your unload handler
with.

&lt;/p>
&lt;p>In a browser environment, the functions will be triggered
during the window.onbeforeunload event. Be careful of doing
too much work in an unload handler. onbeforeunload can be
triggered if a link to download a file is clicked, or if
the link is a javascript: link. In these cases, the
onbeforeunload event fires, but the document is not
actually destroyed. So be careful about doing destructive
operations in a dojo.addOnUnload callback.

&lt;/p>
&lt;p>Further note that calling dojo.addOnUnload will prevent
browsers from using a &amp;quot;fast back&amp;quot; cache to make page
loading via back button instantaneous.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.addOnUnload(functionPointer)
  dojo.addOnUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="_xhrObj" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/></method><method name="objectToQuery" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="map" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>takes a name/value mapping object and returns a string representing
a URL-encoded version of that object.&lt;/p>
</summary><examples><example>&lt;p>this object:

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields the following query string:

&lt;/p>
&lt;pre>&lt;code>  &amp;quot;blah=blah&amp;amp;multi=thud&amp;amp;multi=thonk&amp;quot;&lt;/code>&lt;/pre>
</example></examples></method><method name="queryToObject" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="str" type="String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Create an object representing a de-serialized query section of a
URL. Query keys with multiple values are returned in an array.
&lt;/p>
</summary><examples><example>&lt;p>This string:

&lt;/p>
&lt;pre>&lt;code>    &amp;quot;foo=bar&amp;amp;foo=baz&amp;amp;thinger=%20spaces%20=blah&amp;amp;zonk=blarg&amp;amp;&amp;quot;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>results in this object structure:

&lt;/p>
&lt;pre>&lt;code>    {
      foo: [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ],
      thinger: &amp;quot; spaces =blah&amp;quot;,
      zonk: &amp;quot;blarg&amp;quot;
    }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that spaces and other urlencoded entities are correctly
handled.&lt;/p>
</example></examples></method><method name="fieldToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="inputNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Serialize a form field to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the value encoded in a form field as
as a string or an array of strings. Disabled form elements
and unchecked radio and checkboxes are skipped.  Multi-select
elements are returned as an array of string values.&lt;/p>
</description></method><method name="formToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Serialize a form node to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the values encoded in an HTML form as
string properties in an object which it then returns. Disabled form
elements, buttons, and other non-value form elements are skipped.
Multi-select elements are returned as an array of string values.&lt;/p>
</description><examples><example>&lt;p>This form:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;form id=&amp;quot;test_form&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blah&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;no_value&amp;quot; value=&amp;quot;blah&amp;quot; disabled&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;no_value2&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;select type=&amp;quot;select&amp;quot; multiple name=&amp;quot;multi&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;
      &amp;lt;option value=&amp;quot;blah&amp;quot;&amp;gt;blah&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thud&amp;quot; selected&amp;gt;thud&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thonk&amp;quot; selected&amp;gt;thonk&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields this object structure as the result of a call to
formToObject():

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="formToQuery" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns a URL-encoded string representing the form passed as either a
node or string ID identifying the form to serialize&lt;/p>
</summary></method><method name="formToJson" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/><parameter name="prettyPrint" type="Boolean" usage="optional"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Create a serialized JSON string from a form node or string
ID identifying the form to serialize&lt;/p>
</summary></method><method name="__IoArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoCallbackArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoPublish" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="_ioSetArgs" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="dojo/main.__IoArgs" usage="required"><summary>&lt;p>The args object passed into the public io call. Recognized properties on
the args object are:&lt;/p>
</summary></parameter><parameter name="canceller" type="Function" usage="required"><summary>&lt;p>The canceller function used for the Deferred object. The function
will receive one argument, the Deferred object that is related to the
canceller.&lt;/p>
</summary></parameter><parameter name="okHandler" type="Function" usage="required"><summary>&lt;p>The first OK callback to be registered with Deferred. It has the opportunity
to transform the OK response. It will receive one argument -- the Deferred
object returned from this function.&lt;/p>
</summary></parameter><parameter name="errHandler" type="Function" usage="required"><summary>&lt;p>The first error callback to be registered with Deferred. It has the opportunity
to do cleanup on an error. It will receive two arguments: error (the
Error object) and dfd, the Deferred object returned from this function.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>sets up the Deferred and ioArgs property on the Deferred so it
can be used in an io call.&lt;/p>
</summary></method><method name="_ioCancelAll" scope="normal" type="function" from="dojo/_base/xhr"><parameters/><return-types/><summary>&lt;p>Cancels all pending IO requests, regardless of IO type
(xhr, script, iframe).&lt;/p>
</summary></method><method name="_ioNotifyStart" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>If dojo.publish is available, publish topics
about the start of a request queue and/or the
the beginning of request.

&lt;/p>
&lt;p>Used by IO transports. An IO transport should
call this method before making the network connection.&lt;/p>
</summary></method><method name="_ioWatch" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter><parameter name="validCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if the IO request is still valid. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="ioCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if basic IO call worked. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="resHandle" type="Function" usage="required"><summary>&lt;p>Function used to process response. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></method><method name="_ioAddQueryToUrl" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="ioArgs" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>args (Object): &lt;p>the original object argument to the IO call.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>xhr (XMLHttpRequest): &lt;p>For XMLHttpRequest calls only, the
XMLHttpRequest object that was used for the
request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>The final URL used for the call. Many times it
will be different than the original args.url
value.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>query (String): &lt;p>For non-GET requests, the
name1=value1&amp;amp;name2=value2 parameters sent up in
the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handleAs (String): &lt;p>The final indicator on how the response will be
handled.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String): &lt;p>For dojo/io/script calls only, the internal
script ID used for the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>canDelete (Boolean): &lt;p>For dojo/io/script calls only, indicates
whether the script tag that represents the
request can be deleted after callbacks have
been called. Used internally to know when
cleanup can happen on JSONP-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>json (Object): &lt;p>For dojo/io/script calls only: holds the JSON
response for JSONP-type requests. Used
internally to hold on to the JSON responses.
You should not need to access it directly --
the same object should be passed to the success
callbacks directly.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Adds query params discovered by the io deferred construction to the URL.
Only use this for operations which are fundamentally GET-type operations.&lt;/p>
</summary></method><method name="__XhrArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="xhr" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="method" type="String" usage="required"><summary>&lt;p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="hasBody" type="Boolean" usage="optional"><summary>&lt;p>If the request has an HTTP body, then pass true for hasBody.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deprecated.   Use dojo/request instead.&lt;/p>
</summary><description>&lt;p>Sends an HTTP request with the given method.
See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
for those HTTP methods. There are also methods for &amp;quot;raw&amp;quot; PUT and POST methods
via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.&lt;/p>
</description></method><method name="xhrGet" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP GET request to the server.&lt;/p>
</summary></method><method name="xhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrDelete" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP DELETE request to the server.&lt;/p>
</summary></method><method name="_isDocumentOk" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="http" type="undefined" usage="required"/></parameters><return-types/></method><method name="_getText" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="uri" type="URI" usage="required"><summary>&lt;p>A relative or absolute uri. If absolute, it still must be in
the same &amp;quot;domain&amp;quot; as we are.&lt;/p>
</summary></parameter><parameter name="fail_ok" type="Boolean" usage="required"><summary>&lt;p>Default false. If fail_ok and loading fails, return null
instead of throwing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The response text. null is returned when there is a
failure and failure is okay (an exception otherwise)</return-description><summary>&lt;p>Read the contents of the specified uri and return those contents.&lt;/p>
</summary></method><method name="_loadUri" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="uri" type="undefined" usage="required"/></parameters><return-types/></method><method name="pushContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="Object|String" usage="optional"><summary>&lt;p>The global context. If a string, the id of the frame to
search for a context and document.&lt;/p>
</summary></parameter><parameter name="d" type="MDocumentElement" usage="optional"><summary>&lt;p>The document element to execute subsequent code with.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>causes subsequent calls to Dojo methods to assume the
passed object and, optionally, document as the default
scopes to use. A 2-element array of the previous global and
document are returned.&lt;/p>
</summary><description>&lt;p>dojo.pushContext treats contexts as a stack. The
auto-detected contexts which are initially provided using
dojo.setContext() require authors to keep state in order to
&amp;quot;return&amp;quot; to a previous context, whereas the
dojo.pushContext and dojo.popContext methods provide a more
natural way to augment blocks of code to ensure that they
execute in a different window or frame without issue. If
called without any arguments, the default context (the
context when Dojo is first loaded) is instead pushed into
the stack. If only a single string is passed, a node in the
intitial context&amp;#39;s document is looked up and its
contextWindow and contextDocument properties are used as
the context to push. This means that iframes can be given
an ID and code can be executed in the scope of the iframe&amp;#39;s
document in subsequent calls easily.&lt;/p>
</description></method><method name="popContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>If the context stack contains elements, ensure that
subsequent code executes in the &lt;em>previous&lt;/em> context to the
current context. The current context set ([global,
document]) is returned.&lt;/p>
</summary></method><method name="_inContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="d" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="_loadInit" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_spidermonkeyCurrentFile" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="depth" type="undefined" usage="required"/></parameters><return-types/></method><method name="provide" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="mid" type="undefined" usage="required"/></parameters><return-types/></method><method name="require" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>module name to load, using periods for separators,
e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo&amp;#39;s
internal mapping of locations to names and are disambiguated by
longest prefix. See &lt;code>dojo.registerModulePath()&lt;/code> for details on
registering new modules.
&lt;/p>
</summary></parameter><parameter name="omitModuleCheck" type="Boolean" usage="optional"><summary>&lt;p>if &lt;code>true&lt;/code>, omitModuleCheck skips the step of ensuring that the
loaded file actually defines the symbol it is referenced by.
For example if it called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;)&lt;/code> and the
file located at &lt;code>a/b/c.js&lt;/code> does not define an object &lt;code>a.b.c&lt;/code>,
and exception will be throws whereas no exception is raised
when called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;, true)&lt;/code>
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the required namespace object</return-description><summary>&lt;p>loads a Javascript module from the appropriate URI
&lt;/p>
</summary><description>&lt;p>Modules are loaded via dojo.require by using one of two loaders: the normal loader
and the xdomain loader. The xdomain loader is used when dojo was built with a
custom build that specified loader=xdomain and the module lives on a modulePath
that is a whole URL, with protocol and a domain. The versions of Dojo that are on
the Google and AOL CDNs use the xdomain loader.

&lt;/p>
&lt;p>If the module is loaded via the xdomain loader, it is an asynchronous load, since
the module is added via a dynamically created script tag. This
means that dojo.require() can return before the module has loaded. However, this
should only happen in the case where you do dojo.require calls in the top-level
HTML page, or if you purposely avoid the loader checking for dojo.require
dependencies in your module by using a syntax like dojo[&amp;quot;require&amp;quot;] to load the module.

&lt;/p>
&lt;p>Sometimes it is useful to not have the loader detect the dojo.require calls in the
module so that you can dynamically load the modules as a result of an action on the
page, instead of right at module load time.

&lt;/p>
&lt;p>Also, for script blocks in an HTML page, the loader does not pre-process them, so
it does not know to download the modules before the dojo.require calls occur.

&lt;/p>
&lt;p>So, in those two cases, when you want on-the-fly module loading or for script blocks
in the HTML page, special care must be taken if the dojo.required code is loaded
asynchronously. To make sure you can execute code that depends on the dojo.required
modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
executing.

&lt;/p>
&lt;p>This type of syntax works with both xdomain and normal loaders, so it is good
practice to always use this idiom for on-the-fly code loading and in HTML script
blocks. If at some point you change loaders and where the code is loaded from,
it will all still work.

&lt;/p>
&lt;p>More on how dojo.require
&lt;code>dojo.require(&amp;quot;A.B&amp;quot;)&lt;/code> first checks to see if symbol A.B is
defined. If it is, it is simply returned (nothing to do).

&lt;/p>
&lt;p>If it is not defined, it will look for &lt;code>A/B.js&lt;/code> in the script root
directory.

&lt;/p>
&lt;p>&lt;code>dojo.require&lt;/code> throws an exception if it cannot find a file
to load, or if the symbol &lt;code>A.B&lt;/code> is not defined after loading.

&lt;/p>
&lt;p>It returns the object &lt;code>A.B&lt;/code>, but note the caveats above about on-the-fly loading and
HTML script blocks when the xdomain loader is loading a module.

&lt;/p>
&lt;p>&lt;code>dojo.require()&lt;/code> does nothing about importing symbols into
the current namespace.  It is presumed that the caller will
take care of that.
&lt;/p>
</description><examples><example>&lt;p>To use dojo.require in conjunction with dojo.ready:

&lt;/p>
&lt;pre>&lt;code>  dojo.require(&amp;quot;foo&amp;quot;);
  dojo.require(&amp;quot;bar&amp;quot;);
  dojo.addOnLoad(function(){
    //you can now safely do something with foo and bar
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>For example, to import all symbols into a local block, you might write:

&lt;/p>
&lt;pre>&lt;code>  with (dojo.require(&amp;quot;A.B&amp;quot;)) {
    ...
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>And to import just the leaf symbol to a local variable:

&lt;/p>
&lt;pre>&lt;code>  var B = dojo.require(&amp;quot;A.B&amp;quot;);
  ...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="loadInit" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerModulePath" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="prefix" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Maps a module name to a path&lt;/p>
</summary><description>&lt;p>An unregistered module is given the default path of ../[module],
relative to Dojo root. For example, module acme is mapped to
../acme.  If you want to use a different module name, use
dojo.registerModulePath.&lt;/p>
</description><examples><example>&lt;p>If your dojo.js is located at this location in the web root:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/dojo/dojo/dojo.js&lt;/code>&lt;/pre>
&lt;p>and your modules are located at:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/foo/bar.js
  /myapp/js/foo/baz.js
  /myapp/js/foo/thud/xyzzy.js&lt;/code>&lt;/pre>
&lt;p>Your application can tell Dojo to locate the &amp;quot;foo&amp;quot; namespace by calling:&lt;/p>
&lt;pre>&lt;code>  dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>At which point you can then use dojo.require() to load the
modules (assuming they provide() the same things which are
required). The full code might be:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;
    src=&amp;quot;/myapp/js/dojo/dojo/dojo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);
    dojo.require(&amp;quot;foo.bar&amp;quot;);
    dojo.require(&amp;quot;foo.baz&amp;quot;);
    dojo.require(&amp;quot;foo.thud.xyzzy&amp;quot;);
  &amp;lt;/script&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="platformRequire" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="modMap" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>require one or more modules based on which host environment
Dojo is currently operating in&lt;/p>
</summary><description>&lt;p>This method takes a &amp;quot;map&amp;quot; of arrays which one can use to
optionally load dojo modules. The map is indexed by the
possible dojo.name&lt;em> values, with two additional values:
&amp;quot;default&amp;quot; and &amp;quot;common&amp;quot;. The items in the &amp;quot;default&amp;quot; array will
be loaded if none of the other items have been choosen based on
dojo.name&lt;/em>, set by your host environment. The items in the
&amp;quot;common&amp;quot; array will &lt;em>always&lt;/em> be loaded, regardless of which
list is chosen.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.platformRequire({
    browser: [
      &amp;quot;foo.sample&amp;quot;, // simple module
      &amp;quot;foo.test&amp;quot;,
      [&amp;quot;foo.bar.baz&amp;quot;, true] // skip object check in _loadModule (dojo.require)
    ],
    default: [ &amp;quot;foo.sample._base&amp;quot; ],
    common: [ &amp;quot;important.module.common&amp;quot; ]
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="requireAfterIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireLocalization" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="bundleName" type="String" usage="required"/><parameter name="locale" type="String" usage="optional"/></parameters><return-types/></method><method name="cache" scope="normal" type="function" from="dojo/text"><parameters><parameter name="module" type="String||Object" usage="required"><summary>&lt;p>dojo/cldr/supplemental&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="required"><summary>&lt;p>The rest of the path to append to the path derived from the module argument. If
module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.&lt;/p>
</summary></parameter><parameter name="value" type="String||Object" usage="optional"><summary>&lt;p>If a String, the value to use in the cache for the module/url combination.
If an Object, it can have two properties: value and sanitize. The value property
should be the value to use in the cache, and sanitize can be set to true or false,
to indicate if XML declarations should be removed from the value and if the HTML
inside a body tag in the value should be extracted as the real value. The value argument
or the value property on the value argument are usually only used by the build system
as it inlines cache content.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A getter and setter for storing the string content associated with the
module and url arguments.&lt;/p>
</summary><description>&lt;p>If module is a string that contains slashes, then it is interpretted as a fully
resolved path (typically a result returned by require.toUrl), and url should not be
provided. This is the preferred signature. If module is a string that does not
contain slashes, then url must also be provided and module and url are used to
call &lt;code>dojo.moduleUrl()&lt;/code> to generate a module URL. This signature is deprecated.
If value is specified, the cache value for the moduleUrl will be set to
that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
in its internal cache and return that cached value for the URL. To clear
a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
the URL contents, only modules on the same domain of the page can use this capability.
The build system can inline the cache values though, to allow for xdomain hosting.&lt;/p>
</description><examples><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&amp;quot;cache&amp;quot;] style
of call is used to avoid an issue with the build system erroneously trying to intern
this example. To get the build system to intern your dojo.cache calls, use the
&amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot; that will be
 //the value for the text variable.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
(the dojo[&amp;quot;cache&amp;quot;] style of call is used to avoid an issue with the build system
erroneously trying to intern this example. To get the build system to intern your
dojo.cache calls, use the &amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;, {sanitize: true});&lt;/code>&lt;/pre>
</example><example>&lt;p>Same example as previous, but demonstrates how an object can be passed in as
the first argument, then the value argument can then be the second argument.&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](new dojo._Url(&amp;quot;my/module/template.html&amp;quot;), {sanitize: true});&lt;/code>&lt;/pre>
</example></examples></method><method name="getL10nName" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="moduleName" type="undefined" usage="required"/><parameter name="bundleName" type="undefined" usage="required"/><parameter name="locale" type="undefined" usage="required"/></parameters><return-types><return-type type="string"/></return-types></method><method name="cookie" scope="normal" type="function" from="dojo/cookie"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of the cookie&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>Value for the cookie&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="optional"><summary>&lt;p>Properties for the cookie&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>expires (Date|String|Number, optional): &lt;p>If a number, the number of days from today at which the cookie
will expire. If a date, the date past which the cookie will expire.
If expires is in the past, the cookie will be deleted.
If expires is omitted or is 0, the cookie will expire when the browser closes.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>path (String, optional): &lt;p>The path to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>domain (String, optional): &lt;p>The domain to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>secure (Boolean, optional): &lt;p>Whether to only send the cookie on secure connections&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Get or set a cookie.&lt;/p>
</summary><description>&lt;p>If one argument is passed, returns the value of the cookie
For two or more arguments, acts as a setter.&lt;/p>
</description><examples><example>&lt;p>set a cookie with the JSON-serialized contents of an object which
will expire 5 days from now:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    cookie(&amp;quot;configObj&amp;quot;, json.stringify(config, {expires: 5 }));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>de-serialize a cookie back into a JavaScript object:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    config = json.parse(cookie(&amp;quot;configObj&amp;quot;));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>delete a cookie:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;], function(cookie){
    cookie(&amp;quot;configObj&amp;quot;, null, {expires: -1});
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="hash" scope="normal" type="function" from="dojo/hash"><parameters><parameter name="hash" type="String" usage="optional"><summary>&lt;p>the hash is set - #string.&lt;/p>
</summary></parameter><parameter name="replace" type="Boolean" usage="optional"><summary>&lt;p>If true, updates the hash value in the current history
state instead of creating a new history state.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>when used as a getter, returns the current hash string.
when used as a setter, returns the new hash string.</return-description><summary>&lt;p>Gets or sets the hash string in the browser URL.&lt;/p>
</summary><description>&lt;p>Handles getting and setting of location.hash.

&lt;/p>
&lt;ul>
&lt;li>If no arguments are passed, acts as a getter.&lt;/li>
&lt;li>If a string is passed, acts as a setter.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  topic.subscribe(&amp;quot;/dojo/hashchange&amp;quot;, context, callback);

  function callback (hashValue){
    // do something based on the hash value.
  }&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module is the foundational module of the dojo boot sequence; it defines the dojo object.&lt;/p>
</summary></object><object location="dojo/has" type="function"><properties><property name="cache" scope="normal" type="string" from="dojo/has"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/has"><parameters><parameter name="name" type="String|Integer" usage="required"><summary>&lt;p>The name (if a string) or identifier (if an integer) of the feature to test.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Return the current value of the named feature.
&lt;/p>
</summary><description>&lt;p>Returns the value of the feature named by name. The feature must have been
previously added to the cache by has.add.&lt;/p>
</description></method><method name="add" scope="normal" type="function" from="dojo/has"><parameters><parameter name="name" type="String|Integer" usage="required"><summary>&lt;p>The name (if a string) or identifier (if an integer) of the feature to test.&lt;/p>
</summary></parameter><parameter name="test" type="Function" usage="required"><summary>&lt;p>A test function to register. If a function, queued for testing until actually
needed. The test function should return a boolean indicating
the presence of a feature or bug.&lt;/p>
</summary></parameter><parameter name="now" type="Boolean" usage="optional"><summary>&lt;p>Optional. Omit if &lt;code>test&lt;/code> is not a function. Provides a way to immediately
run the test and cache the result.&lt;/p>
</summary></parameter><parameter name="force" type="Boolean" usage="optional"><summary>&lt;p>Optional. If the test already exists and force is truthy, then the existing
test will be replaced; otherwise, add does not replace an existing test (that
is, by default, the first test advice wins).&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Register a new feature test for some named feature.&lt;/p>
</summary><examples><example>&lt;p>A redundant test, testFn with immediate execution:&lt;/p>
&lt;pre>&lt;code>  has.add(&amp;quot;javascript&amp;quot;, function(){ return true; }, true);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again with the redundantness. You can do this in your tests, but we should
not be doing this in any internal has.js tests&lt;/p>
&lt;pre>&lt;code>  has.add(&amp;quot;javascript&amp;quot;, true);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Three things are passed to the testFunction. &lt;code>global&lt;/code>, &lt;code>document&lt;/code>, and a generic element
from which to work your test should the need arise.&lt;/p>
&lt;pre>&lt;code>  has.add(&amp;quot;bug-byid&amp;quot;, function(g, d, el){
    // g  == global, typically window, yadda yadda
    // d  == document object
    // el == the generic element. a `has` element.
    return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="clearElement" scope="normal" type="function" from="dojo/has"><parameters><parameter name="element" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deletes the contents of the element passed to test functions.&lt;/p>
</summary></method><method name="normalize" scope="normal" type="function" from="dojo/has"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="toAbsMid" type="Function" usage="required"><summary>&lt;p>Resolves a relative module id into an absolute module id&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
&lt;/p>
</summary></method><method name="load" scope="normal" type="function" from="dojo/has"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>Gives the resolved module id to load.&lt;/p>
</summary></parameter><parameter name="parentRequire" type="Function" usage="required"><summary>&lt;p>The loader require function with respect to the module that contained the plugin resource in it&amp;#39;s
dependency list.&lt;/p>
</summary></parameter><parameter name="loaded" type="Function" usage="required"><summary>&lt;p>Callback to loader that consumes result of plugin demand.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Conditional loading of AMD modules based on a has feature test value.&lt;/p>
</summary></method></methods><parameters><parameter name="name" type="String|Integer" usage="required"><summary>&lt;p>The name (if a string) or identifier (if an integer) of the feature to test.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Return the current value of the named feature.
&lt;/p>
</summary><description>&lt;p>Returns the value of the feature named by name. The feature must have been
previously added to the cache by has.add.&lt;/p>
</description></object><object location="dojo/_base/config" type="object"><properties><property name="isDebug" scope="normal" type="Boolean" from="dojo/_base/config"><summary>&lt;p>Defaults to &lt;code>false&lt;/code>. If set to &lt;code>true&lt;/code>, ensures that Dojo provides
extended debugging feedback via Firebug. If Firebug is not available
on your platform, setting &lt;code>isDebug&lt;/code> to &lt;code>true&lt;/code> will force Dojo to
pull in (and display) the version of Firebug Lite which is
integrated into the Dojo distribution, thereby always providing a
debugging/logging console when &lt;code>isDebug&lt;/code> is enabled. Note that
Firebug&amp;#39;s &lt;code>console.*&lt;/code> methods are ALWAYS defined by Dojo. If
&lt;code>isDebug&lt;/code> is false and you are on a platform without Firebug, these
methods will be defined as no-ops.&lt;/p>
</summary></property><property name="locale" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="extraLocale" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="baseUrl" scope="normal" type="undefined" from="dojo/_base/kernel"/><property name="modulePaths" scope="normal" type="Object" from="dojo/_base/config"><summary>&lt;p>A map of module names to paths relative to &lt;code>dojo.baseUrl&lt;/code>. The
key/value pairs correspond directly to the arguments which
&lt;code>dojo.registerModulePath&lt;/code> accepts. Specifying
&lt;code>djConfig.modulePaths = { &amp;quot;foo&amp;quot;: &amp;quot;../../bar&amp;quot; }&lt;/code> is the equivalent
of calling &lt;code>dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../bar&amp;quot;);&lt;/code>. Multiple
modules may be configured via &lt;code>djConfig.modulePaths&lt;/code>.&lt;/p>
</summary></property><property name="addOnLoad" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Adds a callback via dojo/ready. Useful when Dojo is added after
the page loads and djConfig.afterOnLoad is true. Supports the same
arguments as dojo/ready. When using a function reference, use
&lt;code>djConfig.addOnLoad = function(){};&lt;/code>. For object with function name use
&lt;code>djConfig.addOnLoad = [myObject, &amp;quot;functionName&amp;quot;];&lt;/code> and for object with
function reference use
&lt;code>djConfig.addOnLoad = [myObject, function(){}];&lt;/code>&lt;/p>
</summary></property><property name="parseOnLoad" scope="normal" type="Boolean" from="dojo/_base/config"><summary>&lt;p>Run the parser after the page is loaded&lt;/p>
</summary></property><property name="require" scope="normal" type="String[]" from="dojo/_base/config"><summary>&lt;p>An array of module names to be loaded immediately after dojo.js has been included
in a page.&lt;/p>
</summary></property><property name="defaultDuration" scope="normal" type="Number" from="dojo/_base/config"><summary>&lt;p>Default duration, in milliseconds, for wipe and fade animations within dijits.
Assigned to dijit.defaultDuration.&lt;/p>
</summary></property><property name="dojoBlankHtmlUrl" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="ioPublish" scope="normal" type="Boolean" from="dojo/_base/config"><summary>&lt;p>Set this to true to enable publishing of topics for the different phases of
IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
of topics that are published.&lt;/p>
</summary></property><property name="useCustomLogger" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="transparentColor" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="deps" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="callback" scope="normal" type="Function|Array" from="dojo/_base/config"><summary>&lt;p>Defines a callback to be used when dependencies are defined before 
the loader has been loaded. When provided, they cause the loader to 
execute require(deps, callback) once it has finished loading. 
Should be used with deps.&lt;/p>
</summary></property><property name="deferredInstrumentation" scope="normal" type="Boolean" from="dojo/_base/config"><summary>&lt;p>Whether deferred instrumentation should be loaded or included
in builds.&lt;/p>
</summary></property><property name="useDeferredInstrumentation" scope="normal" type="Boolean|String" from="dojo/_base/config"><summary>&lt;p>Whether the deferred instrumentation should be used.

&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;quot;report-rejections&amp;quot;&lt;/code>: report each rejection as it occurs.&lt;/li>
&lt;li>&lt;code>true&lt;/code> or &lt;code>1&lt;/code> or &lt;code>&amp;quot;report-unhandled-rejections&amp;quot;&lt;/code>: wait 1 second
in an attempt to detect unhandled rejections.&lt;/li>
&lt;/ul>
</summary></property><property name="afterOnLoad" scope="normal" type="boolean" from="dojo/ready"/><property name="debugContainerId" scope="normal" type="string" from="dojo/_firebug/firebug"/><property name="debugHeight" scope="normal" type="number" from="dojo/robotx"/></properties><methods/><summary>&lt;p>This module defines the user configuration during bootstrap.&lt;/p>
</summary><description>&lt;p>By defining user configuration as a module value, an entire configuration can be specified in a build,
thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
Also, when multiple instances of dojo exist in a single application, each will necessarily be located
at an unique absolute module identifier as given by the package configuration. Implementing configuration
as a module allows for specifying unique, per-instance configurations.&lt;/p>
</description><examples><example>&lt;p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
dojo.js are already loaded).&lt;/p>
&lt;pre>&lt;code>  // specify a configuration that creates a new instance of dojo at the absolute module identifier &amp;quot;myDojo&amp;quot;
  require({
    packages:[{
      name:&amp;quot;myDojo&amp;quot;,
      location:&amp;quot;.&amp;quot;, //assume baseUrl points to dojo.js
    }]
  });

  // specify a configuration for the myDojo instance
  define(&amp;quot;myDojo/config&amp;quot;, {
    // normal configuration variables go here, e.g.,
    locale:&amp;quot;fr-ca&amp;quot;
  });

  // load and use the new instance of dojo
  require([&amp;quot;myDojo&amp;quot;], function(dojo){
    // dojo is the new instance of dojo
    // use as required
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/_base/lang" type="object"><properties><property name="_extraNames" scope="normal" type="String[]" from="dojo/_base/lang"><summary>&lt;p>Lists property names that must be explicitly processed during for-in iteration
in environments that have has(&amp;quot;bug-for-in-skips-shadowed&amp;quot;) true.&lt;/p>
</summary></property></properties><methods><method name="_mixin" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="dest" type="Object" usage="required"><summary>&lt;p>The object to which to copy/add all properties contained in source.&lt;/p>
</summary></parameter><parameter name="source" type="Object" usage="required"><summary>&lt;p>The object from which to draw all properties to copy into dest.&lt;/p>
</summary></parameter><parameter name="copyFunc" type="Function" usage="optional"><summary>&lt;p>The process used to copy/add a property in source; defaults to the Javascript assignment operator.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Object"/></return-types><return-description>dest, as modified</return-description><summary>&lt;p>Copies/adds all properties of source to dest; returns dest.&lt;/p>
</summary><description>&lt;p>All properties, including functions (sometimes termed &amp;quot;methods&amp;quot;), excluding any non-standard extensions
found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
Notice that by default, _mixin executes a so-called &amp;quot;shallow copy&amp;quot; and aggregate types are copied/added by reference.&lt;/p>
</description></method><method name="mixin" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="dest" type="Object" usage="required"><summary>&lt;p>The object to which to copy/add all properties contained in source. If dest is falsy, then
a new object is manufactured before copying/adding properties begins.&lt;/p>
</summary></parameter><parameter name="sources" type="Object..." usage="required"><summary>&lt;p>One of more objects from which to draw all properties to copy into dest. sources are processed
left-to-right and if more than one of these objects contain the same property name, the right-most
value &amp;quot;wins&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="object"/></return-types><return-description>dest, as modified</return-description><summary>&lt;p>Copies/adds all properties of one or more sources to dest; returns dest.&lt;/p>
</summary><description>&lt;p>All properties, including functions (sometimes termed &amp;quot;methods&amp;quot;), excluding any non-standard extensions
found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
executes a so-called &amp;quot;shallow copy&amp;quot; and aggregate types are copied/added by reference.&lt;/p>
</description><examples><example>&lt;p>make a shallow copy of an object&lt;/p>
&lt;pre>&lt;code>  var copy = lang.mixin({}, source);&lt;/code>&lt;/pre>
</example><example>&lt;p>many class constructors often take an object which specifies
values to be configured on the object. In this case, it is
often simplest to call &lt;code>lang.mixin&lt;/code> on the &lt;code>this&lt;/code> object:&lt;/p>
&lt;pre>&lt;code>  declare(&amp;quot;acme.Base&amp;quot;, null, {
    constructor: function(properties){
      // property configuration:
      lang.mixin(this, properties);

      console.log(this.quip);
      //  ...
    },
    quip: &amp;quot;I wasn&amp;#39;t born yesterday, you know - I&amp;#39;ve seen movies.&amp;quot;,
    // ...
  });

  // create an instance of the class and configure it
  var b = new acme.Base({quip: &amp;quot;That&amp;#39;s what it does!&amp;quot; });&lt;/code>&lt;/pre>
</example><example>&lt;p>copy in properties from multiple objects&lt;/p>
&lt;pre>&lt;code>  var flattened = lang.mixin(
    {
      name: &amp;quot;Frylock&amp;quot;,
      braces: true
    },
    {
      name: &amp;quot;Carl Brutanananadilewski&amp;quot;
    }
  );

  // will print &amp;quot;Carl Brutanananadilewski&amp;quot;
  console.log(flattened.name);
  // will print &amp;quot;true&amp;quot;
  console.log(flattened.braces);&lt;/code>&lt;/pre>
</example></examples></method><method name="setObject" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Path to a property, in the form &amp;quot;A.B.C&amp;quot;.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>value or object to place at location given by name&lt;/p>
</summary></parameter><parameter name="context" type="Object" usage="optional"><summary>&lt;p>Optional. Object to use as root of path. Defaults to
&lt;code>dojo.global&lt;/code>.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Set a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;&lt;/p>
</summary><description>&lt;p>Useful for longer api chains where you have to test each object in
the chain, or when you have an object reference in string format.
Objects are created as needed along &lt;code>path&lt;/code>. Returns the passed
value if setting is successful or &lt;code>undefined&lt;/code> if not.&lt;/p>
</description><examples><example>&lt;p>set the value of &lt;code>foo.bar.baz&lt;/code>, regardless of whether
intermediate objects already exist:&lt;/p>
&lt;pre>&lt;code> lang.setObject(&amp;quot;foo.bar.baz&amp;quot;, value);&lt;/code>&lt;/pre>
</example><example>&lt;p>without &lt;code>lang.setObject&lt;/code>, we often see code like this:&lt;/p>
&lt;pre>&lt;code> // ensure that intermediate objects are available
 if(!obj[&amp;quot;parent&amp;quot;]){ obj.parent = {}; }
 if(!obj.parent[&amp;quot;child&amp;quot;]){ obj.parent.child = {}; }
 // now we can safely set the property
 obj.parent.child.prop = &amp;quot;some value&amp;quot;;&lt;/code>&lt;/pre>
&lt;p>whereas with &lt;code>lang.setObject&lt;/code>, we can shorten that to:&lt;/p>
&lt;pre>&lt;code> lang.setObject(&amp;quot;parent.child.prop&amp;quot;, &amp;quot;some value&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="getObject" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Path to an property, in the form &amp;quot;A.B.C&amp;quot;.&lt;/p>
</summary></parameter><parameter name="create" type="Boolean" usage="optional"><summary>&lt;p>Optional. Defaults to &lt;code>false&lt;/code>. If &lt;code>true&lt;/code>, Objects will be
created at any point along the &amp;#39;path&amp;#39; that is undefined.&lt;/p>
</summary></parameter><parameter name="context" type="Object" usage="optional"><summary>&lt;p>Optional. Object to use as root of path. Defaults to
&amp;#39;dojo.global&amp;#39;. Null may be passed.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Get a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;&lt;/p>
</summary><description>&lt;p>Useful for longer api chains where you have to test each object in
the chain, or when you have an object reference in string format.&lt;/p>
</description></method><method name="exists" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Path to an object, in the form &amp;quot;A.B.C&amp;quot;.&lt;/p>
</summary></parameter><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>Object to use as root of path. Defaults to
&amp;#39;dojo.global&amp;#39;. Null may be passed.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>determine if an object supports a given method&lt;/p>
</summary><description>&lt;p>useful for longer api chains where you have to test each object in
the chain. Useful for object and method detection.&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // define an object
 var foo = {
    bar: { }
 };

 // search the global scope
 lang.exists(&amp;quot;foo.bar&amp;quot;); // true
 lang.exists(&amp;quot;foo.bar.baz&amp;quot;); // false

 // search from a particular scope
 lang.exists(&amp;quot;bar&amp;quot;, foo); // true
 lang.exists(&amp;quot;bar.baz&amp;quot;, foo); // false&lt;/code>&lt;/pre>
</example></examples></method><method name="isString" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="anything" usage="required"><summary>&lt;p>Item to test.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Return true if it is a String&lt;/p>
</summary></method><method name="isArray" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="anything" usage="required"><summary>&lt;p>Item to test.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return true if it is an Array.
Does not work on Arrays created in other windows.&lt;/p>
</summary></method><method name="isFunction" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="anything" usage="required"><summary>&lt;p>Item to test.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Return true if it is a Function&lt;/p>
</summary></method><method name="isObject" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="anything" usage="required"><summary>&lt;p>Item to test.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if it is a JavaScript object (or an Array, a Function
or null)&lt;/p>
</summary></method><method name="isArrayLike" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="anything" usage="required"><summary>&lt;p>Item to test.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Boolean"/></return-types><return-description>If it walks like a duck and quacks like a duck, return `true`</return-description><summary>&lt;p>similar to isArray() but more permissive&lt;/p>
</summary><description>&lt;p>Doesn&amp;#39;t strongly test for &amp;quot;arrayness&amp;quot;.  Instead, settles for &amp;quot;isn&amp;#39;t
a string or number and has a length property&amp;quot;. Arguments objects
and DOM collections will return true when passed to
isArrayLike(), but will return false when passed to
isArray().&lt;/p>
</description></method><method name="isAlien" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="it" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns true if it is a built-in function or some other kind of
oddball that &lt;em>should&lt;/em> report as a function but doesn&amp;#39;t&lt;/p>
</summary></method><method name="extend" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="ctor" type="Object" usage="required"><summary>&lt;p>Target constructor to extend.&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>One or more objects to mix into ctor.prototype&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Target constructor to extend.&lt;/p>
</return-description><summary>&lt;p>Adds all properties and methods of props to constructor&amp;#39;s
prototype, making them available to all instances created with
constructor.&lt;/p>
</summary></method><method name="_hitchArgs" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="scope" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types></method><method name="hitch" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="scope" type="Object" usage="required"><summary>&lt;p>The scope to use when method executes. If method is a string,
scope is also the object containing method.&lt;/p>
</summary></parameter><parameter name="method" type="Function|String..." usage="required"><summary>&lt;p>A function to be hitched to scope, or the name of the method in
scope to be hitched.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="function"/></return-types><summary>&lt;p>Returns a function that will only ever execute in the a given scope.
This allows for easy use of object member functions
in callbacks and other places in which the &amp;quot;this&amp;quot; keyword may
otherwise not reference the expected scope.
Any number of default positional arguments may be passed as parameters
beyond &amp;quot;method&amp;quot;.
Each of these values will be used to &amp;quot;placehold&amp;quot; (similar to curry)
for the hitched function.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  lang.hitch(foo, &amp;quot;bar&amp;quot;)();&lt;/code>&lt;/pre>
&lt;p>runs foo.bar() in the scope of foo&lt;/p>
</example><example>&lt;pre>&lt;code>  lang.hitch(foo, myFunction);&lt;/code>&lt;/pre>
&lt;p>returns a function that runs myFunction in the scope of foo&lt;/p>
</example><example>&lt;p>Expansion on the default positional arguments passed along from
hitch. Passed args are mixed first, additional args after.&lt;/p>
&lt;pre>&lt;code>  var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
  var fn = lang.hitch(foo, &amp;quot;bar&amp;quot;, 1, 2);
  fn(3); // logs &amp;quot;1, 2, 3&amp;quot;&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  var foo = { bar: 2 };
  lang.hitch(foo, function(){ this.bar = 10; })();&lt;/code>&lt;/pre>
&lt;p>execute an anonymous function in scope of foo&lt;/p>
</example></examples></method><method name="delegate" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="obj" type="Object" usage="required"><summary>&lt;p>The object to delegate to for properties not found directly on the
return object or in props.&lt;/p>
</summary></parameter><parameter name="props" type="Object..." usage="required"><summary>&lt;p>an object containing properties to assign to the returned object&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>an Object of anonymous type</return-description><summary>&lt;p>Returns a new object which &amp;quot;looks&amp;quot; to obj for properties which it
does not have a value for. Optionally takes a bag of properties to
seed the returned object with initially.&lt;/p>
</summary><description>&lt;p>This is a small implementation of the Boodman/Crockford delegation
pattern in JavaScript. An intermediate object constructor mediates
the prototype chain for the returned object, using it to delegate
down to obj for property lookup when object-local lookup fails.
This can be thought of similarly to ES4&amp;#39;s &amp;quot;wrap&amp;quot;, save that it does
not act on types but rather on pure objects.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var foo = { bar: &amp;quot;baz&amp;quot; };
  var thinger = lang.delegate(foo, { thud: &amp;quot;xyzzy&amp;quot;});
  thinger.bar == &amp;quot;baz&amp;quot;; // delegated to foo
  foo.thud == undefined; // by definition
  thinger.thud == &amp;quot;xyzzy&amp;quot;; // mixed in from props
  foo.bar = &amp;quot;thonk&amp;quot;;
  thinger.bar == &amp;quot;thonk&amp;quot;; // still delegated to foo&amp;#39;s bar&lt;/code>&lt;/pre>
</example></examples></method><method name="_toArray" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="obj" type="Object" usage="required"><summary>&lt;p>the object to &amp;quot;arrayify&amp;quot;. We expect the object to have, at a
minimum, a length property which corresponds to integer-indexed
properties.&lt;/p>
</summary></parameter><parameter name="offset" type="Number" usage="optional"><summary>&lt;p>the location in obj to start iterating from. Defaults to 0.
Optional.&lt;/p>
</summary></parameter><parameter name="startWith" type="Array" usage="optional"><summary>&lt;p>An array to pack with the properties of obj. If provided,
properties in obj are appended at the end of startWith and
startWith is the returned array.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Converts an array-like object (i.e. arguments, DOMCollection) to an
array. Returns a new Array with the elements of obj.&lt;/p>
</summary></method><method name="partial" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="method" type="Function|String" usage="required"><summary>&lt;p>The function to &amp;quot;wrap&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>similar to hitch() except that the scope object is left to be
whatever the execution context eventually becomes.&lt;/p>
</summary><description>&lt;p>Calling lang.partial is the functional equivalent of calling:&lt;/p>
&lt;pre>&lt;code>  lang.hitch(null, funcName, ...);&lt;/code>&lt;/pre>
</description></method><method name="clone" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="src" type="anything" usage="required"><summary>&lt;p>The object to clone&lt;/p>
</summary></parameter></parameters><return-types><return-type type="anything"/><return-type type="undefined"/><return-type type="instance"/></return-types><return-description>&lt;p>The object to clone&lt;/p>
</return-description><summary>&lt;p>Clones objects (including DOM nodes) and all children.
Warning: do not clone cyclic structures.&lt;/p>
</summary></method><method name="trim" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="str" type="String" usage="required"><summary>&lt;p>String to be trimmed&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/></return-types><return-description>Returns the trimmed string</return-description><summary>&lt;p>Trims whitespace from both sides of the string&lt;/p>
</summary><description>&lt;p>This version of trim() was selected for inclusion into the base due
to its compact size and relatively good performance
(see &lt;a href=&quot;http://blog.stevenlevithan.com/archives/faster-trim-javascript&quot;>Steven Levithan&amp;#39;s blog&lt;/a>
Uses String.prototype.trim instead, if available.
The fastest but longest version of this function is located at
lang.string.trim()&lt;/p>
</description></method><method name="replace" scope="normal" type="function" from="dojo/_base/lang"><parameters><parameter name="tmpl" type="String" usage="required"><summary>&lt;p>String to be used as a template.&lt;/p>
</summary></parameter><parameter name="map" type="Object|Function" usage="required"><summary>&lt;p>If an object, it is used as a dictionary to look up substitutions.
If a function, it is called for every substitution with following parameters:
a whole match, a name, an offset, and the whole template
string (see &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace&lt;/a>
for more details).&lt;/p>
</summary></parameter><parameter name="pattern" type="RegEx" usage="optional"><summary>&lt;p>Optional regular expression objects that overrides the default pattern.
Must be global and match one item. The default is: /{([^}]+)}/g,
which matches patterns like that: &amp;quot;{xxx}&amp;quot;, where &amp;quot;xxx&amp;quot; is any sequence
of characters, which doesn&amp;#39;t include &amp;quot;}&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><return-description>Returns the substituted string.</return-description><summary>&lt;p>Performs parameterized substitutions on a string. Throws an
exception if any parameter is unmatched.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  // uses a dictionary for substitutions:
  lang.replace(&amp;quot;Hello, {name.first} {name.last} AKA {nick}!&amp;quot;,
    {
      nick: &amp;quot;Bob&amp;quot;,
      name: {
        first:  &amp;quot;Robert&amp;quot;,
        middle: &amp;quot;X&amp;quot;,
        last:    &amp;quot;Cringely&amp;quot;
      }
    });
  // returns: Hello, Robert Cringely AKA Bob!&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // uses an array for substitutions:
  lang.replace(&amp;quot;Hello, {0} {2}!&amp;quot;,
    [&amp;quot;Robert&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;Cringely&amp;quot;]);
  // returns: Hello, Robert Cringely!&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // uses a function for substitutions:
  function sum(a){
    var t = 0;
    arrayforEach(a, function(x){ t += x; });
    return t;
  }
  lang.replace(
    &amp;quot;{count} payments averaging {avg} USD per payment.&amp;quot;,
    lang.hitch(
      { payments: [11, 16, 12] },
      function(_, key){
        switch(key){
          case &amp;quot;count&amp;quot;: return this.payments.length;
          case &amp;quot;min&amp;quot;:    return Math.min.apply(Math, this.payments);
          case &amp;quot;max&amp;quot;:    return Math.max.apply(Math, this.payments);
          case &amp;quot;sum&amp;quot;:    return sum(this.payments);
          case &amp;quot;avg&amp;quot;:    return sum(this.payments) / this.payments.length;
        }
      }
    )
  );
  // prints: 3 payments averaging 13 USD per payment.&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // uses an alternative PHP-like pattern for substitutions:
  lang.replace(&amp;quot;Hello, ${0} ${2}!&amp;quot;,
    [&amp;quot;Robert&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;Cringely&amp;quot;], /\$\{([^\}]+)\}/g);
  // returns: Hello, Robert Cringely!&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module defines Javascript language extensions.&lt;/p>
</summary></object><object location="dojo/sniff" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/sniff"><parameters/><return-types/><summary>&lt;p>This module sets has() flags based on the current browser.
It returns the has() function.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>This module sets has() flags based on the current browser.
It returns the has() function.&lt;/p>
</summary></object><object location="dojo/Deferred" type="function"><properties><property name="promise" scope="normal" type="instance" from="dojo/Deferred"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/Deferred"><parameters><parameter name="canceler" type="Function" usage="optional"><summary>&lt;p>Will be invoked if the deferred is canceled. The canceler
receives the reason the deferred was canceled as its argument.
The deferred is rejected with its return value, or a new
&lt;code>dojo/errors/CancelError&lt;/code> instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Creates a new deferred. This API is preferred over
&lt;code>dojo/_base/Deferred&lt;/code>.&lt;/p>
</summary><description>&lt;p>Creates a new deferred, as an abstraction over (primarily)
asynchronous operations. The deferred is the private interface
that should not be returned to calling code. That&amp;#39;s what the
&lt;code>promise&lt;/code> is for. See &lt;code>dojo/promise/Promise&lt;/code>.&lt;/p>
</description></method><method name="toString" scope="prototype" type="function" from="dojo/Deferred"><parameters/><return-types><return-type type="String"/></return-types><return-description>Returns `[object Deferred]`.</return-description></method><method name="isResolved" scope="normal" type="function" from="dojo/Deferred"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the deferred has been resolved.&lt;/p>
</summary></method><method name="isRejected" scope="normal" type="function" from="dojo/Deferred"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the deferred has been rejected.&lt;/p>
</summary></method><method name="isFulfilled" scope="normal" type="function" from="dojo/Deferred"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the deferred has been resolved or rejected.&lt;/p>
</summary></method><method name="isCanceled" scope="normal" type="function" from="dojo/Deferred"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the deferred has been canceled.&lt;/p>
</summary></method><method name="progress" scope="normal" type="function" from="dojo/Deferred"><parameters><parameter name="update" type="any" usage="required"><summary>&lt;p>The progress update. Passed to progbacks.&lt;/p>
</summary></parameter><parameter name="strict" type="Boolean" usage="optional"><summary>&lt;p>If strict, will throw an error if the deferred has already
been fulfilled and consequently no progress can be emitted.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>Returns the original promise for the deferred.</return-description><summary>&lt;p>Emit a progress update on the deferred.&lt;/p>
</summary><description>&lt;p>Emit a progress update on the deferred. Progress updates
can be used to communicate updates about the asynchronous
operation before it has finished.&lt;/p>
</description></method><method name="resolve" scope="normal" type="function" from="dojo/Deferred"><parameters><parameter name="value" type="any" usage="required"><summary>&lt;p>The result of the deferred. Passed to callbacks.&lt;/p>
</summary></parameter><parameter name="strict" type="Boolean" usage="optional"><summary>&lt;p>If strict, will throw an error if the deferred has already
been fulfilled and consequently cannot be resolved.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>Returns the original promise for the deferred.</return-description><summary>&lt;p>Resolve the deferred.&lt;/p>
</summary><description>&lt;p>Resolve the deferred, putting it in a success state.&lt;/p>
</description></method><method name="reject" scope="normal" type="function" from="dojo/Deferred"><parameters><parameter name="error" type="any" usage="required"><summary>&lt;p>The error result of the deferred. Passed to errbacks.&lt;/p>
</summary></parameter><parameter name="strict" type="Boolean" usage="optional"><summary>&lt;p>If strict, will throw an error if the deferred has already
been fulfilled and consequently cannot be rejected.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="instance"/></return-types><return-description>Returns the original promise for the deferred.</return-description><summary>&lt;p>Reject the deferred.&lt;/p>
</summary><description>&lt;p>Reject the deferred, putting it in an error state.&lt;/p>
</description></method><method name="then" scope="normal" type="function" from="dojo/Deferred"><parameters><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved.
Receives the resolution value.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.
Receives the rejection error.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress
update. Receives the progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>Returns a new promise for the result of the callback(s).
This can be used for chaining many asynchronous operations.</return-description><summary>&lt;p>Add new callbacks to the deferred.&lt;/p>
</summary><description>&lt;p>Add new callbacks to the deferred. Callbacks can be added
before or after the deferred is fulfilled.&lt;/p>
</description></method><method name="cancel" scope="normal" type="function" from="dojo/Deferred"><parameters><parameter name="reason" type="any" usage="required"><summary>&lt;p>A message that may be sent to the deferred&amp;#39;s canceler,
explaining why it&amp;#39;s being canceled.&lt;/p>
</summary></parameter><parameter name="strict" type="Boolean" usage="optional"><summary>&lt;p>If strict, will throw an error if the deferred has already
been fulfilled and consequently cannot be canceled.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Returns the rejection reason if the deferred was canceled
normally.</return-description><summary>&lt;p>Inform the deferred it may cancel its asynchronous operation.&lt;/p>
</summary><description>&lt;p>Inform the deferred it may cancel its asynchronous operation.
The deferred&amp;#39;s (optional) canceler is invoked and the
deferred will be left in a rejected state. Can affect other
promises that originate with the same deferred.&lt;/p>
</description></method></methods><parameters><parameter name="canceler" type="Function" usage="optional"><summary>&lt;p>Will be invoked if the deferred is canceled. The canceler
receives the reason the deferred was canceled as its argument.
The deferred is rejected with its return value, or a new
&lt;code>dojo/errors/CancelError&lt;/code> instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Creates a new deferred. This API is preferred over
&lt;code>dojo/_base/Deferred&lt;/code>.&lt;/p>
</summary><description>&lt;p>Creates a new deferred, as an abstraction over (primarily)
asynchronous operations. The deferred is the private interface
that should not be returned to calling code. That&amp;#39;s what the
&lt;code>promise&lt;/code> is for. See &lt;code>dojo/promise/Promise&lt;/code>.&lt;/p>
</description></object><object location="dojo/errors/CancelError" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/errors/CancelError"><parameters/><return-types/><summary>&lt;p>Default error if a promise is canceled without a reason.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Default error if a promise is canceled without a reason.&lt;/p>
</summary></object><object location="dojo/errors/create" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/errors/create"><parameters><parameter name="name" type="undefined" usage="required"/><parameter name="ctor" type="undefined" usage="required"/><parameter name="base" type="undefined" usage="required"/><parameter name="props" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types></method></methods><parameters><parameter name="name" type="undefined" usage="required"/><parameter name="ctor" type="undefined" usage="required"/><parameter name="base" type="undefined" usage="required"/><parameter name="props" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types></object><object location="dojo/promise/Promise" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types/><summary>&lt;p>The public interface to a deferred.&lt;/p>
</summary><description>&lt;p>The public interface to a deferred. All promises in Dojo are
instances of this class.&lt;/p>
</description></method><method name="then" scope="prototype" type="function" from="dojo/promise/Promise"><parameters><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved.
Receives the resolution value.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.
Receives the rejection error.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress
update. Receives the progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>Returns a new promise for the result of the callback(s).
This can be used for chaining many asynchronous operations.</return-description><summary>&lt;p>Add new callbacks to the promise.&lt;/p>
</summary><description>&lt;p>Add new callbacks to the deferred. Callbacks can be added
before or after the deferred is fulfilled.&lt;/p>
</description></method><method name="cancel" scope="prototype" type="function" from="dojo/promise/Promise"><parameters><parameter name="reason" type="any" usage="required"><summary>&lt;p>A message that may be sent to the deferred&amp;#39;s canceler,
explaining why it&amp;#39;s being canceled.&lt;/p>
</summary></parameter><parameter name="strict" type="Boolean" usage="optional"><summary>&lt;p>If strict, will throw an error if the deferred has already
been fulfilled and consequently cannot be canceled.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Returns the rejection reason if the deferred was canceled
normally.</return-description><summary>&lt;p>Inform the deferred it may cancel its asynchronous operation.&lt;/p>
</summary><description>&lt;p>Inform the deferred it may cancel its asynchronous operation.
The deferred&amp;#39;s (optional) canceler is invoked and the
deferred will be left in a rejected state. Can affect other
promises that originate with the same deferred.&lt;/p>
</description></method><method name="isResolved" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the promise has been resolved.&lt;/p>
</summary></method><method name="isRejected" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the promise has been rejected.&lt;/p>
</summary></method><method name="isFulfilled" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the promise has been resolved or rejected.&lt;/p>
</summary></method><method name="isCanceled" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Checks whether the promise has been canceled.&lt;/p>
</summary></method><method name="always" scope="prototype" type="function" from="dojo/promise/Promise"><parameters><parameter name="callbackOrErrback" type="Function" usage="optional"><summary>&lt;p>A function that is used both as a callback and errback.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/></return-types><return-description>Returns a new promise for the result of the callback/errback.</return-description><summary>&lt;p>Add a callback to be invoked when the promise is resolved
or rejected.&lt;/p>
</summary></method><method name="otherwise" scope="prototype" type="function" from="dojo/promise/Promise"><parameters><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/></return-types><return-description>Returns a new promise for the result of the errback.</return-description><summary>&lt;p>Add new errbacks to the promise.&lt;/p>
</summary></method><method name="trace" scope="prototype" type="function" from="dojo/promise/tracer"><parameters/><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>The promise instance `trace()` is called on.</return-description><summary>&lt;p>Trace the promise.&lt;/p>
</summary><description>&lt;p>Tracing allows you to transparently log progress,
resolution and rejection of promises, without affecting the
promise itself. Any arguments passed to &lt;code>trace()&lt;/code> are
emitted in trace events. See &lt;code>dojo/promise/tracer&lt;/code> on how
to handle traces.&lt;/p>
</description></method><method name="traceRejected" scope="prototype" type="function" from="dojo/promise/tracer"><parameters/><return-types><return-type type="dojo/promise/Promise"/></return-types><return-description>The promise instance `traceRejected()` is called on.</return-description><summary>&lt;p>Trace rejection of the promise.&lt;/p>
</summary><description>&lt;p>Tracing allows you to transparently log progress,
resolution and rejection of promises, without affecting the
promise itself. Any arguments passed to &lt;code>trace()&lt;/code> are
emitted in trace events. See &lt;code>dojo/promise/tracer&lt;/code> on how
to handle traces.&lt;/p>
</description></method><method name="toString" scope="prototype" type="function" from="dojo/promise/Promise"><parameters/><return-types><return-type type="string"/></return-types><return-description>Returns `[object Promise]`.</return-description></method></methods><parameters/><return-types/><summary>&lt;p>The public interface to a deferred.&lt;/p>
</summary><description>&lt;p>The public interface to a deferred. All promises in Dojo are
instances of this class.&lt;/p>
</description></object><object location="dojo/DeferredList" type="function"><properties/><methods><method name="gatherResults" scope="prototype" type="function" from="dojo/DeferredList"><parameters><parameter name="deferredList" type="dojo/DeferredList" usage="required"><summary>&lt;p>The deferred list from which this function gathers results.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/DeferredList"/></return-types><return-description>The newly created deferred list which packs results as
parameters to its callback.</return-description><summary>&lt;p>Gathers the results of the deferreds for packaging
as the parameters to the Deferred Lists&amp;#39; callback&lt;/p>
</summary></method></methods><parameters><parameter name="list" type="Array" usage="required"><summary>&lt;p>The list of deferreds to be synchronizied with this DeferredList&lt;/p>
</summary></parameter><parameter name="fireOnOneCallback" type="Boolean" usage="optional"><summary>&lt;p>Will cause the DeferredLists callback to be fired as soon as any
of the deferreds in its list have been fired instead of waiting until
the entire list has finished&lt;/p>
</summary></parameter><parameter name="fireOnOneErrback" type="Boolean" usage="optional"/><parameter name="consumeErrors" type="Boolean" usage="optional"/><parameter name="canceller" type="Function" usage="optional"><summary>&lt;p>A deferred canceller function, see dojo.Deferred&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deprecated, use dojo/promise/all instead.
Provides event handling for a group of Deferred objects.&lt;/p>
</summary><description>&lt;p>DeferredList takes an array of existing deferreds and returns a new deferred of its own
this new deferred will typically have its callback fired when all of the deferreds in
the given list have fired their own deferreds.  The parameters &lt;code>fireOnOneCallback&lt;/code> and
fireOnOneErrback, will fire before all the deferreds as appropriate&lt;/p>
</description></object><object location="dojo/_base/Deferred" type="function"><properties><property name="fired" scope="prototype" type="number" from="dojo/_base/Deferred"/><property name="promise" scope="normal" type="instance" from="dojo/_base/Deferred"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/_base/Deferred"><parameters><parameter name="canceller" type="Function" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.
New code should use dojo/Deferred instead.&lt;/p>
</summary><description>&lt;p>The Deferred API is based on the concept of promises that provide a
generic interface into the eventual completion of an asynchronous action.
The motivation for promises fundamentally is about creating a
separation of concerns that allows one to achieve the same type of
call patterns and logical data flow in asynchronous code as can be
achieved in synchronous code. Promises allows one
to be able to call a function purely with arguments needed for
execution, without conflating the call with concerns of whether it is
sync or async. One shouldn&amp;#39;t need to alter a call&amp;#39;s arguments if the
implementation switches from sync to async (or vice versa). By having
async functions return promises, the concerns of making the call are
separated from the concerns of asynchronous interaction (which are
handled by the promise).

&lt;/p>
&lt;p>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&amp;#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

&lt;/p>
&lt;pre>&lt;code>  var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
  },
  function(error){
    ... handle error ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

&lt;/p>
&lt;p>The Deferred instances also provide the following functions for backwards compatibility:

&lt;/p>
&lt;ul>
&lt;li>addCallback(handler)&lt;/li>
&lt;li>addErrback(handler)&lt;/li>
&lt;li>callback(result)&lt;/li>
&lt;li>errback(result)&lt;/li>
&lt;/ul>
&lt;p>Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

&lt;/p>
&lt;p>The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var deferred = new Deferred();
  setTimeout(function(){ deferred.callback({success: true}); }, 1000);
  return deferred;&lt;/code>&lt;/pre>
</example><example>&lt;p>Deferred objects are often used when making code asynchronous. It
may be easiest to write functions in a synchronous manner and then
split code using a deferred to trigger a response to a long-lived
operation. For example, instead of register a callback function to
denote when a rendering operation completes, the function can
simply return a deferred:

&lt;/p>
&lt;pre>&lt;code>  // callback style:
  function renderLotsOfData(data, callback){
    var success = false
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      success = true;
    }catch(e){ }
    if(callback){
      callback(success);
    }
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using callback style
  renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
      promptUserToRecover();
    }
  });
  // NOTE: no way to add another callback here!!&lt;/code>&lt;/pre>
</example><example>&lt;p>Using a Deferred doesn&amp;#39;t simplify the sending code any, but it
provides a standard interface for callers and senders alike,
providing both with a simple way to service multiple callbacks for
an operation and freeing both sides from worrying about details
such as &amp;quot;did this get called already?&amp;quot;. With Deferreds, new
callbacks can be added at any time.

&lt;/p>
&lt;pre>&lt;code>  // Deferred style:
  function renderLotsOfData(data){
    var d = new Deferred();
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      d.callback(true);
    }catch(e){
      d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
    }
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });
  // NOTE: addErrback and addCallback both return the Deferred
  // again, so we could chain adding callbacks or save the
  // deferred for later should we need to be notified again.&lt;/code>&lt;/pre>
</example><example>&lt;p>In this example, renderLotsOfData is synchronous and so both
versions are pretty artificial. Putting the data display on a
timeout helps show why Deferreds rock:

&lt;/p>
&lt;pre>&lt;code>  // Deferred style and async func
  function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
      try{
        for(var x in data){
          renderDataitem(data[x]);
        }
        d.callback(true);
      }catch(e){
        d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
      }
    }, 100);
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that the caller doesn&amp;#39;t have to change his code at all to
handle the asynchronous case.&lt;/p>
</example></examples></method><method name="addCallback" scope="prototype" type="function" from="dojo/_base/Deferred"><parameters><parameter name="callback" type="Function" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Returns this deferred object.</return-description><summary>&lt;p>Adds successful callback for this deferred instance.&lt;/p>
</summary></method><method name="addErrback" scope="prototype" type="function" from="dojo/_base/Deferred"><parameters><parameter name="errback" type="Function" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Returns this deferred object.</return-description><summary>&lt;p>Adds error callback for this deferred instance.&lt;/p>
</summary></method><method name="addBoth" scope="prototype" type="function" from="dojo/_base/Deferred"><parameters><parameter name="callback" type="Function" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Returns this deferred object.</return-description><summary>&lt;p>Add handler as both successful callback and error callback for this deferred instance.&lt;/p>
</summary></method><method name="callback" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="value" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fulfills the Deferred instance successfully with the provide value&lt;/p>
</summary></method><method name="resolve" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="value" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fulfills the Deferred instance successfully with the provide value&lt;/p>
</summary></method><method name="errback" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="error" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fulfills the Deferred instance as an error with the provided error&lt;/p>
</summary></method><method name="reject" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="error" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fulfills the Deferred instance as an error with the provided error&lt;/p>
</summary></method><method name="progress" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="update" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Send progress events to all listeners&lt;/p>
</summary></method><method name="addCallbacks" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The callback attached to this deferred object.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>The error callback attached to this deferred object.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Returns this deferred object.</return-description><summary>&lt;p>Adds callback and error callback for this deferred instance.&lt;/p>
</summary></method><method name="then" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="resolvedCallback" type="Function" usage="optional"/><parameter name="errorCallback" type="Function" usage="optional"/><parameter name="progressCallback" type="Function" usage="optional"/></parameters><return-types><return-type type="any"/></return-types><return-description>Returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.</return-description><summary>&lt;p>Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
completion of a promise. The fulfilledHandler is called when the promise
is fulfilled. The errorHandler is called when a promise fails. The
progressHandler is called for progress events. All arguments are optional
and non-function values are ignored. The progressHandler is not only an
optional argument, but progress events are purely optional. Promise
providers are not required to ever create progress events.

&lt;/p>
&lt;p>This function will return a new promise that is fulfilled when the given
fulfilledHandler or errorHandler callback is finished. This allows promise
operations to be chained together. The value returned from the callback
handler is the fulfillment value for the returned promise. If the callback
throws an error, the returned promise will be moved to failed state.
&lt;/p>
</summary><examples><example>&lt;p>An example of using a CommonJS compliant promise:&lt;/p>
&lt;pre>&lt;code>  asyncComputeTheAnswerToEverything().
    then(addTwo).
    then(printResult, onError);
  &amp;gt;44&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="cancel" scope="normal" type="function" from="dojo/_base/Deferred"><parameters/><return-types/><summary>&lt;p>Cancels the asynchronous operation&lt;/p>
</summary></method><method name="when" scope="normal" type="function" from="dojo/when"><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></method></methods><parameters><parameter name="canceller" type="Function" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.
New code should use dojo/Deferred instead.&lt;/p>
</summary><description>&lt;p>The Deferred API is based on the concept of promises that provide a
generic interface into the eventual completion of an asynchronous action.
The motivation for promises fundamentally is about creating a
separation of concerns that allows one to achieve the same type of
call patterns and logical data flow in asynchronous code as can be
achieved in synchronous code. Promises allows one
to be able to call a function purely with arguments needed for
execution, without conflating the call with concerns of whether it is
sync or async. One shouldn&amp;#39;t need to alter a call&amp;#39;s arguments if the
implementation switches from sync to async (or vice versa). By having
async functions return promises, the concerns of making the call are
separated from the concerns of asynchronous interaction (which are
handled by the promise).

&lt;/p>
&lt;p>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&amp;#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

&lt;/p>
&lt;pre>&lt;code>  var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
  },
  function(error){
    ... handle error ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

&lt;/p>
&lt;p>The Deferred instances also provide the following functions for backwards compatibility:

&lt;/p>
&lt;ul>
&lt;li>addCallback(handler)&lt;/li>
&lt;li>addErrback(handler)&lt;/li>
&lt;li>callback(result)&lt;/li>
&lt;li>errback(result)&lt;/li>
&lt;/ul>
&lt;p>Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

&lt;/p>
&lt;p>The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var deferred = new Deferred();
  setTimeout(function(){ deferred.callback({success: true}); }, 1000);
  return deferred;&lt;/code>&lt;/pre>
</example><example>&lt;p>Deferred objects are often used when making code asynchronous. It
may be easiest to write functions in a synchronous manner and then
split code using a deferred to trigger a response to a long-lived
operation. For example, instead of register a callback function to
denote when a rendering operation completes, the function can
simply return a deferred:

&lt;/p>
&lt;pre>&lt;code>  // callback style:
  function renderLotsOfData(data, callback){
    var success = false
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      success = true;
    }catch(e){ }
    if(callback){
      callback(success);
    }
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using callback style
  renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
      promptUserToRecover();
    }
  });
  // NOTE: no way to add another callback here!!&lt;/code>&lt;/pre>
</example><example>&lt;p>Using a Deferred doesn&amp;#39;t simplify the sending code any, but it
provides a standard interface for callers and senders alike,
providing both with a simple way to service multiple callbacks for
an operation and freeing both sides from worrying about details
such as &amp;quot;did this get called already?&amp;quot;. With Deferreds, new
callbacks can be added at any time.

&lt;/p>
&lt;pre>&lt;code>  // Deferred style:
  function renderLotsOfData(data){
    var d = new Deferred();
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      d.callback(true);
    }catch(e){
      d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
    }
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });
  // NOTE: addErrback and addCallback both return the Deferred
  // again, so we could chain adding callbacks or save the
  // deferred for later should we need to be notified again.&lt;/code>&lt;/pre>
</example><example>&lt;p>In this example, renderLotsOfData is synchronous and so both
versions are pretty artificial. Putting the data display on a
timeout helps show why Deferreds rock:

&lt;/p>
&lt;pre>&lt;code>  // Deferred style and async func
  function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
      try{
        for(var x in data){
          renderDataitem(data[x]);
        }
        d.callback(true);
      }catch(e){
        d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
      }
    }, 100);
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that the caller doesn&amp;#39;t have to change his code at all to
handle the asynchronous case.&lt;/p>
</example></examples></object><object location="dojo/when" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/when"><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></method></methods><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></object><object location="dojo/_base/array" type="object"><properties/><methods><method name="every" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not every item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s every skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // returns false
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // returns true
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;0; });&lt;/code>&lt;/pre>
</example></examples></method><method name="some" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate over. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not any item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s some skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // is true
 array.some([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // is false
 array.some([1, 2, 3, 4], function(item){ return item&amp;lt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="indexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"/><parameter name="value" type="Object" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/><parameter name="findLast" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the first index of the provided value in the
passed array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s indexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&lt;/a>&lt;/p>
</description></method><method name="lastIndexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="undefined" usage="required"/><parameter name="value" type="undefined" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the last index of the provided value in the passed
array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s lastIndexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&lt;/a>&lt;/p>
</description></method><method name="forEach" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"/><parameter name="callback" type="Function|String" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>for every item in arr, callback is invoked. Return values are ignored.
If you want to break out of the loop, consider using array.every() or array.some().
forEach does not allow breaking out of the loop over the items in arr.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s forEach skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // log out all members of the array:
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item){
      console.log(item);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // log out the members and their indexes
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item, idx, arr){
      console.log(item, &amp;quot;at index:&amp;quot;, idx);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // use a scoped object member as the callback

 var obj = {
    prefix: &amp;quot;logged via obj.callback:&amp;quot;,
    callback: function(item){
      console.log(this.prefix, item);
    }
 };

 // specifying the scope function executes the callback in that scope
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    obj.callback,
    obj
 );

 // alternately, we can accomplish the same thing with lang.hitch()
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    lang.hitch(obj, &amp;quot;callback&amp;quot;)
 );&lt;/code>&lt;/pre>
</example></examples></method><method name="map" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on
individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments, (item, index,
array),   and returns a value&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter><parameter name="Ctr" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="instance"/></return-types><summary>&lt;p>applies callback to each element of arr and returns
an Array with the results&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s map skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4, 5]
 array.map([1, 2, 3, 4], function(item){ return item+1 });&lt;/code>&lt;/pre>
</example></examples></method><method name="filter" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"><summary>&lt;p>the array to iterate over.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function that is invoked with three arguments (item,
index, array). The return of this function is expected to
be a boolean which determines whether the passed-in item
will be included in the returned array.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns a new Array with those items from arr that match the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s filter skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4]
 array.filter([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="clearCache" scope="normal" type="function" from="dojo/_base/array"><parameters/><return-types/></method></methods><summary>&lt;p>The Javascript v1.6 array extensions.&lt;/p>
</summary></object><object location="dojo/Evented" type="function"><properties/><methods><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><parameters/><return-types/><summary>&lt;p>A class that can be used as a mixin or base class,
to add on() and emit() methods to a class
for listening for events and emitting events:

&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/Evented&amp;quot;], function(Evented){
    var EventedWidget = dojo.declare([Evented, dijit._Widget], {...});
    widget = new EventedWidget();
    widget.on(&amp;quot;open&amp;quot;, function(event){
    ... do something with event
   });

  widget.emit(&amp;quot;open&amp;quot;, {name:&amp;quot;some event&amp;quot;, ...});&lt;/code>&lt;/pre>
</summary></object><object location="dojo/aspect" type="object"><properties/><methods><method name="before" scope="normal" type="function" from="dojo/aspect"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>This is the target object&lt;/p>
</summary></parameter><parameter name="methodName" type="String" usage="required"><summary>&lt;p>This is the name of the method to attach to.&lt;/p>
</summary></parameter><parameter name="advice" type="Function" usage="required"><summary>&lt;p>This is function to be called before the original method&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The &amp;quot;before&amp;quot; export of the aspect module is a function that can be used to attach
&amp;quot;before&amp;quot; advice to a method. This function will be executed before the original method
is executed. This function will be called with the arguments used to call the method.
This function may optionally return an array as the new arguments to use to call
the original method (or the previous, next-to-execute before advice, if one exists).
If the before method doesn&amp;#39;t return anything (returns undefined) the original arguments
will be preserved.
If there are multiple &amp;quot;before&amp;quot; advisors, they are executed in the reverse order they were registered.&lt;/p>
</summary></method><method name="around" scope="normal" type="function" from="dojo/aspect"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>This is the target object&lt;/p>
</summary></parameter><parameter name="methodName" type="String" usage="required"><summary>&lt;p>This is the name of the method to attach to.&lt;/p>
</summary></parameter><parameter name="advice" type="Function" usage="required"><summary>&lt;p>This is function to be called around the original method&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The &amp;quot;around&amp;quot; export of the aspect module is a function that can be used to attach
&amp;quot;around&amp;quot; advice to a method. The advisor function is immediately executed when
the around() is called, is passed a single argument that is a function that can be
called to continue execution of the original method (or the next around advisor).
The advisor function should return a function, and this function will be called whenever
the method is called. It will be called with the arguments used to call the method.
Whatever this function returns will be returned as the result of the method call (unless after advise changes it).&lt;/p>
</summary><examples><example>&lt;p>If there are multiple &amp;quot;around&amp;quot; advisors, the most recent one is executed first,
which can then delegate to the next one and so on. For example:&lt;/p>
&lt;pre>&lt;code>  around(obj, &amp;quot;foo&amp;quot;, function(originalFoo){
    return function(){
      var start = new Date().getTime();
      var results = originalFoo.apply(this, arguments); // call the original
      var end = new Date().getTime();
      console.log(&amp;quot;foo execution took &amp;quot; + (end - start) + &amp;quot; ms&amp;quot;);
      return results;
    };
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="after" scope="normal" type="function" from="dojo/aspect"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>This is the target object&lt;/p>
</summary></parameter><parameter name="methodName" type="String" usage="required"><summary>&lt;p>This is the name of the method to attach to.&lt;/p>
</summary></parameter><parameter name="advice" type="Function" usage="required"><summary>&lt;p>This is function to be called after the original method&lt;/p>
</summary></parameter><parameter name="receiveArguments" type="Boolean" usage="optional"><summary>&lt;p>If this is set to true, the advice function receives the original arguments (from when the original mehtod
was called) rather than the return value of the original/previous method.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
stop the advice function from being executed.</return-description><summary>&lt;p>The &amp;quot;after&amp;quot; export of the aspect module is a function that can be used to attach
&amp;quot;after&amp;quot; advice to a method. This function will be executed after the original method
is executed. By default the function will be called with a single argument, the return
value of the original method, or the the return value of the last executed advice (if a previous one exists).
The fourth (optional) argument can be set to true to so the function receives the original
arguments (from when the original method was called) rather than the return value.
If there are multiple &amp;quot;after&amp;quot; advisors, they are executed in the order they were registered.&lt;/p>
</summary></method></methods><summary>&lt;p>provides aspect oriented programming functionality, allowing for
one to add before, around, or after advice on existing methods.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  define([&amp;quot;dojo/aspect&amp;quot;], function(aspect){
    var signal = aspect.after(targetObject, &amp;quot;methodName&amp;quot;, function(someArgument){
      this will be called when targetObject.methodName() is called, after the original function is called
    });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>The returned signal object can be used to cancel the advice.&lt;/p>
&lt;pre>&lt;code>  signal.remove(); // this will stop the advice from being executed anymore
  aspect.before(targetObject, &amp;quot;methodName&amp;quot;, function(someArgument){
    // this will be called when targetObject.methodName() is called, before the original function is called
   });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/on" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/on"><parameters><parameter name="target" type="Element|Object" usage="required"><summary>&lt;p>This is the target object or DOM element that to receive events from&lt;/p>
</summary></parameter><parameter name="type" type="String|Function" usage="required"><summary>&lt;p>This is the name of the event to listen for or an extension event type.&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>This is the function that should be called when the event fires.&lt;/p>
</summary></parameter><parameter name="dontFix" type="undefined" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><return-description>An object with a remove() method that can be used to stop listening for this
event.</return-description><summary>&lt;p>A function that provides core event listening functionality. With this function
you can provide a target, event type, and listener to be notified of
future matching events that are fired.&lt;/p>
</summary><description>&lt;p>To listen for &amp;quot;click&amp;quot; events on a button node, we can do:&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;], function(listen){
    on(button, &amp;quot;click&amp;quot;, clickHandler);
    ...&lt;/code>&lt;/pre>
&lt;p>Evented JavaScript objects can also have their own events.&lt;/p>
&lt;pre>&lt;code>  var obj = new Evented;
  on(obj, &amp;quot;foo&amp;quot;, fooHandler);&lt;/code>&lt;/pre>
&lt;p>And then we could publish a &amp;quot;foo&amp;quot; event:&lt;/p>
&lt;pre>&lt;code>  on.emit(obj, &amp;quot;foo&amp;quot;, {key: &amp;quot;value&amp;quot;});&lt;/code>&lt;/pre>
&lt;p>We can use extension events as well. For example, you could listen for a tap gesture:&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/gesture/tap&amp;quot;, function(listen, tap){
    on(button, tap, tapHandler);
    ...&lt;/code>&lt;/pre>
&lt;p>which would trigger fooHandler. Note that for a simple object this is equivalent to calling:&lt;/p>
&lt;pre>&lt;code>  obj.onfoo({key:&amp;quot;value&amp;quot;});&lt;/code>&lt;/pre>
&lt;p>If you use on.emit on a DOM node, it will use native event dispatching when possible.&lt;/p>
</description></method><method name="pausable" scope="normal" type="function" from="dojo/on"><parameters><parameter name="target" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/><parameter name="dontFix" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>This function acts the same as on(), but with pausable functionality. The
returned signal object has pause() and resume() functions. Calling the
pause() method will cause the listener to not be called for future events. Calling the
resume() method will cause the listener to again be called for future events.&lt;/p>
</summary></method><method name="once" scope="normal" type="function" from="dojo/on"><parameters><parameter name="target" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/><parameter name="dontFix" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>This function acts the same as on(), but will only call the listener once. The
listener will be called for the first
event that takes place and then listener will automatically be removed.&lt;/p>
</summary></method><method name="parse" scope="normal" type="function" from="dojo/on"><parameters><parameter name="target" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/><parameter name="addListener" type="undefined" usage="required"/><parameter name="dontFix" type="undefined" usage="required"/><parameter name="matchesTarget" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="selector" scope="normal" type="function" from="dojo/on"><parameters><parameter name="selector" type="undefined" usage="required"><summary>&lt;p>The CSS selector to use for filter events and determine the |this| of the event listener.&lt;/p>
</summary></parameter><parameter name="eventType" type="undefined" usage="required"><summary>&lt;p>The event to listen for&lt;/p>
</summary></parameter><parameter name="children" type="undefined" usage="required"><summary>&lt;p>Indicates if children elements of the selector should be allowed. This defaults to 
true&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Creates a new extension event with event delegation. This is based on
the provided event type (can be extension event) that
only calls the listener when the CSS selector matches the target of the event.

&lt;/p>
&lt;p>The application must require() an appropriate level of dojo/query to handle the selector.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/mouse&amp;quot;, &amp;quot;dojo/query!css2&amp;quot;], function(listen, mouse){
    on(node, on.selector(&amp;quot;.my-class&amp;quot;, mouse.enter), handlerForMyHover);&lt;/code>&lt;/pre>
</example></examples></method><method name="emit" scope="normal" type="function" from="dojo/on"><parameters><parameter name="target" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types/></method><method name="_fixEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="undefined" usage="required"/><parameter name="se" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_preventDefault" scope="normal" type="function" from="dojo/on"><parameters/><return-types/></method></methods><parameters><parameter name="target" type="Element|Object" usage="required"><summary>&lt;p>This is the target object or DOM element that to receive events from&lt;/p>
</summary></parameter><parameter name="type" type="String|Function" usage="required"><summary>&lt;p>This is the name of the event to listen for or an extension event type.&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>This is the function that should be called when the event fires.&lt;/p>
</summary></parameter><parameter name="dontFix" type="undefined" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><return-description>An object with a remove() method that can be used to stop listening for this
event.</return-description><summary>&lt;p>A function that provides core event listening functionality. With this function
you can provide a target, event type, and listener to be notified of
future matching events that are fired.&lt;/p>
</summary><description>&lt;p>To listen for &amp;quot;click&amp;quot; events on a button node, we can do:&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;], function(listen){
    on(button, &amp;quot;click&amp;quot;, clickHandler);
    ...&lt;/code>&lt;/pre>
&lt;p>Evented JavaScript objects can also have their own events.&lt;/p>
&lt;pre>&lt;code>  var obj = new Evented;
  on(obj, &amp;quot;foo&amp;quot;, fooHandler);&lt;/code>&lt;/pre>
&lt;p>And then we could publish a &amp;quot;foo&amp;quot; event:&lt;/p>
&lt;pre>&lt;code>  on.emit(obj, &amp;quot;foo&amp;quot;, {key: &amp;quot;value&amp;quot;});&lt;/code>&lt;/pre>
&lt;p>We can use extension events as well. For example, you could listen for a tap gesture:&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/gesture/tap&amp;quot;, function(listen, tap){
    on(button, tap, tapHandler);
    ...&lt;/code>&lt;/pre>
&lt;p>which would trigger fooHandler. Note that for a simple object this is equivalent to calling:&lt;/p>
&lt;pre>&lt;code>  obj.onfoo({key:&amp;quot;value&amp;quot;});&lt;/code>&lt;/pre>
&lt;p>If you use on.emit on a DOM node, it will use native event dispatching when possible.&lt;/p>
</description></object><object location="dojo/NodeList-data" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-data"><parameters/><return-types/><summary>&lt;p>Adds data() and removeData() methods to NodeList, and returns NodeList constructor.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds data() and removeData() methods to NodeList, and returns NodeList constructor.&lt;/p>
</summary></object><object location="dojo/query" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="selector" type="String" usage="required"><summary>&lt;p>A CSS selector to search for.&lt;/p>
</summary></parameter><parameter name="context" type="String|DomNode" usage="optional"><summary>&lt;p>An optional context to limit the searching scope. Only nodes under &lt;code>context&lt;/code> will be
scanned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>This modules provides DOM querying functionality. The module export is a function
that can be used to query for DOM nodes by CSS selector and returns a NodeList
representing the matching nodes.&lt;/p>
</summary><description>&lt;p>dojo/query is responsible for loading the appropriate query engine and wrapping
its results with a &lt;code>NodeList&lt;/code>. You can use dojo/query with a specific selector engine
by using it as a plugin. For example, if you installed the sizzle package, you could
use it as the selector engine with:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query!sizzle&amp;quot;], function(query){
    query(&amp;quot;div&amp;quot;)...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The id after the ! can be a module id of the selector engine or one of the following values:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>acme: This is the default engine used by Dojo base, and will ensure that the full
Acme engine is always loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css2: If the browser has a native selector engine, this will be used, otherwise a
very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&amp;gt;)
operators) and nothing more.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css2.1: If the browser has a native selector engine, this will be used, otherwise the
full Acme engine will be loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css3: If the browser has a native selector engine with support for CSS3 pseudo
selectors (most modern browsers except IE8), this will be used, otherwise the
full Acme engine will be loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>Or the module id of a selector engine can be used to explicitly choose the selector engine&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>For example, if you are using CSS3 pseudo selectors in module, you can specify that
you will need support them with:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query!css3&amp;quot;], function(query){
    query(&amp;#39;#t &amp;gt; h3:nth-child(odd)&amp;#39;)...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>You can also choose the selector engine/load configuration by setting the query-selector:
For example:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;script data-dojo-config=&amp;quot;query-selector:&amp;#39;css3&amp;#39;&amp;quot; src=&amp;quot;dojo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</description><examples><example>&lt;p>add an onclick handler to every submit button in the document
which causes the form to be sent via Ajax instead:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;input[type=&amp;#39;submit&amp;#39;]&amp;quot;).on(&amp;quot;click&amp;quot;, function(e){
      dojo.stopEvent(e); // prevent sending the form
      var btn = e.target;
      dojo.xhrPost({
        form: btn.form,
        load: function(data){
          // replace the form with the response
          var div = dojo.doc.createElement(&amp;quot;div&amp;quot;);
          dojo.place(div, btn.form, &amp;quot;after&amp;quot;);
          div.innerHTML = data;
          dojo.style(btn.form, &amp;quot;display&amp;quot;, &amp;quot;none&amp;quot;);
        }
      });
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="load" scope="normal" type="function" from="dojo/query"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="parentRequire" type="undefined" usage="required"/><parameter name="loaded" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>can be used as AMD plugin to conditionally load new query engine&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/query!custom&amp;quot;], function(qsa){
    // loaded selector/custom.js as engine
    qsa(&amp;quot;#foobar&amp;quot;).forEach(...);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_filterResult" scope="normal" type="function" from="dojo/query"><parameters><parameter name="nodes" type="undefined" usage="required"/><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/><return-type type="undefined"/></return-types></method><method name="NodeList" scope="normal" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="selector" type="String" usage="required"><summary>&lt;p>A CSS selector to search for.&lt;/p>
</summary></parameter><parameter name="context" type="String|DomNode" usage="optional"><summary>&lt;p>An optional context to limit the searching scope. Only nodes under &lt;code>context&lt;/code> will be
scanned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>This modules provides DOM querying functionality. The module export is a function
that can be used to query for DOM nodes by CSS selector and returns a NodeList
representing the matching nodes.&lt;/p>
</summary><description>&lt;p>dojo/query is responsible for loading the appropriate query engine and wrapping
its results with a &lt;code>NodeList&lt;/code>. You can use dojo/query with a specific selector engine
by using it as a plugin. For example, if you installed the sizzle package, you could
use it as the selector engine with:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query!sizzle&amp;quot;], function(query){
    query(&amp;quot;div&amp;quot;)...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The id after the ! can be a module id of the selector engine or one of the following values:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>acme: This is the default engine used by Dojo base, and will ensure that the full
Acme engine is always loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css2: If the browser has a native selector engine, this will be used, otherwise a
very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&amp;gt;)
operators) and nothing more.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css2.1: If the browser has a native selector engine, this will be used, otherwise the
full Acme engine will be loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>css3: If the browser has a native selector engine with support for CSS3 pseudo
selectors (most modern browsers except IE8), this will be used, otherwise the
full Acme engine will be loaded.&lt;/p>
&lt;/li>
&lt;li>&lt;p>Or the module id of a selector engine can be used to explicitly choose the selector engine&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>For example, if you are using CSS3 pseudo selectors in module, you can specify that
you will need support them with:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query!css3&amp;quot;], function(query){
    query(&amp;#39;#t &amp;gt; h3:nth-child(odd)&amp;#39;)...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>You can also choose the selector engine/load configuration by setting the query-selector:
For example:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;script data-dojo-config=&amp;quot;query-selector:&amp;#39;css3&amp;#39;&amp;quot; src=&amp;quot;dojo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</description><examples><example>&lt;p>add an onclick handler to every submit button in the document
which causes the form to be sent via Ajax instead:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;input[type=&amp;#39;submit&amp;#39;]&amp;quot;).on(&amp;quot;click&amp;quot;, function(e){
      dojo.stopEvent(e); // prevent sending the form
      var btn = e.target;
      dojo.xhrPost({
        form: btn.form,
        load: function(data){
          // replace the form with the response
          var div = dojo.doc.createElement(&amp;quot;div&amp;quot;);
          dojo.place(div, btn.form, &amp;quot;after&amp;quot;);
          div.innerHTML = data;
          dojo.style(btn.form, &amp;quot;display&amp;quot;, &amp;quot;none&amp;quot;);
        }
      });
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></object><object location="dojo/dom" type="object"><properties/><methods><method name="byId" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="id" type="String|DOMNode" usage="required"><summary>&lt;p>A string to match an HTML id attribute or a reference to a DOM Node
&lt;/p>
</summary></parameter><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Document to work in. Defaults to the current value of
dojo.doc.  Can be used to retrieve
node references from other documents.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns DOM node with matching &lt;code>id&lt;/code> attribute or falsy value (ex: null or undefined)
if not found.  If &lt;code>id&lt;/code> is a DomNode, this function is a no-op.
&lt;/p>
</summary><examples><example>&lt;p>Look up a node by ID:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Check if a node exists, and use it.&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;bar&amp;quot;);
  if(n){ doStuff() ... }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Allow string or DomNode references to be passed to a custom function:&lt;/p>
&lt;pre>&lt;code>  var foo = function(nodeOrId){
    nodeOrId = dojo.byId(nodeOrId);
    // ... more stuff
  }&lt;/code>&lt;/pre>
</example></examples></method><method name="isDescendant" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference to test&lt;/p>
</summary></parameter><parameter name="ancestor" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference of potential parent to test against
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if node is a descendant of ancestor&lt;/p>
</summary><examples><example>&lt;p>Test is node id=&amp;quot;bar&amp;quot; is a descendant of node id=&amp;quot;foo&amp;quot;&lt;/p>
&lt;pre>&lt;code>  if(dojo.isDescendant(&amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="setSelectable" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="selectable" type="undefined" usage="required"/></parameters><return-types/></method></methods><summary>&lt;p>This module defines the core dojo DOM API.&lt;/p>
</summary></object><object location="dojo/_base/window" type="object"><properties><property name="global" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current window. &amp;#39;global&amp;#39; can be modified
for temporary context shifting. See also withGlobal().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description></property><property name="doc" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current document. &amp;#39;doc&amp;#39; can be modified
for temporary context shifting. See also withDoc().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window.document&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  n.appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></property></properties><methods><method name="body" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the body element of the specified document or of dojo/_base/window::doc.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  win.body().appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></method><method name="setContext" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="globalDocument" type="DocumentElement" usage="required"/></parameters><return-types/><summary>&lt;p>changes the behavior of many core Dojo functions that deal with
namespace and DOM lookup, changing them to work in a new global
context (e.g., an iframe). The varibles dojo.global and dojo.doc
are modified as a result of calling this function and the result of
&lt;code>dojo.body()&lt;/code> likewise differs.&lt;/p>
</summary></method><method name="withGlobal" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc. If provided, globalObject
will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo.global
and dojo.doc will be restored to its previous state.&lt;/p>
</description></method><method name="withDoc" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="documentObject" type="DocumentElement" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,
callback will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo/_base/window::doc will
be restored to its previous state.&lt;/p>
</description></method></methods><summary>&lt;p>API to save/set/restore the global/document scope.&lt;/p>
</summary></object><object location="dojo/selector/_loader" type="object"><properties/><methods><method name="load" scope="normal" type="function" from="dojo/selector/_loader"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="parentRequire" type="undefined" usage="required"/><parameter name="loaded" type="undefined" usage="required"/><parameter name="config" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><summary>&lt;p>This module handles loading the appropriate selector engine for the given browser&lt;/p>
</summary></object><object location="dojo/dom-attr" type="object"><properties/><methods><method name="has" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to check&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>true if the requested attribute is specified on the
given element, and false otherwise</return-description><summary>&lt;p>Returns true if the requested attribute is specified on the
given element, and false otherwise.&lt;/p>
</summary></method><method name="get" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/><return-type type="null"/></return-types><return-description>the value of the requested attribute or null if that attribute does not have a specified or
default value;
</return-description><summary>&lt;p>Gets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of attributes on DOM Nodes.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.getAttr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="set" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to set, or a hash of key-value pairs to set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>the value to set for the attribute, if the name is a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of attributes on DOM Nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.setAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setAttr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.setStyle(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="remove" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to remove&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes an attribute from an HTML element.&lt;/p>
</summary></method><method name="getNodeProp" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the attribute</return-description><summary>&lt;p>Returns an effective value of a property or an attribute.&lt;/p>
</summary></method></methods></object><object location="dojo/dom-style" type="object"><properties/><methods><method name="getComputedStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>A reference to a DOM node. Does NOT support taking an
ID string for speed reasons.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &amp;quot;computed style&amp;quot; object.
&lt;/p>
</summary><description>&lt;p>Gets a &amp;quot;computed style&amp;quot; object which can be used to gather
information about the current state of the rendered node.

&lt;/p>
&lt;p>Note that this may behave differently on different browsers.
Values may have different formats and value encodings across
browsers.

&lt;/p>
&lt;p>Note also that this method is expensive.  Wherever possible,
reuse the returned object.

&lt;/p>
&lt;p>Use the dojo.style() method for more consistent (pixelized)
return values.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.getComputedStyle(dojo.byId(&amp;#39;foo&amp;#39;)).borderWidth;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Reusing the returned object, avoiding multiple lookups:&lt;/p>
&lt;pre>&lt;code>  var cs = dojo.getComputedStyle(dojo.byId(&amp;quot;someNode&amp;quot;));
  var w = cs.width, h = cs.height;&lt;/code>&lt;/pre>
</example></examples></method><method name="toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="get" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get style for&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="optional"><summary>&lt;p>the style property to get&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Accesses styles on a node.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
</example></examples></method><method name="set" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><return-description>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</return-description><summary>&lt;p>Sets styles on a node.&lt;/p>
</summary><examples><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo.query()&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module defines the core dojo DOM style API.&lt;/p>
</summary></object><object location="dojo/dom-prop" type="object"><properties><property name="names" scope="normal" type="object" from="dojo/dom-prop"/></properties><methods><method name="get" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the property on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the property to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the requested property or its default value
</return-description><summary>&lt;p>Gets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of properties on DOM nodes.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.getProp(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getProp(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="set" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to set, or a hash object to set
multiple properties at once.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of properties on DOM nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.setProp(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setProp(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method></methods></object><object location="dojo/dom-construct" type="object"><properties/><methods><method name="toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="place" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference to use as basis for placement&lt;/p>
</summary></parameter><parameter name="position" type="String|Number" usage="optional"><summary>&lt;p>string noting the position of node relative to refNode or a
number indicating the location in the childNodes collection of refNode.
Accepted string values are:

&lt;/p>
&lt;ul>
&lt;li>before&lt;/li>
&lt;li>after&lt;/li>
&lt;li>replace&lt;/li>
&lt;li>only&lt;/li>
&lt;li>first&lt;/li>
&lt;li>last&lt;/li>
&lt;/ul>
&lt;p>&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified&lt;/p>
</summary></parameter></parameters><return-types><return-type type="DOMNode"/><return-type type="undefined"/></return-types><return-description>Returned values is the first argument resolved to a DOM node.

.place() is also a method of `dojo/NodeList`, allowing `dojo.query` node lookups.</return-description><summary>&lt;p>Attempt to insert node into the DOM, choosing from various positioning options.
Returns the first argument resolved to a DOM node.&lt;/p>
</summary><examples><example>&lt;p>Place a node by string id as the last child of another node by string id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Place a node by string id before another node by string id&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;, &amp;quot;before&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Create a Node, and place it in the body element (last child):&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;, dojo.body());&lt;/code>&lt;/pre>
</example><example>&lt;p>Put a new LI as the first child of a list by id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;, &amp;quot;someUl&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="create" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="tag" type="DOMNode|String" usage="required"><summary>&lt;p>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
or an existing DOM node to process.&lt;/p>
</summary></parameter><parameter name="attrs" type="Object" usage="required"><summary>&lt;p>An object-hash of attributes to set on the newly created node.
Can be null, if you don&amp;#39;t want to set any attributes/styles.
See: &lt;code>dojo.setAttr&lt;/code> for a description of available attributes.&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="optional"><summary>&lt;p>Optional reference node. Used by &lt;code>dojo.place&lt;/code> to place the newly created
node somewhere in the dom relative to refNode. Can be a DomNode reference
or String ID of a node.&lt;/p>
</summary></parameter><parameter name="pos" type="String" usage="optional"><summary>&lt;p>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code>dojo.place&lt;/code>,
though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
to further control the placement of the new node relative to the refNode.
&amp;#39;refNode&amp;#39; is required if a &amp;#39;pos&amp;#39; is specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create an element, allowing for optional attribute decoration
and placement.&lt;/p>
</summary><description>&lt;p>A DOM Element creation function. A shorthand method for creating a node or
a fragment, and allowing for a convenient optional attribute setting step,
as well as an optional DOM placement reference.

&lt;/p>
&lt;p>Attributes are set by passing the optional object through &lt;code>dojo.setAttr&lt;/code>.
See &lt;code>dojo.setAttr&lt;/code> for noted caveats and nuances, and API if applicable.

&lt;/p>
&lt;p>Placement is done via &lt;code>dojo.place&lt;/code>, assuming the new node to be the action
node, passing along the optional reference node and position.&lt;/p>
</description><examples><example>&lt;p>Create a DIV:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a DIV with content:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, { innerHTML:&amp;quot;&amp;lt;p&amp;gt;hi&amp;lt;/p&amp;gt;&amp;quot; });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Place a new DIV in the BODY, with no attributes set&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, null, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an UL, and populate it with LI&amp;#39;s. Place the list as the first-child of a
node with id=&amp;quot;someId&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  var ul = dojo.create(&amp;quot;ul&amp;quot;, null, &amp;quot;someId&amp;quot;, &amp;quot;first&amp;quot;);
  var items = [&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;];
  dojo.forEach(items, function(data){
    dojo.create(&amp;quot;li&amp;quot;, { innerHTML: data }, ul);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an anchor, with an href. Place in BODY:&lt;/p>
&lt;pre>&lt;code>  dojo.create(&amp;quot;a&amp;quot;, { href:&amp;quot;foo.html&amp;quot;, title:&amp;quot;Goto FOO!&amp;quot; }, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a &lt;code>dojo/NodeList()&lt;/code> from a new element (for syntactic sugar):&lt;/p>
&lt;pre>&lt;code>  dojo.query(dojo.create(&amp;#39;div&amp;#39;))
    .addClass(&amp;quot;newDiv&amp;quot;)
    .onclick(function(e){ console.log(&amp;#39;clicked&amp;#39;, e.target) })
    .place(&amp;quot;#someNode&amp;quot;); // redundant, but cleaner.&lt;/code>&lt;/pre>
</example></examples></method><method name="empty" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>a reference to a DOM node or an id.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>safely removes all children of the node.&lt;/p>
</summary><examples><example>&lt;p>Destroy node&amp;#39;s children byId:&lt;/p>
&lt;pre>&lt;code>  dojo.empty(&amp;quot;someId&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Destroy all nodes&amp;#39; children in a list by reference:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someNode&amp;quot;).forEach(dojo.empty);&lt;/code>&lt;/pre>
</example></examples></method><method name="destroy" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>A String ID or DomNode reference of the element to be destroyed
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes a node from its parent, clobbering it and all of its
children.
&lt;/p>
</summary><description>&lt;p>Removes a node from its parent, clobbering it and all of its
children. Function only works with DomNodes, and returns nothing.
&lt;/p>
</description><examples><example>&lt;p>Destroy a node byId:&lt;/p>
&lt;pre>&lt;code>  dojo.destroy(&amp;quot;someId&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Destroy all nodes in a list by reference:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someNode&amp;quot;).forEach(dojo.destroy);&lt;/code>&lt;/pre>
</example></examples></method></methods></object><object location="dojo/_base/connect" type="object"><properties/><methods><method name="_keypress" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="object" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="connect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>The source object for the event function.
Defaults to &lt;code>kernel.global&lt;/code> if null.
If obj is a DOM node, the connection is delegated
to the DOM event manager (unless dontFix is true).
&lt;/p>
</summary></parameter><parameter name="event" type="String" usage="required"><summary>&lt;p>String name of the event function in obj.
I.e. identifies a property &lt;code>obj[event]&lt;/code>.
&lt;/p>
</summary></parameter><parameter name="context" type="Object|null" usage="required"><summary>&lt;p>The object that method will receive as &amp;quot;this&amp;quot;.

&lt;/p>
&lt;p>If context is null and method is a function, then method
inherits the context of event.

&lt;/p>
&lt;p>If method is a string then context must be the source
object object for method (context[method]). If context is null,
kernel.global is used.
&lt;/p>
</summary></parameter><parameter name="method" type="String|Function" usage="required"><summary>&lt;p>A function reference, or name of a function in context.
The function identified by method fires after event does.
method receives the same arguments as the event.
See context argument comments for information on method&amp;#39;s scope.
&lt;/p>
</summary></parameter><parameter name="dontFix" type="Boolean" usage="optional"><summary>&lt;p>If obj is a DOM node, set dontFix to true to prevent delegation
of this connection to the DOM event manager.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>&lt;code>dojo.connect&lt;/code> is a deprecated event handling and delegation method in
Dojo. It allows one function to &amp;quot;listen in&amp;quot; on the execution of
any other, triggering the second whenever the first is called. Many
listeners may be attached to a function, and source functions may
be either regular function calls or DOM events.
&lt;/p>
</summary><description>&lt;p>Connects listeners to actions, so that after event fires, a
listener is called with the same arguments passed to the original
function.

&lt;/p>
&lt;p>Since &lt;code>dojo.connect&lt;/code> allows the source of events to be either a
&amp;quot;regular&amp;quot; JavaScript function or a DOM event, it provides a uniform
interface for listening to all the types of events that an
application is likely to deal with though a single, unified
interface. DOM programmers may want to think of it as
&amp;quot;addEventListener for everything and anything&amp;quot;.

&lt;/p>
&lt;p>When setting up a connection, the &lt;code>event&lt;/code> parameter must be a
string that is the name of the method/event to be listened for. If
&lt;code>obj&lt;/code> is null, &lt;code>kernel.global&lt;/code> is assumed, meaning that connections
to global methods are supported but also that you may inadvertently
connect to a global by passing an incorrect object name or invalid
reference.

&lt;/p>
&lt;p>&lt;code>dojo.connect&lt;/code> generally is forgiving. If you pass the name of a
function or method that does not yet exist on &lt;code>obj&lt;/code>, connect will
not fail, but will instead set up a stub method. Similarly, null
arguments may simply be omitted such that fewer than 4 arguments
may be required to set up a connection See the examples for details.

&lt;/p>
&lt;p>The return value is a handle that is needed to
remove this connection with &lt;code>dojo.disconnect&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>When obj.onchange(), do ui.update():&lt;/p>
&lt;pre>&lt;code>  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, ui.update); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using return value for disconnect:&lt;/p>
&lt;pre>&lt;code>  var link = dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  ...
  dojo.disconnect(link);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When onglobalevent executes, watcher.handler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;onglobalevent&amp;quot;, watcher, &amp;quot;handler&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, &amp;quot;customEventHandler&amp;quot;);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, &amp;quot;customEventHandler&amp;quot;); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, customEventHandler);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, customEventHandler); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When globalEvent executes, globalHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;globalEvent&amp;quot;, null, globalHandler);
  dojo.connect(&amp;quot;globalEvent&amp;quot;, globalHandler); // same&lt;/code>&lt;/pre>
</example></examples></method><method name="disconnect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>the return value of the dojo.connect call that created the connection.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a link created by dojo.connect.&lt;/p>
</summary><description>&lt;p>Removes the connection between event and the method referenced by handle.&lt;/p>
</description></method><method name="subscribe" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="topic" type="String" usage="required"><summary>&lt;p>The topic to which to subscribe.&lt;/p>
</summary></parameter><parameter name="context" type="Object" usage="optional"><summary>&lt;p>Scope in which method will be invoked, or null for default scope.&lt;/p>
</summary></parameter><parameter name="method" type="String|Function" usage="required"><summary>&lt;p>The name of a function in context, or a function reference. This is the function that
is invoked when topic is published.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Attach a listener to a named topic. The listener function is invoked whenever the
named topic is published (see: dojo.publish).
Returns a handle which is needed to unsubscribe this listener.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); });
  dojo.publish(&amp;quot;alerts&amp;quot;, [ &amp;quot;read this&amp;quot;, &amp;quot;hello world&amp;quot; ]);&lt;/code>&lt;/pre>
</example></examples></method><method name="publish" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="topic" type="String" usage="required"><summary>&lt;p>The name of the topic to publish.&lt;/p>
</summary></parameter><parameter name="args" type="Array" usage="optional"><summary>&lt;p>An array of arguments. The arguments will be applied
to each topic subscriber (as first class parameters, via apply).&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke all listener method subscribed to topic.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); };
  dojo.publish(&amp;quot;alerts&amp;quot;, [ &amp;quot;read this&amp;quot;, &amp;quot;hello world&amp;quot; ]);&lt;/code>&lt;/pre>
</example></examples></method><method name="connectPublisher" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="topic" type="String" usage="required"><summary>&lt;p>The name of the topic to publish.&lt;/p>
</summary></parameter><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>The source object for the event function. Defaults to kernel.global
if null.&lt;/p>
</summary></parameter><parameter name="event" type="String" usage="required"><summary>&lt;p>The name of the event function in obj.
I.e. identifies a property obj[event].&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Ensure that every time obj.event() is called, a message is published
on the topic. Returns a handle which can be passed to
dojo.disconnect() to disable subsequent automatic publication on
the topic.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.connectPublisher(&amp;quot;/ajax/start&amp;quot;, dojo, &amp;quot;xhrGet&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isCopyKey" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>Event object to examine&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)&lt;/p>
</summary></method><method name="unsubscribe" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>The handle returned from a call to subscribe.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a topic listener.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var alerter = dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); };
  ...
  dojo.unsubscribe(alerter);&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module defines the dojo.connect API.
This modules also provides keyboard event handling helpers.
This module exports an extension event for emulating Firefox&amp;#39;s keypress handling.
However, this extension event exists primarily for backwards compatibility and
is not recommended. WebKit and IE uses an alternate keypress handling (only
firing for printable characters, to distinguish from keydown events), and most
consider the WebKit/IE behavior more desirable.&lt;/p>
</summary></object><object location="dojo/topic" type="object"><properties/><methods><method name="publish" scope="normal" type="function" from="dojo/topic"><parameters><parameter name="topic" type="String" usage="required"><summary>&lt;p>The name of the topic to publish to&lt;/p>
</summary></parameter><parameter name="event" type="Object" usage="required"><summary>&lt;p>An event to distribute to the topic listeners&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Publishes a message to a topic on the pub/sub hub. All arguments after
the first will be passed to the subscribers, so any number of arguments
can be provided (not just event).&lt;/p>
</summary></method><method name="subscribe" scope="normal" type="function" from="dojo/topic"><parameters><parameter name="topic" type="String" usage="required"><summary>&lt;p>The topic to subscribe to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>A function to call when a message is published to the given topic&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Subscribes to a topic on the pub/sub hub&lt;/p>
</summary></method></methods><summary>&lt;p>Pubsub hub.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>   topic.subscribe(&amp;quot;some/topic&amp;quot;, function(event){
  ... do something with event
  });
  topic.publish(&amp;quot;some/topic&amp;quot;, {name:&amp;quot;some event&amp;quot;, ...});&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/_base/event" type="object"><properties/><methods><method name="fix" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>native event object&lt;/p>
</summary></parameter><parameter name="sender" type="DOMNode" usage="required"><summary>&lt;p>node to treat as &amp;quot;currentTarget&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Event"/></return-types><return-description>&lt;p>native event object&lt;/p>
</return-description><summary>&lt;p>normalizes properties on the event object including event
bubbling methods, keystroke normalization, and x/y positions&lt;/p>
</summary></method><method name="stop" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>The event object. If omitted, window.event is used on IE.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>prevents propagation and clobbers the default action of the
passed event&lt;/p>
</summary></method></methods><summary>&lt;p>This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
evt.preventDefault(), rather than this module.&lt;/p>
</summary></object><object location="dojo/dom-geometry" type="object"><properties><property name="boxModel" scope="normal" type="string" from="dojo/dom-geometry"/></properties><methods><method name="getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="setContentSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the size of the node&amp;#39;s contents, irrespective of margins,
padding, or borders.&lt;/p>
</summary></method><method name="setMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;l&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>sets the size of the node&amp;#39;s margin box and placement
(left/top), irrespective of box model. Think of it as a
passthrough to setBox that handles box-model vagaries for
you.&lt;/p>
</summary></method><method name="isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="position" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Object"/><return-type type="object"/></return-types><summary>&lt;p>Gets the position and size of the passed element relative to
the viewport (if includeScroll==false), or relative to the
document root (if includeScroll==true).
&lt;/p>
</summary><description>&lt;p>Returns an object of the form:
&lt;code>{ x: 100, y: 300, w: 20, h: 15 }&lt;/code>.
If includeScroll==true, the x and y values will include any
document offsets that may affect the position relative to the
viewport.
Uses the border-box model (inclusive of border and padding but
not margin).  Does not act as a setter.&lt;/p>
</description></method><method name="getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="normalizeEvent" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="event" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
offsetX, offsetY, layerX, and layerX properties&lt;/p>
</summary></method></methods><summary>&lt;p>This module defines the core dojo DOM geometry API.&lt;/p>
</summary></object><object location="dojo/mouse" type="object"><properties><property name="enter" scope="normal" type="undefined" from="dojo/mouse"><summary>&lt;p>This is an extension event for the mouseenter that IE provides, emulating the
behavior on other browsers.&lt;/p>
</summary></property><property name="leave" scope="normal" type="undefined" from="dojo/mouse"><summary>&lt;p>This is an extension event for the mouseleave that IE provides, emulating the
behavior on other browsers.&lt;/p>
</summary></property></properties><methods><method name="_eventHandler" scope="normal" type="function" from="dojo/mouse"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="selectHandler" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types></method><method name="wheel" scope="normal" type="function" from="dojo/mouse"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>This is an extension event for the mousewheel that non-Mozilla browsers provide,
emulating the behavior on Mozilla based browsers.&lt;/p>
</summary></method><method name="isLeft" scope="normal" type="function" from="dojo/mouse"><parameters/><return-types/><summary>&lt;p>Test an event object (from a mousedown event) to see if the left button was pressed.&lt;/p>
</summary></method><method name="isMiddle" scope="normal" type="function" from="dojo/mouse"><parameters/><return-types/><summary>&lt;p>Test an event object (from a mousedown event) to see if the middle button was pressed.&lt;/p>
</summary></method><method name="isRight" scope="normal" type="function" from="dojo/mouse"><parameters/><return-types/><summary>&lt;p>Test an event object (from a mousedown event) to see if the right button was pressed.&lt;/p>
</summary></method></methods><summary>&lt;p>This module provide mouse event handling utility functions and exports
mouseenter and mouseleave event emulation.&lt;/p>
</summary><examples><example>&lt;p>To use these events, you register a mouseenter like this:&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, dojo/mouse&amp;quot;], function(on, mouse){
    on(targetNode, mouse.enter, function(event){
      dojo.addClass(targetNode, &amp;quot;highlighted&amp;quot;);
    });
    on(targetNode, mouse.leave, function(event){
      dojo.removeClass(targetNode, &amp;quot;highlighted&amp;quot;);
    });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/_base/sniff" type="object"><properties/><methods/><summary>&lt;p>Deprecated.   New code should use dojo/sniff.
This module populates the dojo browser version sniffing properties like dojo.isIE.&lt;/p>
</summary></object><object location="dojo/keys" type="object"><properties><property name="BACKSPACE" scope="normal" type="number" from="dojo/keys"/><property name="TAB" scope="normal" type="number" from="dojo/keys"/><property name="CLEAR" scope="normal" type="number" from="dojo/keys"/><property name="ENTER" scope="normal" type="number" from="dojo/keys"/><property name="SHIFT" scope="normal" type="number" from="dojo/keys"/><property name="CTRL" scope="normal" type="number" from="dojo/keys"/><property name="ALT" scope="normal" type="number" from="dojo/keys"/><property name="META" scope="normal" type="number" from="dojo/keys"/><property name="PAUSE" scope="normal" type="number" from="dojo/keys"/><property name="CAPS_LOCK" scope="normal" type="number" from="dojo/keys"/><property name="ESCAPE" scope="normal" type="number" from="dojo/keys"/><property name="SPACE" scope="normal" type="number" from="dojo/keys"/><property name="PAGE_UP" scope="normal" type="number" from="dojo/keys"/><property name="PAGE_DOWN" scope="normal" type="number" from="dojo/keys"/><property name="END" scope="normal" type="number" from="dojo/keys"/><property name="HOME" scope="normal" type="number" from="dojo/keys"/><property name="LEFT_ARROW" scope="normal" type="number" from="dojo/keys"/><property name="UP_ARROW" scope="normal" type="number" from="dojo/keys"/><property name="RIGHT_ARROW" scope="normal" type="number" from="dojo/keys"/><property name="DOWN_ARROW" scope="normal" type="number" from="dojo/keys"/><property name="INSERT" scope="normal" type="number" from="dojo/keys"/><property name="DELETE" scope="normal" type="number" from="dojo/keys"/><property name="HELP" scope="normal" type="number" from="dojo/keys"/><property name="LEFT_WINDOW" scope="normal" type="number" from="dojo/keys"/><property name="RIGHT_WINDOW" scope="normal" type="number" from="dojo/keys"/><property name="SELECT" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_0" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_1" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_2" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_3" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_4" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_5" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_6" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_7" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_8" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_9" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_MULTIPLY" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_PLUS" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_ENTER" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_MINUS" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_PERIOD" scope="normal" type="number" from="dojo/keys"/><property name="NUMPAD_DIVIDE" scope="normal" type="number" from="dojo/keys"/><property name="F1" scope="normal" type="number" from="dojo/keys"/><property name="F2" scope="normal" type="number" from="dojo/keys"/><property name="F3" scope="normal" type="number" from="dojo/keys"/><property name="F4" scope="normal" type="number" from="dojo/keys"/><property name="F5" scope="normal" type="number" from="dojo/keys"/><property name="F6" scope="normal" type="number" from="dojo/keys"/><property name="F7" scope="normal" type="number" from="dojo/keys"/><property name="F8" scope="normal" type="number" from="dojo/keys"/><property name="F9" scope="normal" type="number" from="dojo/keys"/><property name="F10" scope="normal" type="number" from="dojo/keys"/><property name="F11" scope="normal" type="number" from="dojo/keys"/><property name="F12" scope="normal" type="number" from="dojo/keys"/><property name="F13" scope="normal" type="number" from="dojo/keys"/><property name="F14" scope="normal" type="number" from="dojo/keys"/><property name="F15" scope="normal" type="number" from="dojo/keys"/><property name="NUM_LOCK" scope="normal" type="number" from="dojo/keys"/><property name="SCROLL_LOCK" scope="normal" type="number" from="dojo/keys"/><property name="UP_DPAD" scope="normal" type="number" from="dojo/keys"/><property name="DOWN_DPAD" scope="normal" type="number" from="dojo/keys"/><property name="LEFT_DPAD" scope="normal" type="number" from="dojo/keys"/><property name="RIGHT_DPAD" scope="normal" type="number" from="dojo/keys"/><property name="copyKey" scope="normal" type="number" from="dojo/keys"/></properties><methods/><summary>&lt;p>Definitions for common key values.  Client code should test keyCode against these named constants,
as the actual codes can vary by browser.&lt;/p>
</summary></object><object location="dojo/NodeList-dom" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters/><return-types/><summary>&lt;p>Adds DOM related methods to NodeList, and returns NodeList constructor.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds DOM related methods to NodeList, and returns NodeList constructor.&lt;/p>
</summary></object><object location="dojo/dom-class" type="object"><properties/><methods><method name="contains" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to check the class for.&lt;/p>
</summary></parameter><parameter name="classStr" type="String" usage="required"><summary>&lt;p>A string class name to look for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Returns whether or not the specified classes are a portion of the
class list currently applied to the node.&lt;/p>
</summary><examples><example>&lt;p>Do something if a node with id=&amp;quot;someNode&amp;quot; has class=&amp;quot;aSillyClassName&amp;quot; present&lt;/p>
&lt;pre>&lt;code>  if(dojo.hasClass(&amp;quot;someNode&amp;quot;,&amp;quot;aSillyClassName&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="add" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to add a class string too
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds the specified classes to the end of the class list on the
passed node. Will not re-apply duplicate classes.
&lt;/p>
</summary><examples><example>&lt;p>Add a class to some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;anewClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple additions&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).addClass(&amp;quot;firstLevel&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="remove" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="optional"><summary>&lt;p>An optional String class name to remove, or several space-separated
class names, or an array of class names. If omitted, all class names
will be deleted.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes the specified classes from node. No &lt;code>contains()&lt;/code>
check is required.
&lt;/p>
</summary><examples><example>&lt;p>Remove a class from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove all classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple removal&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).removeClass(&amp;quot;foo&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="replace" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="addClassStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="removeClassStr" type="String|Array" usage="optional"><summary>&lt;p>A String class name to remove, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Replaces one or more classes on a node if not present.
Operates more quickly than calling dojo.removeClass and dojo.addClass
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;add1 add2&amp;quot;, &amp;quot;remove1 remove2&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Replace all classes with addMe&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;addMe&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.findMe&amp;quot;).replaceClass(&amp;quot;addMe&amp;quot;, &amp;quot;removeMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toggle" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to toggle a class string
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to toggle, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="condition" type="Boolean" usage="optional"><summary>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</return-description><summary>&lt;p>Adds a class to node if not present, or removes if present.
Pass a boolean condition if you want to explicitly add or remove.
Returns the condition that was specified directly or indirectly.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Forcefully add a class&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;, true);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.toggleMe&amp;quot;).toggleClass(&amp;quot;toggleMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module defines the core dojo DOM class API.&lt;/p>
</summary></object><object location="dojo/NodeList-fx" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters/><return-types/><summary>&lt;p>Adds dojo.fx animation support to dojo.query() by extending the NodeList class
with additional FX functions.  NodeList is the array-like object used to hold query results.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds dojo.fx animation support to dojo.query() by extending the NodeList class
with additional FX functions.  NodeList is the array-like object used to hold query results.&lt;/p>
</summary></object><object location="dojo/_base/fx" type="object"><properties/><methods><method name="_Line" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="start" type="int" usage="required"><summary>&lt;p>Beginning value for range&lt;/p>
</summary></parameter><parameter name="end" type="int" usage="required"><summary>&lt;p>Ending value for range&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Object used to generate values from a start value to an end value&lt;/p>
</summary></method><method name="Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="_fade" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns an animation that will fade the node defined by
args.node from the start to end values passed (args.start
args.end) (end is mandatory, start is optional)&lt;/p>
</summary></method><method name="fadeIn" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to show the node&lt;/p>
</summary></method><method name="fadeOut" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to hide the node&lt;/p>
</summary></method><method name="_defaultEasing" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types/><summary>&lt;p>The default easing function for Animation(s)&lt;/p>
</summary></method><method name="animateProperty" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>properties (Object, optional): &lt;p>A hash map of style properties to Objects describing the transition,
such as the properties of _Line with an additional &amp;#39;units&amp;#39; property&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns an animation that will transition the properties of
node defined in &lt;code>args&lt;/code> depending how they are defined in
&lt;code>args.properties&lt;/code>
&lt;/p>
</summary><description>&lt;p>Foundation of most &lt;code>dojo/_base/fx&lt;/code>
animations. It takes an object of &amp;quot;properties&amp;quot; corresponding to
style properties, and animates them in parallel over a set
duration.
&lt;/p>
</description><examples><example>&lt;p>A simple animation that changes the width of the specified node.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    properties: { width: 400 },
  }).play();&lt;/code>&lt;/pre>
&lt;p>Dojo figures out the start value for the width and converts the
integer specified for the width to the more expressive but
verbose form &lt;code>{ width: { end: &amp;#39;400&amp;#39;, units: &amp;#39;px&amp;#39; } }&lt;/code> which you
can also specify directly. Defaults to &amp;#39;px&amp;#39; if omitted.
&lt;/p>
</example><example>&lt;p>Animate width, height, and padding over 2 seconds... the
pedantic way:&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({ node: node, duration:2000,
    properties: {
      width: { start: &amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      height: { start:&amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      paddingTop: { start:&amp;#39;5&amp;#39;, end:&amp;#39;50&amp;#39;, units:&amp;quot;px&amp;quot; }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>Note &amp;#39;paddingTop&amp;#39; is used over &amp;#39;padding-top&amp;#39;. Multi-name CSS properties
are written using &amp;quot;mixed case&amp;quot;, as the hyphen is illegal as an object key.
&lt;/p>
</example><example>&lt;p>Plug in a different easing function and register a callback for
when the animation ends. Easing functions accept values between
zero and one and return a value on that basis. In this case, an
exponential-in curve.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    // dojo figures out the start value
    properties: { width: { end: 400 } },
    easing: function(n){
      return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
    },
    onEnd: function(node){
      // called when the animation finishes. The animation
      // target is passed to this function
    }
  }).play(500); // delay playing half a second&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Like all &lt;code>Animation&lt;/code>s, animateProperty returns a handle to the
Animation instance, which fires the events common to Dojo FX. Use &lt;code>aspect.after&lt;/code>
to access these events outside of the Animation definition:&lt;/p>
&lt;pre>&lt;code>  var anim = basefx.animateProperty({
    node:&amp;quot;someId&amp;quot;,
    properties:{
      width:400, height:500
    }
  });
  aspect.after(anim, &amp;quot;onEnd&amp;quot;, function(){
    console.log(&amp;quot;animation ended&amp;quot;);
  }, true);
  // play the animation now:
  anim.play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Each property can be a function whose return value is substituted along.
Additionally, each measurement (eg: start, end) can be a function. The node
reference is passed directly to callbacks.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node:&amp;quot;mine&amp;quot;,
    properties:{
      height:function(node){
        // shrink this node by 50%
        return domGeom.position(node).h / 2
      },
      width:{
        start:function(node){ return 100; },
        end:function(node){ return 200; }
      }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="anim" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>a DOM node or the id of a node to animate CSS properties on&lt;/p>
</summary></parameter><parameter name="properties" type="Object" usage="required"/><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds over which the animation
should run. Defaults to the global animation default duration
(350ms).&lt;/p>
</summary></parameter><parameter name="easing" type="Function" usage="optional"><summary>&lt;p>An easing function over which to calculate acceleration
and deceleration of the animation through its duration.
A default easing algorithm is provided, but you may
plug in any you wish. A large selection of easing algorithms
are available in &lt;code>dojo/fx/easing&lt;/code>.&lt;/p>
</summary></parameter><parameter name="onEnd" type="Function" usage="optional"><summary>&lt;p>A function to be called when the animation finishes
running.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds to delay beginning the
animation by. The default is 0.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A simpler interface to &lt;code>animateProperty()&lt;/code>, also returns
an instance of &lt;code>Animation&lt;/code> but begins the animation
immediately, unlike nearly every other Dojo animation API.&lt;/p>
</summary><description>&lt;p>Simpler (but somewhat less powerful) version
of &lt;code>animateProperty&lt;/code>.  It uses defaults for many basic properties
and allows for positional parameters to be used in place of the
packed &amp;quot;property bag&amp;quot; which is used for other Dojo animation
methods.

&lt;/p>
&lt;p>The &lt;code>Animation&lt;/code> object returned will be already playing, so
calling play() on it again is (usually) a no-op.&lt;/p>
</description><examples><example>&lt;p>Fade out a node&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 });&lt;/code>&lt;/pre>
</example><example>&lt;p>Fade out a node over a full second&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 }, 1000);&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module defines the base dojo/_base/fx implementation.&lt;/p>
</summary></object><object location="dojo/_base/declare" type="function"><properties><property name="__DeclareCreatedObject" scope="normal" type="object" from="dojo/_base/declare"><summary>&lt;p>dojo/_base/declare() returns a constructor &lt;code>C&lt;/code>.   &lt;code>new C()&lt;/code> returns an Object with the following
methods, in addition to the methods and properties specified via the arguments passed to declare().&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/_base/declare"><parameters><parameter name="className" type="String" usage="optional"><summary>&lt;p>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
It will be used as a global name for a created constructor.&lt;/p>
</summary></parameter><parameter name="superclass" type="Function|Function[]" usage="required"><summary>&lt;p>May be null, a Function, or an Array of Functions. This argument
specifies a list of bases (the left-most one is the most deepest
base).&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>An object whose properties are copied to the created prototype.
Add an instance-initialization function by making it a property
named &amp;quot;constructor&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/declare.__DeclareCreatedObject"/><return-type type="undefined"/></return-types><return-description>New constructor function.</return-description><summary>&lt;p>Create a feature-rich constructor from compact notation.&lt;/p>
</summary><description>&lt;p>Create a constructor using a compact notation for inheritance and
prototype extension.

&lt;/p>
&lt;p>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

&lt;/p>
&lt;p>Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see &lt;a href=&quot;http://www.python.org/download/releases/2.3/mro/&quot;>http://www.python.org/download/releases/2.3/mro/&lt;/a> for more
details).

&lt;/p>
&lt;p>&amp;quot;className&amp;quot; is cached in &amp;quot;declaredClass&amp;quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&amp;quot;superclass&amp;quot; property of the new class.

&lt;/p>
&lt;p>Methods in &amp;quot;props&amp;quot; will be copied and modified: &amp;quot;nom&amp;quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

&lt;/p>
&lt;p>It is possible to use constructors created &amp;quot;manually&amp;quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &amp;quot;this.inherited()&amp;quot;.

&lt;/p>
&lt;p>Special property &amp;quot;-chains-&amp;quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &amp;quot;after&amp;quot;, this method will be
called after methods of its base classes. If a hint string is
&amp;quot;before&amp;quot;, this method will be called before methods of its base
classes.

&lt;/p>
&lt;p>If &amp;quot;constructor&amp;quot; is not mentioned in &amp;quot;-chains-&amp;quot; property, it will
be chained using the legacy mode: using &amp;quot;after&amp;quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &amp;quot;after&amp;quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&amp;quot;constructor&amp;quot; cannot be chained &amp;quot;before&amp;quot;, but it allows
a special hint string: &amp;quot;manual&amp;quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

&lt;/p>
&lt;p>All chaining hints are &amp;quot;inherited&amp;quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

&lt;/p>
&lt;p>Once a method was chained, it is impossible to unchain it. The
only exception is &amp;quot;constructor&amp;quot;. You don&amp;#39;t need to define a
method in order to supply a chaining hint.

&lt;/p>
&lt;p>If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

&lt;/p>
&lt;p>Usually constructors and initializers of any kind are chained
using &amp;quot;after&amp;quot; and destructors of any kind are chained as
&amp;quot;before&amp;quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  declare(&amp;quot;my.classes.bar&amp;quot;, my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
      this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
      doStuff();
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var F = function(){ console.log(&amp;quot;raw constructor&amp;quot;); };
  F.prototype.method = function(){
    console.log(&amp;quot;raw method&amp;quot;);
  };
  var A = declare(F, {
    constructor: function(){
      console.log(&amp;quot;A.constructor&amp;quot;);
    },
    method: function(){
      console.log(&amp;quot;before calling F.method...&amp;quot;);
      this.inherited(arguments);
      console.log(&amp;quot;...back in A&amp;quot;);
    }
  });
  new A().method();
  // will print:
  // raw constructor
  // A.constructor
  // before calling F.method...
  // raw method
  // ...back in A&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      destroy: &amp;quot;before&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      console.log(&amp;quot;B.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;B.destroy&amp;quot;);
    }
  });
  var C = declare(B, {
    constructor: function(){
      console.log(&amp;quot;C.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;C.destroy&amp;quot;);
    }
  });
  new C().destroy();
  // prints:
  // B.constructor
  // C.constructor
  // C.destroy
  // B.destroy&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      constructor: &amp;quot;manual&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      // ...
      // call the base constructor with new parameters
      this.inherited(arguments, [1, 2, 3]);
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      m1: &amp;quot;before&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    &amp;quot;-chains-&amp;quot;: {
      m2: &amp;quot;after&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;B.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  x.m1();
  // prints:
  // B.m1
  // A.m1
  x.m2();
  // prints:
  // A.m2
  // B.m2&lt;/code>&lt;/pre>
</example></examples></method><method name="safeMixin" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>Target object to accept new properties.&lt;/p>
</summary></parameter><parameter name="source" type="Object" usage="required"><summary>&lt;p>Source object for new properties.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Target object to accept new properties.&lt;/p>
</return-description><summary>&lt;p>Mix in properties skipping a constructor and decorating functions
like it is done by declare().&lt;/p>
</summary><description>&lt;p>This function is used to mix in properties like lang.mixin does,
but it skips a constructor property and decorates functions like
declare() does.

&lt;/p>
&lt;p>It is meant to be used with classes and objects produced with
declare. Functions mixed in with dojo.safeMixin can use
this.inherited() like normal methods.

&lt;/p>
&lt;p>This function is used to implement extend() method of a constructor
produced with declare().
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var A = declare(null, {
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m1&amp;quot;);
    }
  });
  B.extend({
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  dojo.safeMixin(x, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m1&amp;quot;);
    },
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m2&amp;quot;);
    }
  });
  x.m2();
  // prints:
  // A.m1
  // B.m1
  // X.m1&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="className" type="String" usage="optional"><summary>&lt;p>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
It will be used as a global name for a created constructor.&lt;/p>
</summary></parameter><parameter name="superclass" type="Function|Function[]" usage="required"><summary>&lt;p>May be null, a Function, or an Array of Functions. This argument
specifies a list of bases (the left-most one is the most deepest
base).&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>An object whose properties are copied to the created prototype.
Add an instance-initialization function by making it a property
named &amp;quot;constructor&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/declare.__DeclareCreatedObject"/><return-type type="undefined"/></return-types><return-description>New constructor function.</return-description><summary>&lt;p>Create a feature-rich constructor from compact notation.&lt;/p>
</summary><description>&lt;p>Create a constructor using a compact notation for inheritance and
prototype extension.

&lt;/p>
&lt;p>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

&lt;/p>
&lt;p>Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see &lt;a href=&quot;http://www.python.org/download/releases/2.3/mro/&quot;>http://www.python.org/download/releases/2.3/mro/&lt;/a> for more
details).

&lt;/p>
&lt;p>&amp;quot;className&amp;quot; is cached in &amp;quot;declaredClass&amp;quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&amp;quot;superclass&amp;quot; property of the new class.

&lt;/p>
&lt;p>Methods in &amp;quot;props&amp;quot; will be copied and modified: &amp;quot;nom&amp;quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

&lt;/p>
&lt;p>It is possible to use constructors created &amp;quot;manually&amp;quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &amp;quot;this.inherited()&amp;quot;.

&lt;/p>
&lt;p>Special property &amp;quot;-chains-&amp;quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &amp;quot;after&amp;quot;, this method will be
called after methods of its base classes. If a hint string is
&amp;quot;before&amp;quot;, this method will be called before methods of its base
classes.

&lt;/p>
&lt;p>If &amp;quot;constructor&amp;quot; is not mentioned in &amp;quot;-chains-&amp;quot; property, it will
be chained using the legacy mode: using &amp;quot;after&amp;quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &amp;quot;after&amp;quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&amp;quot;constructor&amp;quot; cannot be chained &amp;quot;before&amp;quot;, but it allows
a special hint string: &amp;quot;manual&amp;quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

&lt;/p>
&lt;p>All chaining hints are &amp;quot;inherited&amp;quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

&lt;/p>
&lt;p>Once a method was chained, it is impossible to unchain it. The
only exception is &amp;quot;constructor&amp;quot;. You don&amp;#39;t need to define a
method in order to supply a chaining hint.

&lt;/p>
&lt;p>If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

&lt;/p>
&lt;p>Usually constructors and initializers of any kind are chained
using &amp;quot;after&amp;quot; and destructors of any kind are chained as
&amp;quot;before&amp;quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  declare(&amp;quot;my.classes.bar&amp;quot;, my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
      this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
      doStuff();
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var F = function(){ console.log(&amp;quot;raw constructor&amp;quot;); };
  F.prototype.method = function(){
    console.log(&amp;quot;raw method&amp;quot;);
  };
  var A = declare(F, {
    constructor: function(){
      console.log(&amp;quot;A.constructor&amp;quot;);
    },
    method: function(){
      console.log(&amp;quot;before calling F.method...&amp;quot;);
      this.inherited(arguments);
      console.log(&amp;quot;...back in A&amp;quot;);
    }
  });
  new A().method();
  // will print:
  // raw constructor
  // A.constructor
  // before calling F.method...
  // raw method
  // ...back in A&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      destroy: &amp;quot;before&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      console.log(&amp;quot;B.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;B.destroy&amp;quot;);
    }
  });
  var C = declare(B, {
    constructor: function(){
      console.log(&amp;quot;C.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;C.destroy&amp;quot;);
    }
  });
  new C().destroy();
  // prints:
  // B.constructor
  // C.constructor
  // C.destroy
  // B.destroy&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      constructor: &amp;quot;manual&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      // ...
      // call the base constructor with new parameters
      this.inherited(arguments, [1, 2, 3]);
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      m1: &amp;quot;before&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    &amp;quot;-chains-&amp;quot;: {
      m2: &amp;quot;after&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;B.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  x.m1();
  // prints:
  // B.m1
  // A.m1
  x.m2();
  // prints:
  // A.m2
  // B.m2&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/_base/Color" type="function"><properties><property name="r" scope="prototype" type="number" from="dojo/_base/Color"/><property name="g" scope="prototype" type="number" from="dojo/_base/Color"/><property name="b" scope="prototype" type="number" from="dojo/_base/Color"/><property name="a" scope="prototype" type="number" from="dojo/_base/Color"/><property name="named" scope="normal" type="object" from="dojo/_base/Color"><summary>&lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types/><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and creates a new Color instance to work from.
&lt;/p>
</summary><examples><example>&lt;p>Work with a Color instance:&lt;/p>
&lt;pre>&lt;code> var c = new Color();
 c.setColor([0,0,0]); // black
 var hex = c.toHex(); // #000000&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Work with a node&amp;#39;s color:&lt;/p>
&lt;pre>&lt;code> var color = dojo.style(&amp;quot;someNode&amp;quot;, &amp;quot;backgroundColor&amp;quot;);
 var n = new Color(color);
 // adjust the color some
 n.r *= .5;
 console.log(n.toString()); // rgb(128, 255, 255);&lt;/code>&lt;/pre>
</example></examples></method><method name="_set" scope="prototype" type="function" from="dojo/_base/Color"><parameters><parameter name="r" type="undefined" usage="required"/><parameter name="g" type="undefined" usage="required"/><parameter name="b" type="undefined" usage="required"/><parameter name="a" type="undefined" usage="required"/></parameters><return-types/></method><method name="setColor" scope="prototype" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>
</return-description><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var c = new Color(); // no color
  c.setColor(&amp;quot;#ededed&amp;quot;); // greyish&lt;/code>&lt;/pre>
</example></examples></method><method name="sanitize" scope="prototype" type="function" from="dojo/colors"><parameters/><return-types/><summary>&lt;p>makes sure that the object has correct attributes&lt;/p>
</summary></method><method name="toRgb" scope="prototype" type="function" from="dojo/_base/Color"><parameters/><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns 3 component array of rgb values&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var c = new Color(&amp;quot;#000000&amp;quot;);
  console.log(c.toRgb()); // [0,0,0]&lt;/code>&lt;/pre>
</example></examples></method><method name="toRgba" scope="prototype" type="function" from="dojo/_base/Color"><parameters/><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>
</summary></method><method name="toHex" scope="prototype" type="function" from="dojo/_base/Color"><parameters/><return-types><return-type type="string"/></return-types><summary>&lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  console.log(new Color([0,0,0]).toHex()); // #000000&lt;/code>&lt;/pre>
</example></examples></method><method name="toCss" scope="prototype" type="function" from="dojo/_base/Color"><parameters><parameter name="includeAlpha" type="Boolean" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>Returns a css color string in rgb(a) representation&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var c = new Color(&amp;quot;#FFF&amp;quot;).toCss();
  console.log(c); // rgb(&amp;#39;255&amp;#39;,&amp;#39;255&amp;#39;,&amp;#39;255&amp;#39;)&lt;/code>&lt;/pre>
</example></examples></method><method name="toString" scope="prototype" type="function" from="dojo/_base/Color"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns a visual representation of the color&lt;/p>
</summary></method><method name="blendColors" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="start" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="end" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="weight" type="Number" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>
</summary></method><method name="fromRgb" scope="normal" type="function" from="dojo/colors"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="dojo/_base/Color" usage="optional"/></parameters><return-types/><summary>&lt;p>get rgb(a) array from css-style color declarations&lt;/p>
</summary><description>&lt;p>this function can handle all 4 CSS3 Color Module formats: rgb,
rgba, hsl, hsla, including rgb(a) with percentage values.&lt;/p>
</description></method><method name="fromHex" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.
</return-description><summary>&lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#ededed&amp;quot;); // grey, longhand&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#000&amp;quot;); // black, shorthand&lt;/code>&lt;/pre>
</example></examples></method><method name="fromArray" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="a" type="Array" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha&lt;/code>&lt;/pre>
</example></examples></method><method name="fromString" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="str" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromArray: &lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Parses &lt;code>str&lt;/code> for a color value. Accepts hex, rgb, and rgba
style color values.&lt;/p>
</summary><description>&lt;p>Acceptable input values for str may include arrays of any form
accepted by dojo.colorFromArray, hex strings such as &amp;quot;#aaaaaa&amp;quot;, or
rgb or rgba strings such as &amp;quot;rgb(133, 200, 16)&amp;quot; or &amp;quot;rgba(10, 10,
10, 50)&amp;quot;&lt;/p>
</description></method><method name="makeGrey" scope="normal" type="function" from="dojo/colors"><parameters><parameter name="g" type="Number" usage="required"/><parameter name="a" type="Number" usage="optional"/></parameters><return-types/><summary>&lt;p>creates a greyscale color with an optional alpha&lt;/p>
</summary></method></methods><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types/><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and creates a new Color instance to work from.
&lt;/p>
</summary><examples><example>&lt;p>Work with a Color instance:&lt;/p>
&lt;pre>&lt;code> var c = new Color();
 c.setColor([0,0,0]); // black
 var hex = c.toHex(); // #000000&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Work with a node&amp;#39;s color:&lt;/p>
&lt;pre>&lt;code> var color = dojo.style(&amp;quot;someNode&amp;quot;, &amp;quot;backgroundColor&amp;quot;);
 var n = new Color(color);
 // adjust the color some
 n.r *= .5;
 console.log(n.toString()); // rgb(128, 255, 255);&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/fx" type="object"><properties><property name="easing" scope="normal" type="object" from="dojo/fx/easing"><summary>&lt;p>Collection of easing functions to use beyond the default
&lt;code>dojo._defaultEasing&lt;/code> function.&lt;/p>
</summary><description>&lt;p>Easing functions are used to manipulate the iteration through
an &lt;code>dojo.Animation&lt;/code>s _Line. _Line being the properties of an Animation,
and the easing function progresses through that Line determining
how quickly (or slowly) it should go. Or more accurately: modify
the value of the _Line based on the percentage of animation completed.

&lt;/p>
&lt;p>All functions follow a simple naming convention of &amp;quot;ease type&amp;quot; + &amp;quot;when&amp;quot;.
If the name of the function ends in Out, the easing described appears
towards the end of the animation. &amp;quot;In&amp;quot; means during the beginning,
and InOut means both ranges of the Animation will applied, both
beginning and end.

&lt;/p>
&lt;p>One does not call the easing function directly, it must be passed to
the &lt;code>easing&lt;/code> property of an animation.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.require(&amp;quot;dojo.fx.easing&amp;quot;);
  var anim = dojo.fadeOut({
    node: &amp;#39;node&amp;#39;,
    duration: 2000,
    //  note there is no ()
    easing: dojo.fx.easing.quadIn
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></property></properties><methods><method name="chain" scope="normal" type="function" from="dojo/fx"><parameters><parameter name="animations" type="dojo/_base/fx.Animation[]" usage="required"/></parameters><return-types/><summary>&lt;p>Chain a list of &lt;code>dojo.Animation&lt;/code>s to run in sequence
&lt;/p>
</summary><description>&lt;p>Return a &lt;code>dojo.Animation&lt;/code> which will play all passed
&lt;code>dojo.Animation&lt;/code> instances in sequence, firing its own
synthesized events simulating a single animation. (eg:
onEnd of this animation means the end of the chain,
not the individual animations within)
&lt;/p>
</description><examples><example>&lt;p>Once &lt;code>node&lt;/code> is faded out, fade in &lt;code>otherNode&lt;/code>&lt;/p>
&lt;pre>&lt;code>  fx.chain([
    dojo.fadeIn({ node:node }),
    dojo.fadeOut({ node:otherNode })
  ]).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="combine" scope="normal" type="function" from="dojo/fx"><parameters><parameter name="animations" type="dojo/_base/fx.Animation[]" usage="required"/></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Combine a list of &lt;code>dojo.Animation&lt;/code>s to run in parallel
&lt;/p>
</summary><description>&lt;p>Combine an array of &lt;code>dojo.Animation&lt;/code>s to run in parallel,
providing a new &lt;code>dojo.Animation&lt;/code> instance encompasing each
animation, firing standard animation events.
&lt;/p>
</description><examples><example>&lt;p>Fade out &lt;code>node&lt;/code> while fading in &lt;code>otherNode&lt;/code> simultaneously&lt;/p>
&lt;pre>&lt;code>  fx.combine([
    dojo.fadeIn({ node:node }),
    dojo.fadeOut({ node:otherNode })
  ]).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the longest animation ends, execute a function:&lt;/p>
&lt;pre>&lt;code>  var anim = fx.combine([
    dojo.fadeIn({ node: n, duration:700 }),
    dojo.fadeOut({ node: otherNode, duration: 300 })
  ]);
  dojo.connect(anim, &amp;quot;onEnd&amp;quot;, function(){
    // overall animation is done.
  });
  anim.play(); // play the animation&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="wipeIn" scope="normal" type="function" from="dojo/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>A hash-map of standard &lt;code>dojo.Animation&lt;/code> constructor properties
(such as easing: node: duration: and so on)
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Expand a node to it&amp;#39;s natural height.
&lt;/p>
</summary><description>&lt;p>Returns an animation that will expand the
node defined in &amp;#39;args&amp;#39; object from it&amp;#39;s current height to
it&amp;#39;s natural height (with no scrollbar).
Node must have no margin/border/padding.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  fx.wipeIn({
    node:&amp;quot;someId&amp;quot;
  }).play()&lt;/code>&lt;/pre>
</example></examples></method><method name="wipeOut" scope="normal" type="function" from="dojo/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>A hash-map of standard &lt;code>dojo.Animation&lt;/code> constructor properties
(such as easing: node: duration: and so on)
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Shrink a node to nothing and hide it.
&lt;/p>
</summary><description>&lt;p>Returns an animation that will shrink node defined in &amp;quot;args&amp;quot;
from it&amp;#39;s current height to 1px, and then hide it.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  fx.wipeOut({ node:&amp;quot;someId&amp;quot; }).play()&lt;/code>&lt;/pre>
</example></examples></method><method name="slideTo" scope="normal" type="function" from="dojo/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>A hash-map of standard &lt;code>dojo.Animation&lt;/code> constructor properties
(such as easing: node: duration: and so on). Special args members
are &lt;code>top&lt;/code> and &lt;code>left&lt;/code>, which indicate the new position to slide to.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Slide a node to a new top/left position
&lt;/p>
</summary><description>&lt;p>Returns an animation that will slide &amp;quot;node&amp;quot;
defined in args Object from its current position to
the position defined by (args.left, args.top).
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  .slideTo({ node: node, left:&amp;quot;40&amp;quot;, top:&amp;quot;50&amp;quot;, units:&amp;quot;px&amp;quot; }).play()&lt;/code>&lt;/pre>
</example></examples></method><method name="Toggler" scope="normal" type="constructor" from="dojo/fx/Toggler"><parameters/><return-types/></method></methods><summary>&lt;p>Effects library on top of Base animations&lt;/p>
</summary></object><object location="dojo/ready" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/NodeList-html" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-html"><parameters/><return-types/><summary>&lt;p>Adds a chainable html method to dojo.query() / NodeList instances for setting/replacing node content&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds a chainable html method to dojo.query() / NodeList instances for setting/replacing node content&lt;/p>
</summary></object><object location="dojo/html" type="object"><properties/><methods><method name="_secureForInnerHtml" scope="normal" type="function" from="dojo/html"><parameters><parameter name="cont" type="String" usage="required"><summary>&lt;p>An html string for insertion into the dom
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>removes !DOCTYPE and title elements from the html string.

&lt;/p>
&lt;p>khtml is picky about dom faults, you can&amp;#39;t attach a style or &lt;code>&amp;lt;title&amp;gt;&lt;/code> node as child of body
must go into head, so we need to cut out those tags&lt;/p>
</summary></method><method name="_emptyNode" scope="normal" type="function" from="dojo/html"><parameters><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>the parent element&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes all child nodes from the given node.   Deprecated, should use dojo/dom-constuct.empty() directly
instead.&lt;/p>
</summary></method><method name="_setNodeContent" scope="normal" type="function" from="dojo/html"><parameters><parameter name="node" type="DomNode" usage="required"><summary>&lt;p>the parent element&lt;/p>
</summary></parameter><parameter name="cont" type="String|DomNode|NodeList" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>inserts the given content into the given node&lt;/p>
</summary></method><method name="_ContentSetter" scope="normal" type="constructor" from="dojo/html"><parameters/><return-types/></method><method name="set" scope="normal" type="function" from="dojo/html"><parameters><parameter name="node" type="DomNode" usage="required"><summary>&lt;p>the parent element that will receive the content&lt;/p>
</summary></parameter><parameter name="cont" type="String|DomNode|NodeList" usage="required"><summary>&lt;p>the content to be set on the parent element.
This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="optional"><summary>&lt;p>Optional flags/properties to configure the content-setting. See dojo/html/_ContentSetter&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>inserts (replaces) the given content into the given node. dojo.place(cont, node, &amp;quot;only&amp;quot;)
may be a better choice for simple HTML insertion.&lt;/p>
</summary><description>&lt;p>Unless you need to use the params capabilities of this method, you should use
dojo.place(cont, node, &amp;quot;only&amp;quot;). dojo.place() has more robust support for injecting
an HTML string into the DOM, but it only handles inserting an HTML string as DOM
elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
or the other capabilities as defined by the params object for this method.&lt;/p>
</description><examples><example>&lt;p>A safe string/node/nodelist content replacement/injection with hooks for extension
Example Usage:&lt;/p>
&lt;pre>&lt;code>  html.set(node, &amp;quot;some string&amp;quot;);
  html.set(node, contentNode, {options});
  html.set(node, myNode.childNodes, {options});&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/parser" type="object"><properties/><methods><method name="_clearCache" scope="normal" type="function" from="dojo/parser"><parameters/><return-types/><summary>&lt;p>Clear cached data.   Used mainly for benchmarking.&lt;/p>
</summary></method><method name="_functionFromScript" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="script" type="DOMNode" usage="required"><summary>&lt;p>The &lt;code>&amp;lt;script&amp;gt;&lt;/code> DOMNode&lt;/p>
</summary></parameter><parameter name="attrData" type="String" usage="required"><summary>&lt;p>For HTML5 compliance, searches for attrData + &amp;quot;args&amp;quot; (typically
&amp;quot;data-dojo-args&amp;quot;) instead of &amp;quot;args&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Convert a &lt;code>&amp;lt;script type=&amp;quot;dojo/method&amp;quot; args=&amp;quot;a, b, c&amp;quot;&amp;gt; ... &amp;lt;/script&amp;gt;&lt;/code>
into a function&lt;/p>
</summary></method><method name="instantiate" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>Array of DOM nodes&lt;/p>
</summary></parameter><parameter name="mixin" type="Object" usage="optional"><summary>&lt;p>An object that will be mixed in with each node in the array.
Values in the mixin will override values in the node, if they
exist.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>An object used to hold kwArgs for instantiation.
See parse.options argument for details.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Takes array of nodes, and turns them into class instances and
potentially calls a startup method to allow them to connect with
any children.&lt;/p>
</summary></method><method name="_instantiate" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>Array of objects like&lt;/p>
&lt;pre>&lt;code>    {
      ctor: Function (may be null)
      types: [&amp;quot;dijit/form/Button&amp;quot;, &amp;quot;acme/MyMixin&amp;quot;] (used if ctor not specified)
      node: DOMNode,
      scripts: [ ... ],  // array of &amp;lt;script type=&amp;quot;dojo/...&amp;quot;&amp;gt; children of node
      inherited: { ... }  // settings inherited from ancestors like dir, theme, etc.
    }&lt;/code>&lt;/pre>
</summary></parameter><parameter name="mixin" type="Object" usage="required"><summary>&lt;p>An object that will be mixed in with each node in the array.
Values in the mixin will override values in the node, if they
exist.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="required"><summary>&lt;p>An options object used to hold kwArgs for instantiation.
See parse.options argument for details.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Takes array of objects representing nodes, and turns them into class instances and
potentially calls a startup method to allow them to connect with
any children.&lt;/p>
</summary></method><method name="construct" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="ctor" type="Function" usage="required"><summary>&lt;p>Widget constructor.&lt;/p>
</summary></parameter><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.&lt;/p>
</summary></parameter><parameter name="mixin" type="Object" usage="optional"><summary>&lt;p>Attributes in this object will be passed as parameters to ctor,
overriding attributes specified on the node.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>An options object used to hold kwArgs for instantiation.   See parse.options argument for details.&lt;/p>
</summary></parameter><parameter name="scripts" type="DomNode[]" usage="optional"><summary>&lt;p>Array of &lt;code>&amp;lt;script type=&amp;quot;dojo/*&amp;quot;&amp;gt;&lt;/code> DOMNodes.  If not specified, will search for &lt;code>&amp;lt;script&amp;gt;&lt;/code> tags inside node.&lt;/p>
</summary></parameter><parameter name="inherited" type="Object" usage="optional"><summary>&lt;p>Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Calls new ctor(params, node), where params is the hash of parameters specified on the node,
excluding data-dojo-type and data-dojo-mixins.   Does not call startup().   Returns the widget.&lt;/p>
</summary></method><method name="scan" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="root" type="DomNode" usage="optional"><summary>&lt;p>A default starting root node from which to start the parsing. Can be
omitted, defaulting to the entire document. If omitted, the &lt;code>options&lt;/code>
object can be passed in this place. If the &lt;code>options&lt;/code> object has a
&lt;code>rootNode&lt;/code> member, that is used.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="required"><summary>&lt;p>a kwArgs options object, see parse() for details
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Promise"/><return-type type="undefined"/></return-types><return-description>A promise that is resolved with the nodes that have been parsed.</return-description><summary>&lt;p>Scan a DOM tree and return an array of objects representing the DOMNodes
that need to be turned into widgets.&lt;/p>
</summary><description>&lt;p>Search specified node (or document root node) recursively for class instances
and return an array of objects that represent potential widgets to be
instantiated. Searches for either data-dojo-type=&amp;quot;MID&amp;quot; or dojoType=&amp;quot;MID&amp;quot; where
&amp;quot;MID&amp;quot; is a module ID like &amp;quot;dijit/form/Button&amp;quot; or a fully qualified Class name
like &amp;quot;dijit/form/Button&amp;quot;.  If the MID is not currently available, scan will
attempt to require() in the module.

&lt;/p>
&lt;p>See parser.parse() for details of markup.&lt;/p>
</description></method><method name="_require" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="script" type="DOMNode" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Helper for _scanAMD().  Takes a &lt;code>&amp;lt;script type=dojo/require&amp;gt;bar: &amp;quot;acme/bar&amp;quot;, ...&amp;lt;/script&amp;gt;&lt;/code> node,
calls require() to load the specified modules and (asynchronously) assign them to the specified global
variables, and returns a Promise for when that operation completes.

&lt;/p>
&lt;p>In the example above, it is effectively doing a require([&amp;quot;acme/bar&amp;quot;, ...], function(a){ bar = a; }).&lt;/p>
</summary></method><method name="_scanAmd" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="root" type="DomNode" usage="required"><summary>&lt;p>The node to base the scan from.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Scans the DOM for any declarative requires and returns their values.&lt;/p>
</summary><description>&lt;p>Looks for &lt;code>&amp;lt;script type=dojo/require&amp;gt;bar: &amp;quot;acme/bar&amp;quot;, ...&amp;lt;/script&amp;gt;&lt;/code> node, calls require() to load the
specified modules and (asynchronously) assign them to the specified global variables,
and returns a Promise for when those operations complete.&lt;/p>
</description></method><method name="parse" scope="normal" type="function" from="dojo/parser"><parameters><parameter name="rootNode" type="DomNode" usage="optional"><summary>&lt;p>A default starting root node from which to start the parsing. Can be
omitted, defaulting to the entire document. If omitted, the &lt;code>options&lt;/code>
object can be passed in this place. If the &lt;code>options&lt;/code> object has a
&lt;code>rootNode&lt;/code> member, that is used.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>A hash of options.

&lt;/p>
&lt;ul>
&lt;li>noStart: Boolean?:
when set will prevent the parser from calling .startup()
when locating the nodes.&lt;/li>
&lt;li>rootNode: DomNode?:
identical to the function&amp;#39;s &lt;code>rootNode&lt;/code> argument, though
allowed to be passed in via this `options object.&lt;/li>
&lt;li>template: Boolean:
If true, ignores ContentPane&amp;#39;s stopParser flag and parses contents inside of
a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
nested inside the ContentPane to work.&lt;/li>
&lt;li>inherited: Object:
Hash possibly containing dir and lang settings to be applied to
parsed widgets, unless there&amp;#39;s another setting on a sub-node that overrides&lt;/li>
&lt;li>scope: String:
Root for attribute names to search for.   If scopeName is dojo,
will search for data-dojo-type (or dojoType).   For backwards compatibility
reasons defaults to dojo._scopeName (which is &amp;quot;dojo&amp;quot; except when
multi-version support is used, when it will be something like dojo16, dojo20, etc.)&lt;/li>
&lt;li>propsThis: Object:
If specified, &amp;quot;this&amp;quot; referenced from data-dojo-props will refer to propsThis.
Intended for use from the widgets-in-template feature of &lt;code>dijit._WidgetsInTemplateMixin&lt;/code>&lt;/li>
&lt;/ul>
</summary></parameter></parameters><return-types><return-type type="Mixed"/><return-type type="Array"/></return-types><return-description>Returns a blended object that is an array of the instantiated objects, but also can include
a promise that is resolved with the instantiated objects.  This is done for backwards
compatibility.  If the parser auto-requires modules, it will always behave in a promise
fashion and `parser.parse().then(function(instances){...})` should be used.</return-description><summary>&lt;p>Scan the DOM for class instances, and instantiate them.&lt;/p>
</summary><description>&lt;p>Search specified node (or root node) recursively for class instances,
and instantiate them. Searches for either data-dojo-type=&amp;quot;Class&amp;quot; or
dojoType=&amp;quot;Class&amp;quot; where &amp;quot;Class&amp;quot; is a a fully qualified class name,
like &lt;code>dijit/form/Button&lt;/code>

&lt;/p>
&lt;p>Using &lt;code>data-dojo-type&lt;/code>:
Attributes using can be mixed into the parameters used to instantiate the
Class by using a &lt;code>data-dojo-props&lt;/code> attribute on the node being converted.
&lt;code>data-dojo-props&lt;/code> should be a string attribute to be converted from JSON.

&lt;/p>
&lt;p>Using &lt;code>dojoType&lt;/code>:
Attributes are read from the original domNode and converted to appropriate
types by looking up the Class prototype values. This is the default behavior
from Dojo 1.0 to Dojo 1.5. &lt;code>dojoType&lt;/code> support is deprecated, and will
go away in Dojo 2.0.&lt;/p>
</description><examples><example>&lt;p>Parse all widgets on a page:&lt;/p>
&lt;pre>&lt;code>    parser.parse();&lt;/code>&lt;/pre>
</example><example>&lt;p>Parse all classes within the node with id=&amp;quot;foo&amp;quot;&lt;/p>
&lt;pre>&lt;code>    parser.parse(dojo.byId(&amp;#39;foo&amp;#39;));&lt;/code>&lt;/pre>
</example><example>&lt;p>Parse all classes in a page, but do not call .startup() on any
child&lt;/p>
&lt;pre>&lt;code>    parser.parse({ noStart: true })&lt;/code>&lt;/pre>
</example><example>&lt;p>Parse all classes in a node, but do not call .startup()&lt;/p>
&lt;pre>&lt;code>    parser.parse(someNode, { noStart:true });
    // or
    parser.parse({ noStart:true, rootNode: someNode });&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>The Dom/Widget parsing package&lt;/p>
</summary></object><object location="dojo/_base/html" type="object"><properties/><methods/><summary>&lt;p>This module is a stub for the core dojo DOM API.&lt;/p>
</summary></object><object location="dojo/_base/url" type="function"><properties><property name="uri" scope="normal" type="undefined" from="dojo/_base/url"/><property name="scheme" scope="normal" type="object" from="dojo/_base/url"/><property name="authority" scope="normal" type="object" from="dojo/_base/url"/><property name="path" scope="normal" type="undefined" from="dojo/_base/url"/><property name="query" scope="normal" type="object" from="dojo/_base/url"/><property name="fragment" scope="normal" type="object" from="dojo/_base/url"/><property name="user" scope="normal" type="object" from="dojo/_base/url"/><property name="password" scope="normal" type="object" from="dojo/_base/url"/><property name="host" scope="normal" type="undefined" from="dojo/_base/url"/><property name="port" scope="normal" type="object" from="dojo/_base/url"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/_base/url"><parameters/><return-types/></method><method name="toString" scope="prototype" type="function" from="dojo/_base/url"><parameters/><return-types/></method></methods><parameters/><return-types/></object><object location="dojo/_base/json" type="object"><properties/><methods/><summary>&lt;p>This module defines the dojo JSON API.&lt;/p>
</summary></object><object location="dojo/json" type="object"><properties/><methods><method name="parse" scope="normal" type="function" from="dojo/json"><parameters><parameter name="str" type="undefined" usage="required"><summary>&lt;p>a string literal of a JSON item, for instance:
&lt;code>&amp;#39;{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }&amp;#39;&lt;/code>&lt;/p>
</summary></parameter><parameter name="strict" type="undefined" usage="required"><summary>&lt;p>When set to true, this will ensure that only valid, secure JSON is ever parsed.
Make sure this is set to true for untrusted content. Note that on browsers/engines
without native JSON support, setting this to true will run slower.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Parses a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> string to return a JavaScript object.&lt;/p>
</summary><description>&lt;p>This function follows &lt;a href=&quot;https://developer.mozilla.org/en/JSON&quot;>native JSON API&lt;/a>
Throws for invalid JSON strings. This delegates to eval() if native JSON
support is not available. By default this will evaluate any valid JS expression.
With the strict parameter set to true, the parser will ensure that only
valid JSON strings are parsed (otherwise throwing an error). Without the strict
parameter, the content passed to this method must come
from a trusted source.&lt;/p>
</description></method><method name="stringify" scope="normal" type="function" from="dojo/json"><parameters><parameter name="value" type="undefined" usage="required"><summary>&lt;p>A value to be serialized.&lt;/p>
</summary></parameter><parameter name="replacer" type="undefined" usage="required"><summary>&lt;p>A replacer function that is called for each value and can return a replacement&lt;/p>
</summary></parameter><parameter name="spacer" type="undefined" usage="required"><summary>&lt;p>A spacer string to be used for pretty printing of JSON&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
This function follows &lt;a href=&quot;https://developer.mozilla.org/en/JSON&quot;>native JSON API&lt;/a>
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/json&amp;quot;], function(JSON){
    var jsonStr = JSON.stringify({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
    doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>Functions to parse and serialize JSON&lt;/p>
</summary></object><object location="dojo/date/stamp" type="object"><properties><property name="_isoRegExp" scope="normal" type="RegExp" from="dojo/data/ItemFileReadStore"/></properties><methods><method name="fromISOString" scope="normal" type="function" from="dojo/date/stamp"><parameters><parameter name="formattedString" type="String" usage="required"><summary>&lt;p>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00&lt;/p>
</summary></parameter><parameter name="defaultTime" type="Number" usage="optional"><summary>&lt;p>Used for defaults for fields omitted in the formattedString.
Uses 1970-01-01T00:00:00.0Z by default.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
&lt;/p>
</summary><description>&lt;p>Accepts a string formatted according to a profile of ISO8601 as defined by
&lt;a href=&quot;http://www.ietf.org/rfc/rfc3339.txt&quot;>RFC3339&lt;/a>, except that partial input is allowed.
Can also process dates as specified &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;>by the W3C&lt;/a>
The following combinations are valid:

&lt;/p>
&lt;ul>
&lt;li>dates only&lt;/li>
&lt;li>yyyy&lt;/li>
&lt;li>yyyy-MM&lt;/li>
&lt;li>yyyy-MM-dd&lt;/li>
&lt;li>times only, with an optional time zone appended&lt;/li>
&lt;li>THH:mm&lt;/li>
&lt;li>THH:mm:ss&lt;/li>
&lt;li>THH:mm:ss.SSS&lt;/li>
&lt;li>and &amp;quot;datetimes&amp;quot; which could be any combination of the above&lt;/li>
&lt;/ul>
&lt;p>timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
input may return null.  Arguments which are out of bounds will be handled
by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
Only years between 100 and 9999 are supported.&lt;/p>
</description></method><method name="toISOString" scope="normal" type="function" from="dojo/date/stamp"><parameters><parameter name="dateObject" type="Date" usage="required"><summary>&lt;p>A Date object&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; for partial formatting of the Date object.
Both date and time will be formatted by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>zulu (Boolean): &lt;p>if true, UTC/GMT is used for a timezone&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>milliseconds (Boolean): &lt;p>if true, output milliseconds&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Format a Date object as a string according a subset of the ISO-8601 standard
&lt;/p>
</summary><description>&lt;p>When options.selector is omitted, output follows &lt;a href=&quot;http://www.ietf.org/rfc/rfc3339.txt&quot;>RFC3339&lt;/a>
The local time zone is included as an offset from GMT, except when selector==&amp;#39;time&amp;#39; (time without a date)
Does not check bounds.  Only years between 100 and 9999 are supported.
&lt;/p>
</description></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/NodeList-manipulate" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters/><return-types/><summary>&lt;p>Adds chainable methods to dojo.query() / NodeList instances for manipulating HTML
and DOM nodes and their properties.&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds chainable methods to dojo.query() / NodeList instances for manipulating HTML
and DOM nodes and their properties.&lt;/p>
</summary></object><object location="dojo/NodeList-traverse" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types/><summary>&lt;p>Adds chainable methods to dojo.query() / NodeList instances for traversing the DOM&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Adds chainable methods to dojo.query() / NodeList instances for traversing the DOM&lt;/p>
</summary></object><object location="dojo/NodeList" type="function"><properties><property name="events" scope="normal" type="Array" from="dojo/_base/NodeList"/></properties><methods><method name="_wrap" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="a" type="Array" usage="required"><summary>&lt;p>Array of nodes to decorate.&lt;/p>
</summary></parameter><parameter name="parent" type="dojo/NodeList" usage="optional"><summary>&lt;p>An optional parent NodeList that generated the current
list of nodes. Used to call _stash() so the parent NodeList
can be accessed via end() later.&lt;/p>
</summary></parameter><parameter name="NodeListCtor" type="Function" usage="optional"><summary>&lt;p>An optional constructor function to use for any
new NodeList calls. This allows a certain chain of
NodeList calls to use a different object than dojo/NodeList.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>decorate an array to make it look like a &lt;code>dojo/NodeList&lt;/code>.&lt;/p>
</summary></method><method name="constructor" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method><method name="_NodeListCtor" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method><method name="toString" scope="prototype" type="function" from="dojo/query"><parameters/><return-types><return-type type="undefined"/></return-types></method><method name="_stash" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="parent" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>private function to hold to a parent NodeList. end() to return the parent NodeList.
&lt;/p>
</return-description><summary>&lt;p>private function to hold to a parent NodeList. end() to return the parent NodeList.
&lt;/p>
</summary><examples><example>&lt;p>How to make a &lt;code>dojo/NodeList&lt;/code> method that only returns the third node in
the dojo/NodeList but allows access to the original NodeList by using this._stash:&lt;/p>
&lt;pre>&lt;code>  dojo.extend(NodeList, {
    third: function(){
      var newNodeList = NodeList(this[2]);
      return newNodeList._stash(this);
    }
  });
  // then see how _stash applies a sub-list, to be .end()&amp;#39;ed out of
  dojo.query(&amp;quot;.foo&amp;quot;)
    .third()
      .addClass(&amp;quot;thirdFoo&amp;quot;)
    .end()
    // access to the orig .foo list
    .removeClass(&amp;quot;foo&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="on" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="eventName" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Listen for events on the nodes in the NodeList. Basic usage is:&lt;/p>
&lt;pre>&lt;code> query(&amp;quot;.my-class&amp;quot;).on(&amp;quot;click&amp;quot;, listener);&lt;/code>&lt;/pre>
&lt;p>This supports event delegation by using selectors as the first argument with the event names as
pseudo selectors. For example:&lt;/p>
&lt;pre>&lt;code> dojo.query(&amp;quot;#my-list&amp;quot;).on(&amp;quot;li:click&amp;quot;, listener);&lt;/code>&lt;/pre>
&lt;p>This will listen for click events within &lt;code>&amp;lt;li&amp;gt;&lt;/code> elements that are inside the &lt;code>#my-list&lt;/code> element.
Because on supports CSS selector syntax, we can use comma-delimited events as well:&lt;/p>
&lt;pre>&lt;code> dojo.query(&amp;quot;#my-list&amp;quot;).on(&amp;quot;li button:mouseover, li:click&amp;quot;, listener);&lt;/code>&lt;/pre>
</summary></method><method name="end" scope="prototype" type="function" from="dojo/query"><parameters/><return-types><return-type type="undefined"/><return-type type="instance"/></return-types><summary>&lt;p>Ends use of the current &lt;code>NodeList&lt;/code> by returning the previous NodeList
that generated the current NodeList.&lt;/p>
</summary><description>&lt;p>Returns the &lt;code>NodeList&lt;/code> that generated the current &lt;code>NodeList&lt;/code>. If there
is no parent NodeList, an empty NodeList is returned.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.query(&amp;quot;a&amp;quot;)
    .filter(&amp;quot;.disabled&amp;quot;)
      // operate on the anchors that only have a disabled class
      .style(&amp;quot;color&amp;quot;, &amp;quot;grey&amp;quot;)
    .end()
    // jump back to the list of anchors
    .style(...)&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="slice" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="begin" type="Integer" usage="required"><summary>&lt;p>Can be a positive or negative integer, with positive
integers noting the offset to begin at, and negative
integers denoting an offset from the end (i.e., to the left
of the end)&lt;/p>
</summary></parameter><parameter name="end" type="Integer" usage="optional"><summary>&lt;p>Optional parameter to describe what position relative to
the NodeList&amp;#39;s zero index to end the slice at. Like begin,
can be positive or negative.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns a new NodeList, maintaining this one in place&lt;/p>
</summary><description>&lt;p>This method behaves exactly like the Array.slice method
with the caveat that it returns a dojo/NodeList and not a
raw Array. For more details, see Mozilla&amp;#39;s &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice&quot;>slice
documentation&lt;/a>&lt;/p>
</description></method><method name="splice" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>begin can be a positive or negative integer, with positive
integers noting the offset to begin at, and negative
integers denoting an offset from the end (i.e., to the left
of the end)&lt;/p>
</summary></parameter><parameter name="howmany" type="Integer" usage="optional"><summary>&lt;p>Optional parameter to describe what position relative to
the NodeList&amp;#39;s zero index to end the slice at. Like begin,
can be positive or negative.&lt;/p>
</summary></parameter><parameter name="item" type="Object..." usage="optional"><summary>&lt;p>Any number of optional parameters may be passed in to be
spliced into the NodeList&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns a new NodeList, manipulating this NodeList based on
the arguments passed, potentially splicing in new elements
at an offset, optionally deleting elements&lt;/p>
</summary><description>&lt;p>This method behaves exactly like the Array.splice method
with the caveat that it returns a dojo/NodeList and not a
raw Array. For more details, see Mozilla&amp;#39;s &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice&quot;>splice
documentation&lt;/a>
For backwards compatibility, calling .end() on the spliced NodeList
does not return the original NodeList -- splice alters the NodeList in place.&lt;/p>
</description></method><method name="indexOf" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="value" type="Object" usage="required"><summary>&lt;p>The value to search for.&lt;/p>
</summary></parameter><parameter name="fromIndex" type="Integer" usage="optional"><summary>&lt;p>The location to start searching from. Optional. Defaults to 0.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Positive Integer or 0 for a match, -1 of not found.</return-description><summary>&lt;p>see dojo.indexOf(). The primary difference is that the acted-on
array is implicitly this NodeList&lt;/p>
</summary><description>&lt;p>For more details on the behavior of indexOf, see Mozilla&amp;#39;s
&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf&quot;>indexOf
docs&lt;/a>&lt;/p>
</description></method><method name="lastIndexOf" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="value" type="Object" usage="required"><summary>&lt;p>The value to search for.&lt;/p>
</summary></parameter><parameter name="fromIndex" type="Integer" usage="optional"><summary>&lt;p>The location to start searching from. Optional. Defaults to 0.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Positive Integer or 0 for a match, -1 of not found.</return-description><summary>&lt;p>see dojo.lastIndexOf(). The primary difference is that the
acted-on array is implicitly this NodeList&lt;/p>
</summary><description>&lt;p>For more details on the behavior of lastIndexOf, see
Mozilla&amp;#39;s &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf&quot;>lastIndexOf
docs&lt;/a>&lt;/p>
</description></method><method name="every" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="callback" type="Function" usage="required"><summary>&lt;p>the callback&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>the context&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>see &lt;code>dojo.every()&lt;/code> and the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every&quot;>Array.every
docs&lt;/a>.
Takes the same structure of arguments and returns as
dojo.every() with the caveat that the passed array is
implicitly this NodeList&lt;/p>
</summary></method><method name="some" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="callback" type="Function" usage="required"><summary>&lt;p>the callback&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>the context&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Takes the same structure of arguments and returns as
&lt;code>dojo.some()&lt;/code> with the caveat that the passed array is
implicitly this NodeList.  See &lt;code>dojo.some()&lt;/code> and Mozilla&amp;#39;s
&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some&quot;>Array.some
documentation&lt;/a>.&lt;/p>
</summary></method><method name="concat" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="item" type="Object" usage="optional"><summary>&lt;p>Any number of optional parameters may be passed in to be
spliced into the NodeList&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns a new NodeList comprised of items in this NodeList
as well as items passed in as parameters&lt;/p>
</summary><description>&lt;p>This method behaves exactly like the Array.concat method
with the caveat that it returns a &lt;code>NodeList&lt;/code> and not a
raw Array. For more details, see the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat&quot;>Array.concat
docs&lt;/a>&lt;/p>
</description></method><method name="map" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="func" type="Function" usage="required"/><parameter name="obj" type="Function" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>see dojo.map(). The primary difference is that the acted-on
array is implicitly this NodeList and the return is a
NodeList (a subclass of Array)&lt;/p>
</summary></method><method name="forEach" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="callback" type="undefined" usage="required"/><parameter name="thisObj" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>see &lt;code>dojo.forEach()&lt;/code>. The primary difference is that the acted-on
array is implicitly this NodeList. If you want the option to break out
of the forEach loop, use every() or some() instead.&lt;/p>
</return-description><summary>&lt;p>see &lt;code>dojo.forEach()&lt;/code>. The primary difference is that the acted-on
array is implicitly this NodeList. If you want the option to break out
of the forEach loop, use every() or some() instead.&lt;/p>
</summary></method><method name="filter" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="filter" type="String|Function" usage="required"><summary>&lt;p>If a string, a CSS rule like &amp;quot;.thinger&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>&amp;quot;masks&amp;quot; the built-in javascript filter() method (supported
in Dojo via &lt;code>dojo.filter&lt;/code>) to support passing a simple
string filter in addition to supporting filtering function
objects.&lt;/p>
</summary><examples><example>&lt;p>&amp;quot;regular&amp;quot; JS filter syntax as exposed in dojo.filter:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;*&amp;quot;).filter(function(item){
    // highlight every paragraph
    return (item.nodeName == &amp;quot;p&amp;quot;);
  }).style(&amp;quot;backgroundColor&amp;quot;, &amp;quot;yellow&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>the same filtering using a CSS selector&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;*&amp;quot;).filter(&amp;quot;p&amp;quot;).styles(&amp;quot;backgroundColor&amp;quot;, &amp;quot;yellow&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="instantiate" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="declaredClass" type="String|Object" usage="required"/><parameter name="properties" type="Object" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create a new instance of a specified class, using the
specified properties and each node in the NodeList as a
srcNodeRef.&lt;/p>
</summary><examples><example>&lt;p>Grabs all buttons in the page and converts them to dijit/form/Button&amp;#39;s.&lt;/p>
&lt;pre>&lt;code>  var buttons = query(&amp;quot;button&amp;quot;).instantiate(Button, {showLabel: true});&lt;/code>&lt;/pre>
</example></examples></method><method name="at" scope="prototype" type="function" from="dojo/query"><parameters><parameter name="index" type="Integer..." usage="required"><summary>&lt;p>One or more 0-based indices of items in the current
NodeList. A negative index will start at the end of the
list and go backwards.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns a new NodeList comprised of items in this NodeList
at the given index or indices.
&lt;/p>
</summary><examples><example>&lt;p>Shorten the list to the first, second, and third elements&lt;/p>
&lt;pre>&lt;code>  query(&amp;quot;a&amp;quot;).at(0, 1, 2).forEach(fn);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Retrieve the first and last elements of a unordered list:&lt;/p>
&lt;pre>&lt;code>  query(&amp;quot;ul &amp;gt; li&amp;quot;).at(0, -1).forEach(cb);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Do something for the first element only, but end() out back to
the original list and continue chaining:&lt;/p>
&lt;pre>&lt;code>  query(&amp;quot;a&amp;quot;).at(0).onclick(fn).end().forEach(function(n){
    console.log(n); // all anchors on the page.
  })&lt;/code>&lt;/pre>
</example></examples></method><method name="data" scope="prototype" type="function" from="dojo/NodeList-data"><parameters><parameter name="key" type="Object|String" usage="optional"><summary>&lt;p>If an object, act as a setter and iterate over said object setting data items as defined.
If a string, and &lt;code>value&lt;/code> present, set the data for defined &lt;code>key&lt;/code> to &lt;code>value&lt;/code>
If a string, and &lt;code>value&lt;/code> absent, act as a getter, returning the data associated with said &lt;code>key&lt;/code>
&lt;/p>
</summary></parameter><parameter name="value" type="Anything" usage="optional"><summary>&lt;p>The value to set for said &lt;code>key&lt;/code>, provided &lt;code>key&lt;/code> is a string (and not an object)
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object|Anything|Nothing"/></return-types><return-description>When used as a setter via `dojo/NodeList`, a NodeList instance is returned
for further chaining. When used as a getter via `dojo/NodeList` an ARRAY
of items is returned. The items in the array correspond to the elements
in the original list. This is true even when the list length is 1, eg:
when looking up a node by ID (#foo)</return-description><summary>&lt;p>stash or get some arbitrary data on/from these nodes.
&lt;/p>
</summary><description>&lt;p>Stash or get some arbitrary data on/from these nodes. This private _data function is
exposed publicly on &lt;code>dojo/NodeList&lt;/code>, eg: as the result of a &lt;code>dojo.query&lt;/code> call.
DIFFERS from jQuery.data in that when used as a getter, the entire list is ALWAYS
returned. EVEN WHEN THE LIST IS length == 1.

&lt;/p>
&lt;p>A single-node version of this function is provided as &lt;code>dojo._nodeData&lt;/code>, which follows
the same signature, though expects a String ID or DomNode reference in the first
position, before key/value arguments.
&lt;/p>
</description><examples><example>&lt;p>Set a key &lt;code>bar&lt;/code> to some data, then retrieve it.&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo&amp;quot;).data(&amp;quot;bar&amp;quot;, &amp;quot;touched&amp;quot;);
  var touched = dojo.query(&amp;quot;.foo&amp;quot;).data(&amp;quot;bar&amp;quot;);
  if(touched[0] == &amp;quot;touched&amp;quot;){ alert(&amp;#39;win&amp;#39;); }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Get all the data items for a given node.&lt;/p>
&lt;pre>&lt;code>  var list = dojo.query(&amp;quot;.foo&amp;quot;).data();
  var first = list[0];&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set the data to a complex hash. Overwrites existing keys with new value&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo&amp;quot;).data({ bar:&amp;quot;baz&amp;quot;, foo:&amp;quot;bar&amp;quot; });&lt;/code>&lt;/pre>
&lt;p>Then get some random key:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo&amp;quot;).data(&amp;quot;foo&amp;quot;); // returns [`bar`]&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="removeData" scope="prototype" type="function" from="dojo/NodeList-data"><parameters><parameter name="key" type="String" usage="optional"><summary>&lt;p>If omitted, clean all data for this node.
If passed, remove the data item found at &lt;code>key&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove the data associated with these nodes.&lt;/p>
</summary></method><method name="_normalize" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="content" type="String||Element||Object||NodeList" usage="required"/><parameter name="refNode" type="DOMNode" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>normalizes data to an array of items to insert.&lt;/p>
</summary><description>&lt;p>If content is an object, it can have special properties &amp;quot;template&amp;quot; and
&amp;quot;parse&amp;quot;. If &amp;quot;template&amp;quot; is defined, then the template value is run through
dojo.string.substitute (if dojo/string.substitute() has been dojo.required elsewhere),
or if templateFunc is a function on the content, that function will be used to
transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
If content.parse is true, then it is remembered for later, for when the content
nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
(if dojo.parser has been dojo.required elsewhere).&lt;/p>
</description></method><method name="_cloneNode" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="node" type="DOMNode" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>private utility to clone a node. Not very interesting in the vanilla
dojo/NodeList case, but delegates could do interesting things like
clone event handlers if that is derivable from the node.&lt;/p>
</summary></method><method name="_place" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="ary" type="Array" usage="required"/><parameter name="refNode" type="DOMNode" usage="required"/><parameter name="position" type="String" usage="required"/><parameter name="useClone" type="Boolean" usage="required"/></parameters><return-types/><summary>&lt;p>private utility to handle placing an array of nodes relative to another node.&lt;/p>
</summary><description>&lt;p>Allows for cloning the nodes in the array, and for
optionally parsing widgets, if ary._runParse is true.&lt;/p>
</description></method><method name="position" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns border-box objects (x/y/w/h) of all elements in a node list
as an Array (&lt;em>not&lt;/em> a NodeList). Acts like &lt;code>dojo.position&lt;/code>, though
assumes the node passed is each node in this list.&lt;/p>
</summary></method><method name="attr" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="property" type="String" usage="required"><summary>&lt;p>the attribute to get/set&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>optional. The value to set the property to&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>if no value is passed, the result is an array of attribute values
If a value is passed, the return is this NodeList</return-description><summary>&lt;p>gets or sets the DOM attribute for every element in the
NodeList. See also &lt;code>dojo.attr&lt;/code>&lt;/p>
</summary><examples><example>&lt;p>Make all nodes with a particular class focusable:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.focusable&amp;quot;).attr(&amp;quot;tabIndex&amp;quot;, -1);&lt;/code>&lt;/pre>
</example><example>&lt;p>Disable a group of buttons:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;button.group&amp;quot;).attr(&amp;quot;disabled&amp;quot;, true);&lt;/code>&lt;/pre>
</example><example>&lt;p>innerHTML can be assigned or retrieved as well:&lt;/p>
&lt;pre>&lt;code>  // get the innerHTML (as an array) for each list item
  var ih = dojo.query(&amp;quot;li.replaceable&amp;quot;).attr(&amp;quot;innerHTML&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="style" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="property" type="String" usage="required"><summary>&lt;p>the CSS property to get/set, in JavaScript notation
(&amp;quot;lineHieght&amp;quot; instead of &amp;quot;line-height&amp;quot;)&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>optional. The value to set the property to&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>if no value is passed, the result is an array of strings.
If a value is passed, the return is this NodeList</return-description><summary>&lt;p>gets or sets the CSS property for every element in the NodeList&lt;/p>
</summary></method><method name="addClass" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="className" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds the specified class to every node in the list&lt;/p>
</summary></method><method name="removeClass" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="className" type="String|Array" usage="optional"><summary>&lt;p>An optional String class name to remove, or several space-separated
class names, or an array of class names. If omitted, all class names
will be deleted.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>this list</return-description><summary>&lt;p>removes the specified class from every node in the list&lt;/p>
</summary></method><method name="toggleClass" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="className" type="String" usage="required"><summary>&lt;p>the CSS class to add&lt;/p>
</summary></parameter><parameter name="condition" type="Boolean" usage="optional"><summary>&lt;p>If passed, true means to add the class, false means to remove.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds a class to node if not present, or removes if present.
Pass a boolean condition if you want to explicitly add or remove.&lt;/p>
</summary></method><method name="replaceClass" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="addClassStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.&lt;/p>
</summary></parameter><parameter name="removeClassStr" type="String|Array" usage="optional"><summary>&lt;p>A String class name to remove, or several space-separated class names,
or an array of class names.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Replaces one or more classes on a node if not present.
Operates more quickly than calling &lt;code>removeClass()&lt;/code> and &lt;code>addClass()&lt;/code>&lt;/p>
</summary></method><method name="empty" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>clears all content from each node in the list. Effectively
equivalent to removing all child nodes from every item in
the list.&lt;/p>
</summary></method><method name="removeAttr" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to remove&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes an attribute from each node in the list.&lt;/p>
</summary></method><method name="marginBox" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters/><return-types/><summary>&lt;p>Returns margin-box size of nodes&lt;/p>
</summary></method><method name="place" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="queryOrNode" type="String||Node" usage="required"><summary>&lt;p>may be a string representing any valid CSS3 selector or a DOM node.
In the selector case, only the first matching element will be used
for relative positioning.&lt;/p>
</summary></parameter><parameter name="position" type="String" usage="required"><summary>&lt;p>can be one of:

&lt;/p>
&lt;ul>
&lt;li>&amp;quot;last&amp;quot; (default)&lt;/li>
&lt;li>&amp;quot;first&amp;quot;&lt;/li>
&lt;li>&amp;quot;before&amp;quot;&lt;/li>
&lt;li>&amp;quot;after&amp;quot;&lt;/li>
&lt;li>&amp;quot;only&amp;quot;&lt;/li>
&lt;li>&amp;quot;replace&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>or an offset in the childNodes property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>places elements of this node list relative to the first element matched
by queryOrNode. Returns the original NodeList. See: &lt;code>dojo.place&lt;/code>&lt;/p>
</summary></method><method name="orphan" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="filter" type="String" usage="optional"><summary>&lt;p>CSS selector like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>NodeList containing the orphaned elements</return-description><summary>&lt;p>removes elements in this list that match the filter
from their parents and returns them as a new NodeList.&lt;/p>
</summary></method><method name="adopt" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="queryOrListOrNode" type="String||Array||DomNode" usage="required"><summary>&lt;p>a DOM node or a query string or a query result.
Represents the nodes to be adopted relative to the
first element of this NodeList.&lt;/p>
</summary></parameter><parameter name="position" type="String" usage="optional"><summary>&lt;p>can be one of:

&lt;/p>
&lt;ul>
&lt;li>&amp;quot;last&amp;quot; (default)&lt;/li>
&lt;li>&amp;quot;first&amp;quot;&lt;/li>
&lt;li>&amp;quot;before&amp;quot;&lt;/li>
&lt;li>&amp;quot;after&amp;quot;&lt;/li>
&lt;li>&amp;quot;only&amp;quot;&lt;/li>
&lt;li>&amp;quot;replace&amp;quot;&lt;/li>
&lt;/ul>
&lt;p>or an offset in the childNodes property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>places any/all elements in queryOrListOrNode at a
position relative to the first element in this list.
Returns a dojo/NodeList of the adopted elements.&lt;/p>
</summary></method><method name="query" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="queryStr" type="String" usage="required"/></parameters><return-types><return-type type="function"/><return-type type="undefined"/></return-types><return-description>&lt;p>Returns a new list whose members match the passed query,
assuming elements of the current NodeList as the root for
each search.&lt;/p>
</return-description><summary>&lt;p>Returns a new list whose members match the passed query,
assuming elements of the current NodeList as the root for
each search.&lt;/p>
</summary><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;
      bacon is tasty, &amp;lt;span&amp;gt;dontcha think?&amp;lt;/span&amp;gt;
    &amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;great comedians may not be funny &amp;lt;span&amp;gt;in person&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>If we are presented with the following definition for a NodeList:&lt;/p>
&lt;pre>&lt;code>  var l = new NodeList(dojo.byId(&amp;quot;foo&amp;quot;), dojo.byId(&amp;quot;bar&amp;quot;));&lt;/code>&lt;/pre>
&lt;p>it&amp;#39;s possible to find all span elements under paragraphs
contained by these elements with this sub-query:&lt;/p>
&lt;pre>&lt;code>  var spans = l.query(&amp;quot;p span&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="addContent" scope="prototype" type="function" from="dojo/NodeList-dom"><parameters><parameter name="content" type="String||DomNode||Object||dojo/NodeList" usage="required"><summary>&lt;p>the content to be set on the parent element.
This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes&lt;/p>
</summary></parameter><parameter name="position" type="String||Integer" usage="optional"><summary>&lt;p>can be one of:

&lt;/p>
&lt;ul>
&lt;li>&amp;quot;last&amp;quot;||&amp;quot;end&amp;quot; (default)&lt;/li>
&lt;li>&amp;quot;first||&amp;quot;start&amp;quot;&lt;/li>
&lt;li>&amp;quot;before&amp;quot;&lt;/li>
&lt;li>&amp;quot;after&amp;quot;&lt;/li>
&lt;li>&amp;quot;replace&amp;quot; (replaces nodes in this NodeList with new content)&lt;/li>
&lt;li>&amp;quot;only&amp;quot; (removes other children of the nodes so new content is the only child)&lt;/li>
&lt;/ul>
&lt;p>or an offset in the childNodes property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>add a node, NodeList or some HTML as a string to every item in the
list.  Returns the original list.&lt;/p>
</return-description><summary>&lt;p>add a node, NodeList or some HTML as a string to every item in the
list.  Returns the original list.&lt;/p>
</summary><description>&lt;p>a copy of the HTML content is added to each item in the
list, with an optional position argument. If no position
argument is provided, the content is appended to the end of
each item.&lt;/p>
</description><examples><example>&lt;p>appends content to the end if the position is omitted&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;h3 &amp;gt; p&amp;quot;).addContent(&amp;quot;hey there!&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>add something to the front of each element that has a
&amp;quot;thinger&amp;quot; property:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;[thinger]&amp;quot;).addContent(&amp;quot;...&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>adds a header before each element of the list&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.note&amp;quot;).addContent(&amp;quot;&amp;lt;h4&amp;gt;NOTE:&amp;lt;/h4&amp;gt;&amp;quot;, &amp;quot;before&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>add a clone of a DOM node to the end of every element in
the list, removing it from its existing parent.&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.note&amp;quot;).addContent(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>Append nodes from a templatized string.&lt;/p>
&lt;pre>&lt;code>  dojo.require(&amp;quot;dojo.string&amp;quot;);
  dojo.query(&amp;quot;.note&amp;quot;).addContent({
    template: &amp;#39;&amp;lt;b&amp;gt;${id}: &amp;lt;/b&amp;gt;&amp;lt;span&amp;gt;${name}&amp;lt;/span&amp;gt;&amp;#39;,
    id: &amp;quot;user332&amp;quot;,
    name: &amp;quot;Mr. Anderson&amp;quot;
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>Append nodes from a templatized string that also has widgets parsed.&lt;/p>
&lt;pre>&lt;code>  dojo.require(&amp;quot;dojo.string&amp;quot;);
  dojo.require(&amp;quot;dojo.parser&amp;quot;);
  var notes = dojo.query(&amp;quot;.note&amp;quot;).addContent({
    template: &amp;#39;&amp;lt;button dojoType=&amp;quot;dijit/form/Button&amp;quot;&amp;gt;${text}&amp;lt;/button&amp;gt;&amp;#39;,
    parse: true,
    text: &amp;quot;Send&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_anim" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="obj" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="wipeIn" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>wipe in all elements of this NodeList via &lt;code>dojo/fx.wipeIn()&lt;/code>
&lt;/p>
</summary><examples><example>&lt;p>Fade in all tables with class &amp;quot;blah&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;table.blah&amp;quot;).wipeIn().play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Utilizing &lt;code>auto&lt;/code> to get the NodeList back:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.titles&amp;quot;).wipeIn({ auto:true }).onclick(someFunction);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="wipeOut" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>wipe out all elements of this NodeList via &lt;code>dojo/fx.wipeOut()&lt;/code>
&lt;/p>
</summary><examples><example>&lt;p>Wipe out all tables with class &amp;quot;blah&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;table.blah&amp;quot;).wipeOut().play();&lt;/code>&lt;/pre>
</example></examples></method><method name="slideTo" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>slide all elements of the node list to the specified place via &lt;code>dojo/fx.slideTo()&lt;/code>
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  Move all tables with class &amp;quot;blah&amp;quot; to 300/300:
  dojo.query(&amp;quot;table.blah&amp;quot;).slideTo({
    left: 40,
    top: 50
  }).play();&lt;/code>&lt;/pre>
</example></examples></method><method name="fadeIn" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>fade in all elements of this NodeList via &lt;code>dojo.fadeIn&lt;/code>
&lt;/p>
</summary><examples><example>&lt;p>Fade in all tables with class &amp;quot;blah&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;table.blah&amp;quot;).fadeIn().play();&lt;/code>&lt;/pre>
</example></examples></method><method name="fadeOut" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>fade out all elements of this NodeList via &lt;code>dojo.fadeOut&lt;/code>
&lt;/p>
</summary><examples><example>&lt;p>Fade out all elements with class &amp;quot;zork&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.zork&amp;quot;).fadeOut().play();&lt;/code>&lt;/pre>
</example><example>&lt;p>Fade them on a delay and do something at the end:&lt;/p>
&lt;pre>&lt;code>  var fo = dojo.query(&amp;quot;.zork&amp;quot;).fadeOut();
  dojo.connect(fo, &amp;quot;onEnd&amp;quot;, function(){ /*...*/ });
  fo.play();&lt;/code>&lt;/pre>
</example><example>&lt;p>Using &lt;code>auto&lt;/code>:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;li&amp;quot;).fadeOut({ auto:true }).filter(filterFn).forEach(doit);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="animateProperty" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Additional dojo/_base/fx.Animation arguments to mix into this set with the addition of
an &lt;code>auto&lt;/code> parameter.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/fx.Animation|dojo/NodeList"/><return-type type="undefined"/></return-types><return-description>A special args member `auto` can be passed to automatically play the animation.
If args.auto is present, the original dojo/NodeList will be returned for further
chaining. Otherwise the dojo/_base/fx.Animation instance is returned and must be .play()'ed
</return-description><summary>&lt;p>Animate all elements of this NodeList across the properties specified.
syntax identical to &lt;code>dojo.animateProperty&lt;/code>
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.query(&amp;quot;.zork&amp;quot;).animateProperty({
    duration: 500,
    properties: {
      color:    { start: &amp;quot;black&amp;quot;, end: &amp;quot;white&amp;quot; },
      left:    { end: 300 }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  dojo.query(&amp;quot;.grue&amp;quot;).animateProperty({
    auto:true,
    properties: {
      height:240
    }
  }).onclick(handler);&lt;/code>&lt;/pre>
</example></examples></method><method name="anim" scope="prototype" type="function" from="dojo/NodeList-fx"><parameters><parameter name="properties" type="Object" usage="required"><summary>&lt;p>the properties to animate. does NOT support the &lt;code>auto&lt;/code> parameter like other
NodeList-fx methods.&lt;/p>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Optional. The time to run the animations for&lt;/p>
</summary></parameter><parameter name="easing" type="Function" usage="optional"><summary>&lt;p>Optional. The easing function to use.&lt;/p>
</summary></parameter><parameter name="onEnd" type="Function" usage="optional"><summary>&lt;p>A function to be called when the animation ends&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>how long to delay playing the returned animation&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Animate one or more CSS properties for all nodes in this list.
The returned animation object will already be playing when it
is returned. See the docs for &lt;code>dojo.anim&lt;/code> for full details.&lt;/p>
</summary><examples><example>&lt;p>Another way to fade out:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;).anim({ opacity: 0 });&lt;/code>&lt;/pre>
</example><example>&lt;p>animate all elements with the &amp;quot;thigner&amp;quot; class to a width of 500
pixels over half a second&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;).anim({ width: 500 }, 700);&lt;/code>&lt;/pre>
</example></examples></method><method name="html" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="value" type="String|DOMNode|NodeList" usage="optional"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>if no value is passed, the result is String, the innerHTML of the first node.
If a value is passed, the return is this dojo/NodeList</return-description><summary>&lt;p>allows setting the innerHTML of each node in the NodeList,
if there is a value passed in, otherwise, reads the innerHTML value of the first node.&lt;/p>
</summary><description>&lt;p>This method is simpler than the dojo/NodeList.html() method provided by
&lt;code>dojo/NodeList-html&lt;/code>. This method just does proper innerHTML insertion of HTML fragments,
and it allows for the innerHTML to be read for the first node in the node list.
Since dojo/NodeList-html already took the &amp;quot;html&amp;quot; name, this method is called
&amp;quot;innerHTML&amp;quot;. However, if dojo/NodeList-html has not been loaded yet, this
module will define an &amp;quot;html&amp;quot; method that can be used instead. Be careful if you
are working in an environment where it is possible that dojo/NodeList-html could
have been loaded, since its definition of &amp;quot;html&amp;quot; will take precedence.
The nodes represented by the value argument will be cloned if more than one
node is in this NodeList. The nodes in this NodeList are returned in the &amp;quot;set&amp;quot;
usage of this method, not the HTML that was inserted.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code inserts &lt;code>&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code> into both divs:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).innerHTML(&amp;quot;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code returns &lt;code>&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&lt;/code>:&lt;/p>
&lt;pre>&lt;code>  var message = dojo.query(&amp;quot;div&amp;quot;).innerHTML();&lt;/code>&lt;/pre>
</example></examples></method><method name="_placeMultiple" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String||Node||NodeList" usage="required"/><parameter name="position" type="String" usage="required"/></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>private method for inserting queried nodes into all nodes in this NodeList
at different positions. Differs from NodeList.place because it will clone
the nodes in this NodeList if the query matches more than one element.&lt;/p>
</return-description><summary>&lt;p>private method for inserting queried nodes into all nodes in this NodeList
at different positions. Differs from NodeList.place because it will clone
the nodes in this NodeList if the query matches more than one element.&lt;/p>
</summary></method><method name="innerHTML" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="value" type="String|DOMNode|NodeList" usage="optional"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>if no value is passed, the result is String, the innerHTML of the first node.
If a value is passed, the return is this dojo/NodeList</return-description><summary>&lt;p>allows setting the innerHTML of each node in the NodeList,
if there is a value passed in, otherwise, reads the innerHTML value of the first node.&lt;/p>
</summary><description>&lt;p>This method is simpler than the dojo/NodeList.html() method provided by
&lt;code>dojo/NodeList-html&lt;/code>. This method just does proper innerHTML insertion of HTML fragments,
and it allows for the innerHTML to be read for the first node in the node list.
Since dojo/NodeList-html already took the &amp;quot;html&amp;quot; name, this method is called
&amp;quot;innerHTML&amp;quot;. However, if dojo/NodeList-html has not been loaded yet, this
module will define an &amp;quot;html&amp;quot; method that can be used instead. Be careful if you
are working in an environment where it is possible that dojo/NodeList-html could
have been loaded, since its definition of &amp;quot;html&amp;quot; will take precedence.
The nodes represented by the value argument will be cloned if more than one
node is in this NodeList. The nodes in this NodeList are returned in the &amp;quot;set&amp;quot;
usage of this method, not the HTML that was inserted.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code inserts &lt;code>&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code> into both divs:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).innerHTML(&amp;quot;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code returns &lt;code>&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&lt;/code>:&lt;/p>
&lt;pre>&lt;code>  var message = dojo.query(&amp;quot;div&amp;quot;).innerHTML();&lt;/code>&lt;/pre>
</example></examples></method><method name="text" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/><return-type type="string"/></return-types><return-description>if no value is passed, the result is String, the text value of the first node.
If a value is passed, the return is this dojo/NodeList</return-description><summary>&lt;p>allows setting the text value of each node in the NodeList,
if there is a value passed in, otherwise, returns the text value for all the
nodes in the NodeList in one string.&lt;/p>
</summary><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code inserts &amp;quot;Hello World&amp;quot; into both divs:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).text(&amp;quot;Hello World&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars &amp;lt;span&amp;gt;today&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code returns &amp;quot;Hello Mars today&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  var message = dojo.query(&amp;quot;div&amp;quot;).text();&lt;/code>&lt;/pre>
</example></examples></method><method name="val" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="value" type="String||Array" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/><return-type type="undefined"/><return-type type="null"/></return-types><return-description>if no value is passed, the result is String or an Array, for the value of the
first node.
If a value is passed, the return is this dojo/NodeList</return-description><summary>&lt;p>If a value is passed, allows seting the value property of form elements in this
NodeList, or properly selecting/checking the right value for radio/checkbox/select
elements. If no value is passed, the value of the first node in this NodeList
is returned.&lt;/p>
</summary><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;input type=&amp;quot;text&amp;quot; value=&amp;quot;foo&amp;quot;&amp;gt;
  &amp;lt;select multiple&amp;gt;
    &amp;lt;option value=&amp;quot;red&amp;quot; selected&amp;gt;Red&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;blue&amp;quot;&amp;gt;Blue&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;yellow&amp;quot; selected&amp;gt;Yellow&amp;lt;/option&amp;gt;
  &amp;lt;/select&amp;gt;&lt;/code>&lt;/pre>
&lt;p>This code gets and sets the values for the form fields above:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;#39;[type=&amp;quot;text&amp;quot;]&amp;#39;).val(); //gets value foo
  dojo.query(&amp;#39;[type=&amp;quot;text&amp;quot;]&amp;#39;).val(&amp;quot;bar&amp;quot;); //sets the input&amp;#39;s value to &amp;quot;bar&amp;quot;
  dojo.query(&amp;quot;select&amp;quot;).val() //gets array value [&amp;quot;red&amp;quot;, &amp;quot;yellow&amp;quot;]
  dojo.query(&amp;quot;select&amp;quot;).val([&amp;quot;blue&amp;quot;, &amp;quot;yellow&amp;quot;]) //Sets the blue and yellow options to selected.&lt;/code>&lt;/pre>
</example></examples></method><method name="append" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="content" type="String||DOMNode||NodeList" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the appended content.</return-description><summary>&lt;p>appends the content to every node in the NodeList.&lt;/p>
</summary><description>&lt;p>The content will be cloned if the length of NodeList
is greater than 1. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).append(&amp;quot;&amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="appendTo" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the matched nodes from the query.</return-description><summary>&lt;p>appends nodes in this NodeList to the nodes matched by
the query passed to appendTo.&lt;/p>
</summary><description>&lt;p>The nodes in this NodeList will be cloned if the query
matches more than one element. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;span&amp;quot;).appendTo(&amp;quot;p&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;p&amp;gt;Hello Mars&amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;span&amp;gt;append&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="prepend" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="content" type="String||DOMNode||NodeList" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the appended content.
assume a DOM created by this markup:
|  &lt;div id=&quot;foo&quot;>&lt;p>Hello Mars&lt;/p>&lt;/div>
|  &lt;div id=&quot;bar&quot;>&lt;p>Hello World&lt;/p>&lt;/div>
Running this code:
|  dojo.query(&quot;div&quot;).prepend(&quot;&lt;span>prepend&lt;/span>&quot;);
Results in this DOM structure:
|  &lt;div id=&quot;foo&quot;>&lt;span>prepend&lt;/span>&lt;p>Hello Mars&lt;/p>&lt;/div>
|  &lt;div id=&quot;bar&quot;>&lt;span>prepend&lt;/span>&lt;p>Hello World&lt;/p>&lt;/div></return-description><summary>&lt;p>prepends the content to every node in the NodeList.&lt;/p>
</summary><description>&lt;p>The content will be cloned if the length of NodeList
is greater than 1. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description></method><method name="prependTo" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the matched nodes from the query.</return-description><summary>&lt;p>prepends nodes in this NodeList to the nodes matched by
the query passed to prependTo.&lt;/p>
</summary><description>&lt;p>The nodes in this NodeList will be cloned if the query
matches more than one element. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;prepend&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;span&amp;quot;).prependTo(&amp;quot;p&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;prepend&amp;lt;/span&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;prepend&amp;lt;/span&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="after" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="content" type="String||Element||NodeList" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the appended content.</return-description><summary>&lt;p>Places the content after every node in the NodeList.&lt;/p>
</summary><description>&lt;p>The content will be cloned if the length of NodeList
is greater than 1. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).after(&amp;quot;&amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="insertAfter" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the matched nodes from the query.</return-description><summary>&lt;p>The nodes in this NodeList will be placed after the nodes
matched by the query passed to insertAfter.&lt;/p>
</summary><description>&lt;p>The nodes in this NodeList will be cloned if the query
matches more than one element. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;span&amp;quot;).insertAfter(&amp;quot;p&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;span&amp;gt;after&amp;lt;/span&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="before" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="content" type="String||DOMNode||NodeList" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the appended content.</return-description><summary>&lt;p>Places the content before every node in the NodeList.&lt;/p>
</summary><description>&lt;p>The content will be cloned if the length of NodeList
is greater than 1. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;div&amp;quot;).before(&amp;quot;&amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;&amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;&amp;lt;div id=&amp;quot;bar&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="insertBefore" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>dojo/NodeList, the nodes currently in this NodeList will be returned,
not the matched nodes from the query.</return-description><summary>&lt;p>The nodes in this NodeList will be placed after the nodes
matched by the query passed to insertAfter.&lt;/p>
</summary><description>&lt;p>The nodes in this NodeList will be cloned if the query
matches more than one element. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;span&amp;quot;).insertBefore(&amp;quot;p&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;&amp;lt;p&amp;gt;Hello Mars&amp;lt;/p&amp;gt;
  &amp;lt;span&amp;gt;before&amp;lt;/span&amp;gt;&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="remove" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="filter" type="String" usage="optional"><summary>&lt;p>CSS selector like &amp;quot;.foo&amp;quot; or &amp;quot;div &amp;gt; span&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>NodeList containing the orphaned elements</return-description><summary>&lt;p>removes elements in this list that match the filter
from their parents and returns them as a new NodeList.&lt;/p>
</summary></method><method name="wrap" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="html" type="String||DOMNode" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>the nodes in the current NodeList will be returned,
not the nodes from html argument.</return-description><summary>&lt;p>Wrap each node in the NodeList with html passed to wrap.&lt;/p>
</summary><description>&lt;p>html will be cloned if the NodeList has more than one
element. Only DOM nodes are cloned, not any attached
event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;b&amp;gt;one&amp;lt;/b&amp;gt;
  &amp;lt;b&amp;gt;two&amp;lt;/b&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;b&amp;quot;).wrap(&amp;quot;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;b&amp;gt;one&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;b&amp;gt;two&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="wrapAll" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="html" type="String||DOMNode" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>the nodes in the current NodeList will be returned,
not the nodes from html argument.</return-description><summary>&lt;p>Insert html where the first node in this NodeList lives, then place all
nodes in this NodeList as the child of the html.&lt;/p>
</summary><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).wrapAll(&amp;#39;&amp;lt;div class=&amp;quot;allRed&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;#39;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;allRed&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
      &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="wrapInner" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="html" type="String||DOMNode" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>the nodes in the current NodeList will be returned,
not the nodes from html argument.</return-description><summary>&lt;p>For each node in the NodeList, wrap all its children with the passed in html.&lt;/p>
</summary><description>&lt;p>html will be cloned if the NodeList has more than one
element. Only DOM nodes are cloned, not any attached
event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).wrapInner(&amp;#39;&amp;lt;span class=&amp;quot;special&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;#39;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;special&amp;quot;&amp;gt;Red One&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;special&amp;quot;&amp;gt;Red Two&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="replaceWith" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="content" type="String||DOMNode||NodeList" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>The nodes currently in this NodeList will be returned, not the replacing content.
Note that the returned nodes have been removed from the DOM.</return-description><summary>&lt;p>Replaces each node in ths NodeList with the content passed to replaceWith.&lt;/p>
</summary><description>&lt;p>The content will be cloned if the length of NodeList
is greater than 1. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).replaceWith(&amp;#39;&amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;Green&amp;lt;/div&amp;gt;&amp;#39;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;Green&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;green&amp;quot;&amp;gt;Green&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="replaceAll" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>The nodes currently in this NodeList will be returned, not the matched nodes
from the query. The nodes currently in this NodeLIst could have
been cloned, so the returned NodeList will include the cloned nodes.</return-description><summary>&lt;p>replaces nodes matched by the query passed to replaceAll with the nodes
in this NodeList.&lt;/p>
</summary><description>&lt;p>The nodes in this NodeList will be cloned if the query
matches more than one element. Only the DOM nodes are cloned, not
any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).replaceAll(&amp;quot;.blue&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;spacer&amp;quot;&amp;gt;___&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="clone" scope="prototype" type="function" from="dojo/NodeList-manipulate"><parameters/><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>a cloned set of the original nodes.</return-description><summary>&lt;p>Clones all the nodes in this NodeList and returns them as a new NodeList.&lt;/p>
</summary><description>&lt;p>Only the DOM nodes are cloned, not any attached event handlers.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).clone().appendTo(&amp;quot;.container&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>Results in this DOM structure:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="_buildArrayFromCallback" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="callback" type="Function" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>builds a new array of possibly differing size based on the input list.
Since the returned array is likely of different size than the input array,
the array&amp;#39;s map function cannot be used.&lt;/p>
</summary></method><method name="_getUniqueAsNodeList" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="nodes" type="Array" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>given a list of nodes, make sure only unique
elements are returned as our NodeList object.
Does not call _stash().&lt;/p>
</summary></method><method name="_getUniqueNodeListWithParent" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="nodes" type="Array" usage="required"/><parameter name="query" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>gets unique element nodes, filters them further
with an optional query and then calls _stash to track parent NodeList.&lt;/p>
</summary></method><method name="_getRelatedUniqueNodes" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"/><parameter name="callback" type="Function" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>cycles over all the nodes and calls a callback
to collect nodes for a possible inclusion in a result.
The callback will get two args: callback(node, ary),
where ary is the array being used to collect the nodes.&lt;/p>
</summary></method><method name="children" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>all immediate child elements for the nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns all immediate child elements for nodes in this dojo/NodeList.
Optionally takes a query to filter the child elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.container&amp;quot;).children();&lt;/code>&lt;/pre>
&lt;p>returns the four divs that are children of the container div.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.container&amp;quot;).children(&amp;quot;.red&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the two divs that have the class &amp;quot;red&amp;quot;.&lt;/p>
</example></examples></method><method name="closest" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="required"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter><parameter name="root" type="String|DOMNode" usage="optional"><summary>&lt;p>If specified, query is relative to &amp;quot;root&amp;quot; rather than document body.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the closest parent that matches the query, including the current
node in this dojo/NodeList if it matches the query.</return-description><summary>&lt;p>Returns closest parent that matches query, including current node in this
dojo/NodeList if it matches the query.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.red&amp;quot;).closest(&amp;quot;.container&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the div with class &amp;quot;container&amp;quot;.&lt;/p>
</example></examples></method><method name="parent" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>immediate parent elements for nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns immediate parent elements for nodes in this dojo/NodeList.
Optionally takes a query to filter the parent elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Blue One&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Blue Two&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.text&amp;quot;).parent();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class &amp;quot;blue&amp;quot;.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.text&amp;quot;).parent(&amp;quot;.first&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the one div with class &amp;quot;blue&amp;quot; and &amp;quot;first&amp;quot;.&lt;/p>
</example></examples></method><method name="parents" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>all parent elements for nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns all parent elements for nodes in this dojo/NodeList.
Optionally takes a query to filter the child elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Blue One&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;text&amp;quot;&amp;gt;Blue Two&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.text&amp;quot;).parents();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class &amp;quot;blue&amp;quot;, the div with class &amp;quot;container&amp;quot;,&lt;/p>
&lt;pre>&lt;code>  the body element and the html element.&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.text&amp;quot;).parents(&amp;quot;.container&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the one div with class &amp;quot;container&amp;quot;.&lt;/p>
</example></examples></method><method name="siblings" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>all sibling elements for nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns all sibling elements for nodes in this dojo/NodeList.
Optionally takes a query to filter the sibling elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).siblings();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class &amp;quot;red&amp;quot; and the other div&lt;/p>
&lt;pre>&lt;code>  with class &amp;quot;blue&amp;quot; that does not have &amp;quot;first&amp;quot;.&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).siblings(&amp;quot;.red&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the two div with class &amp;quot;red&amp;quot;.&lt;/p>
</example></examples></method><method name="next" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the next element for nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns the next element for nodes in this dojo/NodeList.
Optionally takes a query to filter the next elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue last&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).next();&lt;/code>&lt;/pre>
&lt;p>returns the div with class &amp;quot;red&amp;quot; and has innerHTML of &amp;quot;Red Two&amp;quot;.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.last&amp;quot;).next(&amp;quot;.red&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>does not return any elements.&lt;/p>
</example></examples></method><method name="nextAll" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>all sibling elements that come after the nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns all sibling elements that come after the nodes in this dojo/NodeList.
Optionally takes a query to filter the sibling elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red next&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue next&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).nextAll();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class of &amp;quot;next&amp;quot;.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).nextAll(&amp;quot;.red&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the one div with class &amp;quot;red&amp;quot; and innerHTML &amp;quot;Red Two&amp;quot;.&lt;/p>
</example></examples></method><method name="prev" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the previous element for nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns the previous element for nodes in this dojo/NodeList.
Optionally takes a query to filter the previous elements.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).prev();&lt;/code>&lt;/pre>
&lt;p>returns the div with class &amp;quot;red&amp;quot; and has innerHTML of &amp;quot;Red One&amp;quot;.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).prev(&amp;quot;.blue&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>does not return any elements.&lt;/p>
</example></examples></method><method name="prevAll" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters><parameter name="query" type="String" usage="optional"><summary>&lt;p>a CSS selector.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>all sibling elements that come before the nodes in this dojo/NodeList.</return-description><summary>&lt;p>Returns all sibling elements that come before the nodes in this dojo/NodeList.
Optionally takes a query to filter the sibling elements.&lt;/p>
</summary><description>&lt;p>The returned nodes will be in reverse DOM order -- the first node in the list will
be the node closest to the original node/NodeList.
.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red prev&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue prev&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red second&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.second&amp;quot;).prevAll();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class of &amp;quot;prev&amp;quot;.
Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.first&amp;quot;).prevAll(&amp;quot;.red&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>returns the one div with class &amp;quot;red prev&amp;quot; and innerHTML &amp;quot;Red One&amp;quot;.&lt;/p>
</example></examples></method><method name="andSelf" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red prev&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    Some Text
    &amp;lt;div class=&amp;quot;blue prev&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red second&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.second&amp;quot;).prevAll().andSelf();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class of &amp;quot;prev&amp;quot;, as well as the div with class &amp;quot;second&amp;quot;.&lt;/p>
</example></examples></method><method name="first" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the first node in this dojo/NodeList</return-description><summary>&lt;p>Returns the first node in this dojo/NodeList as a dojo/NodeList.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue last&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.blue&amp;quot;).first();&lt;/code>&lt;/pre>
&lt;p>returns the div with class &amp;quot;blue&amp;quot; and &amp;quot;first&amp;quot;.&lt;/p>
</example></examples></method><method name="last" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the last node in this dojo/NodeList</return-description><summary>&lt;p>Returns the last node in this dojo/NodeList as a dojo/NodeList.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue first&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;blue last&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.blue&amp;quot;).last();&lt;/code>&lt;/pre>
&lt;p>returns the last div with class &amp;quot;blue&amp;quot;,&lt;/p>
</example></examples></method><method name="even" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the even nodes in this dojo/NodeList</return-description><summary>&lt;p>Returns the even nodes in this dojo/NodeList as a dojo/NodeList.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;interior red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.interior&amp;quot;).even();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class &amp;quot;blue&amp;quot;&lt;/p>
</example></examples></method><method name="odd" scope="prototype" type="function" from="dojo/NodeList-traverse"><parameters/><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the odd nodes in this dojo/NodeList</return-description><summary>&lt;p>Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.&lt;/p>
</summary><description>&lt;p>.end() can be used on the returned dojo/NodeList to get back to the
original dojo/NodeList.&lt;/p>
</description><examples><example>&lt;p>assume a DOM created by this markup:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;interior red&amp;quot;&amp;gt;Red One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior blue&amp;quot;&amp;gt;Blue One&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior red&amp;quot;&amp;gt;Red Two&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;interior blue&amp;quot;&amp;gt;Blue Two&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;&lt;/code>&lt;/pre>
&lt;p>Running this code:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.interior&amp;quot;).odd();&lt;/code>&lt;/pre>
&lt;p>returns the two divs with class &amp;quot;red&amp;quot;&lt;/p>
</example></examples></method><method name="connect" scope="prototype" type="function" from="dojo/_base/NodeList"><parameters><parameter name="methodName" type="String" usage="required"><summary>&lt;p>the name of the method to attach to. For DOM events, this should be
the lower-case name of the event&lt;/p>
</summary></parameter><parameter name="objOrFunc" type="Object|Function|String" usage="required"><summary>&lt;p>if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
reference a function or be the name of the function in the global
namespace to attach. If 3 arguments are provided
(methodName, objOrFunc, funcName), objOrFunc must be the scope to
locate the bound function in&lt;/p>
</summary></parameter><parameter name="funcName" type="String" usage="optional"><summary>&lt;p>optional. A string naming the function in objOrFunc to bind to the
event. May also be a function reference.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Attach event handlers to every item of the NodeList. Uses dojo.connect()
so event properties are normalized.

&lt;/p>
&lt;p>Application must manually require() &amp;quot;dojo/_base/connect&amp;quot; before using this method.&lt;/p>
</summary><examples><example>&lt;p>add an onclick handler to every button on the page&lt;/p>
&lt;pre>&lt;code>  query(&amp;quot;div:nth-child(odd)&amp;quot;).connect(&amp;quot;onclick&amp;quot;, function(e){
    console.log(&amp;quot;clicked!&amp;quot;);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>attach foo.bar() to every odd div&amp;#39;s onmouseover&lt;/p>
&lt;pre>&lt;code>  query(&amp;quot;div:nth-child(odd)&amp;quot;).connect(&amp;quot;onmouseover&amp;quot;, foo, &amp;quot;bar&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="coords" scope="prototype" type="function" from="dojo/_base/NodeList"><parameters/><return-types/><summary>&lt;p>Deprecated: Use position() for border-box x/y/w/h
or marginBox() for margin-box w/h/l/t.
Returns the box objects of all elements in a node list as
an Array (&lt;em>not&lt;/em> a NodeList). Acts like &lt;code>domGeom.coords&lt;/code>, though assumes
the node passed is each node in this list.&lt;/p>
</summary></method><method name="_wrap" scope="normal" type="function" from="dojo/query"><parameters><parameter name="a" type="Array" usage="required"><summary>&lt;p>Array of nodes to decorate.&lt;/p>
</summary></parameter><parameter name="parent" type="dojo/NodeList" usage="optional"><summary>&lt;p>An optional parent NodeList that generated the current
list of nodes. Used to call _stash() so the parent NodeList
can be accessed via end() later.&lt;/p>
</summary></parameter><parameter name="NodeListCtor" type="Function" usage="optional"><summary>&lt;p>An optional constructor function to use for any
new NodeList calls. This allows a certain chain of
NodeList calls to use a different object than dojo/NodeList.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>decorate an array to make it look like a &lt;code>dojo/NodeList&lt;/code>.&lt;/p>
</summary></method><method name="_adaptAsMap" scope="normal" type="function" from="dojo/query"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>a function to adapt&lt;/p>
</summary></parameter><parameter name="o" type="Object" usage="optional"><summary>&lt;p>an optional context for f&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>adapts a single node function to be used in the map-type
actions. The return is a new array of values, as via &lt;code>dojo.map&lt;/code>&lt;/p>
</summary></method><method name="_adaptAsForEach" scope="normal" type="function" from="dojo/query"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>a function to adapt&lt;/p>
</summary></parameter><parameter name="o" type="Object" usage="optional"><summary>&lt;p>an optional context for f&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>adapts a single node function to be used in the forEach-type
actions. The initial object is returned from the specialized
function.&lt;/p>
</summary></method><method name="_adaptAsFilter" scope="normal" type="function" from="dojo/query"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>a function to adapt&lt;/p>
</summary></parameter><parameter name="o" type="Object" usage="optional"><summary>&lt;p>an optional context for f&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>adapts a single node function to be used in the filter-type actions&lt;/p>
</summary></method><method name="_adaptWithCondition" scope="normal" type="function" from="dojo/query"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>a function to adapt&lt;/p>
</summary></parameter><parameter name="g" type="Function" usage="required"><summary>&lt;p>a condition function, if true runs as map(), otherwise runs as forEach()&lt;/p>
</summary></parameter><parameter name="o" type="Object" usage="optional"><summary>&lt;p>an optional context for f and g&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>adapts a single node function to be used in the map-type
actions, behaves like forEach() or map() depending on arguments&lt;/p>
</summary></method></methods><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/Stateful" type="constructor" classlike="true"><properties><property name="_attrPairNames" scope="prototype" type="Hash" from="dojo/Stateful"><summary>&lt;p>Used across all instances a hash to cache attribute names and their getter 
and setter names.&lt;/p>
</summary></property></properties><methods><method name="_getAttrNames" scope="prototype" type="function" from="dojo/Stateful" private="true"><parameters><parameter name="name" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="object"/></return-types><summary>&lt;p>Helper function for get() and set().
Caches attribute name values so we don&amp;#39;t do the string ops every time.&lt;/p>
</summary></method><method name="postscript" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="params" type="Object" usage="optional"/></parameters><return-types/></method><method name="_get" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="name" type="undefined" usage="required"/><parameter name="names" type="undefined" usage="required"><summary>&lt;p>Hash of names of custom attributes&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Private function that does a get based off a hash of names&lt;/p>
</summary></method><method name="get" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The property to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>The property value on this Stateful instance.</return-description><summary>&lt;p>Get a property on a Stateful instance.&lt;/p>
</summary><description>&lt;p>Get a named property on a Stateful object. The property may
potentially be retrieved via a getter method in subclasses. In the base class
this just retrieves the object&amp;#39;s property.
For example:&lt;/p>
&lt;pre>&lt;code>  stateful = new dojo.Stateful({foo: 3});
  stateful.get(&amp;quot;foo&amp;quot;) // returns 3
  stateful.foo // returns 3&lt;/code>&lt;/pre>
</description></method><method name="set" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The property to set.&lt;/p>
</summary></parameter><parameter name="value" type="Object" usage="required"><summary>&lt;p>The value to set in the property.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="function"/></return-types><return-description>The function returns this dojo.Stateful instance.</return-description><summary>&lt;p>Set a property on a Stateful instance&lt;/p>
</summary><description>&lt;p>Sets named properties on a stateful object and notifies any watchers of
the property. A programmatic setter may be defined in subclasses.
For example:&lt;/p>
&lt;pre>&lt;code>  stateful = new dojo.Stateful();
  stateful.watch(function(name, oldValue, value){
    // this will be called on the set below
  }
  stateful.set(foo, 5);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>set() may also be called with a hash of name/value pairs, ex:&lt;/p>
&lt;pre>&lt;code>  myObj.set({
    foo: &amp;quot;Howdy&amp;quot;,
    bar: 3
  })&lt;/code>&lt;/pre>
&lt;p>This is equivalent to calling set(foo, &amp;quot;Howdy&amp;quot;) and set(bar, 3)&lt;/p>
</description></method><method name="_changeAttrValue" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The property to set.&lt;/p>
</summary></parameter><parameter name="value" type="Mixed" usage="required"><summary>&lt;p>The value to set in the property.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>Internal helper for directly changing an attribute value.
&lt;/p>
</return-description><summary>&lt;p>Internal helper for directly changing an attribute value.
&lt;/p>
</summary><description>&lt;p>Directly change the value of an attribute on an object, bypassing any
accessor setter.  Also handles the calling of watch and emitting events.
It is designed to be used by descendent class when there are two values
of attributes that are linked, but calling .set() is not appropriate.&lt;/p>
</description></method><method name="watch" scope="prototype" type="function" from="dojo/Stateful"><parameters><parameter name="name" type="String" usage="optional"><summary>&lt;p>Indicates the property to watch. This is optional (the callback may be the
only parameter), and if omitted, all the properties will be watched&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="required"><summary>&lt;p>The function to execute when the property changes. This will be called after
the property has been changed. The callback will be called with the |this|
set to the instance, the first argument as the name of the property, the
second argument as the old value and the third argument as the new value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="object"/></return-types><return-description>An object handle for the watch. The unwatch method of this object
can be used to discontinue watching this property:
|  var watchHandle = obj.watch(&quot;foo&quot;, callback);
|  watchHandle.unwatch(); // callback won't be called now</return-description><summary>&lt;p>Watches a property for changes&lt;/p>
</summary></method></methods><summary>&lt;p>Base class for objects that provide named properties with optional getter/setter
control and the ability to watch for property changes

&lt;/p>
&lt;p>The class also provides the functionality to auto-magically manage getters
and setters for object attributes/properties.

&lt;/p>
&lt;p>Getters and Setters should follow the format of _xxxGetter or _xxxSetter where
the xxx is a name of the attribute to handle.  So an attribute of &amp;quot;foo&amp;quot;
would have a custom getter of _fooGetter and a custom setter of _fooSetter.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var obj = new dojo.Stateful();
  obj.watch(&amp;quot;foo&amp;quot;, function(){
    console.log(&amp;quot;foo changed to &amp;quot; + this.get(&amp;quot;foo&amp;quot;));
  });
  obj.set(&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/_base/NodeList" type="object"><properties/><methods/><summary>&lt;p>This module extends dojo/NodeList with the legacy connect(), coords(),
blur(), focus(), change(), click(), error(), keydown(), keypress(),
keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
mouseout(), mouseover(), mouseup(), and submit() methods.&lt;/p>
</summary></object><object location="dojo/_base/browser" type="object"><properties/><methods/><summary>&lt;p>This module causes the browser-only base modules to be loaded.&lt;/p>
</summary></object><object location="dojo/_base/unload" type="object"><properties/><methods><method name="addOnWindowUnload" scope="normal" type="function" from="dojo/_base/unload"><parameters><parameter name="obj" type="Object|Function" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when window.onunload
fires.&lt;/p>
</summary><description>&lt;p>The first time that addOnWindowUnload is called Dojo
will register a page listener to trigger your unload
handler with. Note that registering these handlers may
destroy &amp;quot;fastback&amp;quot; page caching in browsers that support
it. Be careful trying to modify the DOM or access
JavaScript properties during this phase of page unloading:
they may not always be available. Consider
addOnUnload() if you need to modify the DOM or do
heavy JavaScript work since it fires at the equivalent of
the page&amp;#39;s &amp;quot;onbeforeunload&amp;quot; event.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  unload.addOnWindowUnload(functionPointer)
  unload.addOnWindowUnload(object, &amp;quot;functionName&amp;quot;);
  unload.addOnWindowUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="addOnUnload" scope="normal" type="function" from="dojo/_base/unload"><parameters><parameter name="obj" type="Object?|Function" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when the page unloads.&lt;/p>
</summary><description>&lt;p>The first time that addOnUnload is called Dojo will
register a page listener to trigger your unload handler
with.

&lt;/p>
&lt;p>In a browser environment, the functions will be triggered
during the window.onbeforeunload event. Be careful of doing
too much work in an unload handler. onbeforeunload can be
triggered if a link to download a file is clicked, or if
the link is a javascript: link. In these cases, the
onbeforeunload event fires, but the document is not
actually destroyed. So be careful about doing destructive
operations in a dojo.addOnUnload callback.

&lt;/p>
&lt;p>Further note that calling dojo.addOnUnload will prevent
browsers from using a &amp;quot;fast back&amp;quot; cache to make page
loading via back button instantaneous.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.addOnUnload(functionPointer)
  dojo.addOnUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module contains the document and window unload detection API.&lt;/p>
</summary></object><object location="dojo/_base/xhr" type="function"><properties><property name="contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/_base/xhr"><parameters><parameter name="method" type="String" usage="required"><summary>&lt;p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="hasBody" type="Boolean" usage="optional"><summary>&lt;p>If the request has an HTTP body, then pass true for hasBody.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deprecated.   Use dojo/request instead.&lt;/p>
</summary><description>&lt;p>Sends an HTTP request with the given method.
See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
for those HTTP methods. There are also methods for &amp;quot;raw&amp;quot; PUT and POST methods
via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.&lt;/p>
</description></method><method name="_xhrObj" scope="normal" type="function" from="dojo/_base/xhr"><parameters/><return-types><return-type type="instance"/></return-types></method><method name="fieldToObject" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="inputNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Serialize a form field to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the value encoded in a form field as
as a string or an array of strings. Disabled form elements
and unchecked radio and checkboxes are skipped.  Multi-select
elements are returned as an array of string values.&lt;/p>
</description></method><method name="formToObject" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Serialize a form node to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the values encoded in an HTML form as
string properties in an object which it then returns. Disabled form
elements, buttons, and other non-value form elements are skipped.
Multi-select elements are returned as an array of string values.&lt;/p>
</description><examples><example>&lt;p>This form:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;form id=&amp;quot;test_form&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blah&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;no_value&amp;quot; value=&amp;quot;blah&amp;quot; disabled&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;no_value2&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;select type=&amp;quot;select&amp;quot; multiple name=&amp;quot;multi&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;
      &amp;lt;option value=&amp;quot;blah&amp;quot;&amp;gt;blah&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thud&amp;quot; selected&amp;gt;thud&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thonk&amp;quot; selected&amp;gt;thonk&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields this object structure as the result of a call to
formToObject():

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="objectToQuery" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="map" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>takes a name/value mapping object and returns a string representing
a URL-encoded version of that object.&lt;/p>
</summary><examples><example>&lt;p>this object:

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields the following query string:

&lt;/p>
&lt;pre>&lt;code>  &amp;quot;blah=blah&amp;amp;multi=thud&amp;amp;multi=thonk&amp;quot;&lt;/code>&lt;/pre>
</example></examples></method><method name="formToQuery" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns a URL-encoded string representing the form passed as either a
node or string ID identifying the form to serialize&lt;/p>
</summary></method><method name="formToJson" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/><parameter name="prettyPrint" type="Boolean" usage="optional"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Create a serialized JSON string from a form node or string
ID identifying the form to serialize&lt;/p>
</summary></method><method name="queryToObject" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="str" type="String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Create an object representing a de-serialized query section of a
URL. Query keys with multiple values are returned in an array.
&lt;/p>
</summary><examples><example>&lt;p>This string:

&lt;/p>
&lt;pre>&lt;code>    &amp;quot;foo=bar&amp;amp;foo=baz&amp;amp;thinger=%20spaces%20=blah&amp;amp;zonk=blarg&amp;amp;&amp;quot;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>results in this object structure:

&lt;/p>
&lt;pre>&lt;code>    {
      foo: [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ],
      thinger: &amp;quot; spaces =blah&amp;quot;,
      zonk: &amp;quot;blarg&amp;quot;
    }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that spaces and other urlencoded entities are correctly
handled.&lt;/p>
</example></examples></method><method name="_ioSetArgs" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="dojo/main.__IoArgs" usage="required"><summary>&lt;p>The args object passed into the public io call. Recognized properties on
the args object are:&lt;/p>
</summary></parameter><parameter name="canceller" type="Function" usage="required"><summary>&lt;p>The canceller function used for the Deferred object. The function
will receive one argument, the Deferred object that is related to the
canceller.&lt;/p>
</summary></parameter><parameter name="okHandler" type="Function" usage="required"><summary>&lt;p>The first OK callback to be registered with Deferred. It has the opportunity
to transform the OK response. It will receive one argument -- the Deferred
object returned from this function.&lt;/p>
</summary></parameter><parameter name="errHandler" type="Function" usage="required"><summary>&lt;p>The first error callback to be registered with Deferred. It has the opportunity
to do cleanup on an error. It will receive two arguments: error (the
Error object) and dfd, the Deferred object returned from this function.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>sets up the Deferred and ioArgs property on the Deferred so it
can be used in an io call.&lt;/p>
</summary></method><method name="_ioCancelAll" scope="normal" type="function" from="dojo/_base/xhr"><parameters/><return-types/><summary>&lt;p>Cancels all pending IO requests, regardless of IO type
(xhr, script, iframe).&lt;/p>
</summary></method><method name="_ioNotifyStart" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>If dojo.publish is available, publish topics
about the start of a request queue and/or the
the beginning of request.

&lt;/p>
&lt;p>Used by IO transports. An IO transport should
call this method before making the network connection.&lt;/p>
</summary></method><method name="_ioWatch" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter><parameter name="validCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if the IO request is still valid. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="ioCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if basic IO call worked. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="resHandle" type="Function" usage="required"><summary>&lt;p>Function used to process response. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></method><method name="_ioAddQueryToUrl" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="ioArgs" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>args (Object): &lt;p>the original object argument to the IO call.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>xhr (XMLHttpRequest): &lt;p>For XMLHttpRequest calls only, the
XMLHttpRequest object that was used for the
request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>The final URL used for the call. Many times it
will be different than the original args.url
value.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>query (String): &lt;p>For non-GET requests, the
name1=value1&amp;amp;name2=value2 parameters sent up in
the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handleAs (String): &lt;p>The final indicator on how the response will be
handled.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String): &lt;p>For dojo/io/script calls only, the internal
script ID used for the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>canDelete (Boolean): &lt;p>For dojo/io/script calls only, indicates
whether the script tag that represents the
request can be deleted after callbacks have
been called. Used internally to know when
cleanup can happen on JSONP-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>json (Object): &lt;p>For dojo/io/script calls only: holds the JSON
response for JSONP-type requests. Used
internally to hold on to the JSON responses.
You should not need to access it directly --
the same object should be passed to the success
callbacks directly.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Adds query params discovered by the io deferred construction to the URL.
Only use this for operations which are fundamentally GET-type operations.&lt;/p>
</summary></method><method name="_isDocumentOk" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="x" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_getText" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="url" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="get" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP GET request to the server.&lt;/p>
</summary></method><method name="post" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="put" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="del" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP DELETE request to the server.&lt;/p>
</summary></method></methods><parameters><parameter name="method" type="String" usage="required"><summary>&lt;p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="hasBody" type="Boolean" usage="optional"><summary>&lt;p>If the request has an HTTP body, then pass true for hasBody.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deprecated.   Use dojo/request instead.&lt;/p>
</summary><description>&lt;p>Sends an HTTP request with the given method.
See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
for those HTTP methods. There are also methods for &amp;quot;raw&amp;quot; PUT and POST methods
via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.&lt;/p>
</description></object><object location="dojo/io-query" type="object"><properties/><methods><method name="objectToQuery" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="map" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>takes a name/value mapping object and returns a string representing
a URL-encoded version of that object.&lt;/p>
</summary><examples><example>&lt;p>this object:

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields the following query string:

&lt;/p>
&lt;pre>&lt;code>  &amp;quot;blah=blah&amp;amp;multi=thud&amp;amp;multi=thonk&amp;quot;&lt;/code>&lt;/pre>
</example></examples></method><method name="queryToObject" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="str" type="String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Create an object representing a de-serialized query section of a
URL. Query keys with multiple values are returned in an array.
&lt;/p>
</summary><examples><example>&lt;p>This string:

&lt;/p>
&lt;pre>&lt;code>    &amp;quot;foo=bar&amp;amp;foo=baz&amp;amp;thinger=%20spaces%20=blah&amp;amp;zonk=blarg&amp;amp;&amp;quot;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>results in this object structure:

&lt;/p>
&lt;pre>&lt;code>    {
      foo: [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ],
      thinger: &amp;quot; spaces =blah&amp;quot;,
      zonk: &amp;quot;blarg&amp;quot;
    }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that spaces and other urlencoded entities are correctly
handled.&lt;/p>
</example></examples></method></methods><summary>&lt;p>This module defines query string processing functions.&lt;/p>
</summary></object><object location="dojo/dom-form" type="object"><properties/><methods><method name="fieldToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="inputNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Serialize a form field to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the value encoded in a form field as
as a string or an array of strings. Disabled form elements
and unchecked radio and checkboxes are skipped.  Multi-select
elements are returned as an array of string values.&lt;/p>
</description></method><method name="toObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Serialize a form node to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the values encoded in an HTML form as
string properties in an object which it then returns. Disabled form
elements, buttons, and other non-value form elements are skipped.
Multi-select elements are returned as an array of string values.&lt;/p>
</description><examples><example>&lt;p>This form:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;form id=&amp;quot;test_form&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blah&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;no_value&amp;quot; value=&amp;quot;blah&amp;quot; disabled&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;no_value2&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;select type=&amp;quot;select&amp;quot; multiple name=&amp;quot;multi&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;
      &amp;lt;option value=&amp;quot;blah&amp;quot;&amp;gt;blah&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thud&amp;quot; selected&amp;gt;thud&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thonk&amp;quot; selected&amp;gt;thonk&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields this object structure as the result of a call to
formToObject():

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="toQuery" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns a URL-encoded string representing the form passed as either a
node or string ID identifying the form to serialize&lt;/p>
</summary></method><method name="toJson" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/><parameter name="prettyPrint" type="Boolean" usage="optional"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Create a serialized JSON string from a form node or string
ID identifying the form to serialize&lt;/p>
</summary></method></methods><summary>&lt;p>This module defines form-processing functions.&lt;/p>
</summary></object><object location="dojo/request/watch" type="function"><properties><property name="validCheck" scope="prototype" type="Function" from="dojo/request/watch"><summary>&lt;p>Function used to check if the IO request is still valid. Gets the dfd
object as its only argument.&lt;/p>
</summary></property><property name="ioCheck" scope="prototype" type="Function" from="dojo/request/watch"><summary>&lt;p>Function used to check if basic IO call worked. Gets the dfd
object as its only argument.&lt;/p>
</summary></property><property name="resHandle" scope="prototype" type="Function" from="dojo/request/watch"><summary>&lt;p>Function used to process response. Gets the dfd
object as its only argument.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/watch"><parameters><parameter name="dfd" type="Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></method><method name="cancelAll" scope="normal" type="function" from="dojo/request/watch"><parameters/><return-types/><summary>&lt;p>Cancels all pending IO requests, regardless of IO type&lt;/p>
</summary></method></methods><parameters><parameter name="dfd" type="Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></object><object location="dojo/request/util" type="object"><properties/><methods><method name="deepCopy" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="target" type="undefined" usage="required"/><parameter name="source" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deepCreate" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="source" type="undefined" usage="required"/><parameter name="properties" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deferred" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="response" type="Object" usage="required"><summary>&lt;p>The object used as the value of the request promise.&lt;/p>
</summary></parameter><parameter name="cancel" type="undefined" usage="required"/><parameter name="isValid" type="undefined" usage="required"/><parameter name="isReady" type="undefined" usage="required"/><parameter name="handleResponse" type="undefined" usage="required"/><parameter name="last" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="addCommonMethods" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="provider" type="undefined" usage="required"/><parameter name="methods" type="undefined" usage="required"/></parameters><return-types/></method><method name="parseArgs" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="url" type="undefined" usage="required"/><parameter name="options" type="undefined" usage="required"/><parameter name="skipData" type="undefined" usage="required"/></parameters><return-types><return-type type="object"/></return-types></method><method name="checkStatus" scope="normal" type="function" from="dojo/request/util"><parameters><parameter name="stat" type="undefined" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types></method><method name="notify" scope="normal" type="function" from="dojo/request/notify"><parameters><parameter name="type" type="String" usage="optional"><summary>&lt;p>The event to listen for. Events emitted: &amp;quot;start&amp;quot;, &amp;quot;send&amp;quot;,
&amp;quot;load&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;done&amp;quot;, &amp;quot;stop&amp;quot;.&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="optional"><summary>&lt;p>A callback to be run when an event happens.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A signal object that can be used to cancel the listener.
If remove() is called on this signal object, it will
stop the listener from being executed.</return-description><summary>&lt;p>Register a listener to be notified when an event
in dojo/request happens.&lt;/p>
</summary></method></methods></object><object location="dojo/errors/RequestError" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/errors/RequestError"><parameters/><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/errors/RequestTimeoutError" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/errors/RequestTimeoutError"><parameters/><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/request/xhr" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/xhr"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="__BaseOptions" scope="normal" type="constructor" from="dojo/request/xhr"><parameters/><return-types/></method><method name="__MethodOptions" scope="normal" type="constructor" from="dojo/request/xhr"><parameters/><return-types/></method><method name="__Options" scope="normal" type="constructor" from="dojo/request/xhr"><parameters/><return-types/></method><method name="get" scope="normal" type="function" from="dojo/request/xhr"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP GET request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="post" scope="normal" type="function" from="dojo/request/xhr"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP POST request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="put" scope="normal" type="function" from="dojo/request/xhr"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP PUT request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="del" scope="normal" type="function" from="dojo/request/xhr"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="_create" scope="normal" type="function" from="dojo/request/xhr"><parameters/><return-types><return-type type="instance"/></return-types></method></methods><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/xhr.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></object><object location="dojo/request/handlers" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/handlers"><parameters><parameter name="response" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="register" scope="normal" type="function" from="dojo/request/handlers"><parameters><parameter name="name" type="undefined" usage="required"/><parameter name="handler" type="undefined" usage="required"/></parameters><return-types/></method></methods><parameters><parameter name="response" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></object><object location="dojo/request" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>The URL to request.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send a request using the default transport for the current platform.&lt;/p>
</summary></method><method name="__Promise" scope="normal" type="constructor" from="dojo/request"><parameters/><return-types/></method><method name="__BaseOptions" scope="normal" type="constructor" from="dojo/request"><parameters/><return-types/></method><method name="__MethodOptions" scope="normal" type="constructor" from="dojo/request"><parameters/><return-types/></method><method name="__Options" scope="normal" type="constructor" from="dojo/request"><parameters/><return-types/></method><method name="get" scope="normal" type="function" from="dojo/request"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP GET request using the default transport for the current platform.&lt;/p>
</summary></method><method name="post" scope="normal" type="function" from="dojo/request"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP POST request using the default transport for the current platform.&lt;/p>
</summary></method><method name="put" scope="normal" type="function" from="dojo/request"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP POST request using the default transport for the current platform.&lt;/p>
</summary></method><method name="del" scope="normal" type="function" from="dojo/request"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP DELETE request using the default transport for the current platform.&lt;/p>
</summary></method></methods><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>The URL to request.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send a request using the default transport for the current platform.&lt;/p>
</summary></object><object location="dojo/_base/loader" type="number"><properties/><methods/></object><object location="dojo/_base/query" type="object"><properties/><methods/><summary>&lt;p>Deprecated.   Use dojo/query instead.&lt;/p>
</summary></object><object location="dojo/_firebug/firebug" type="undefined"><properties/><methods/></object><object location="dojo/back" type="object"><properties/><methods><method name="getHash" scope="normal" type="function" from="dojo/back"><parameters/><return-types><return-type type="undefined"/></return-types></method><method name="setHash" scope="normal" type="function" from="dojo/back"><parameters><parameter name="h" type="undefined" usage="required"/></parameters><return-types/></method><method name="goBack" scope="normal" type="function" from="dojo/back"><parameters/><return-types/><summary>&lt;p>private method. Do not call this directly.&lt;/p>
</summary></method><method name="goForward" scope="normal" type="function" from="dojo/back"><parameters/><return-types/><summary>&lt;p>private method. Do not call this directly.&lt;/p>
</summary></method><method name="init" scope="normal" type="function" from="dojo/back"><parameters/><return-types/><summary>&lt;p>Initializes the undo stack. This must be called from a &lt;script>
block that lives inside the &lt;code>&amp;lt;body&amp;gt;&lt;/code> tag to prevent bugs on IE.

&lt;/p>
&lt;p>Only call this method before the page&amp;#39;s DOM is finished loading. Otherwise
it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
in order for this method to work, dojo/back will need to be part of a build layer.&lt;/p>
</summary></method><method name="setInitialState" scope="normal" type="function" from="dojo/back"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>See the addToHistory() function for the list of valid args properties.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the state object and back callback for the very first page
that is loaded.

&lt;/p>
&lt;p>It is recommended that you call this method as part of an event
listener that is registered via dojo/ready.&lt;/p>
</summary></method><method name="addToHistory" scope="normal" type="function" from="dojo/back"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The state object that will be added to the history list.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>back (Function, optional): &lt;p>A function to be called when this state is reached via the user
clicking the back button.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>forward (Function, optional): &lt;p>Upon return to this state from the &amp;quot;back, forward&amp;quot; combination
of navigation steps, this function will be called. Somewhat
analogous to the semantic of an &amp;quot;onRedo&amp;quot; event handler.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>changeUrl (Boolean|String, optional): &lt;p>Boolean indicating whether or not to create a unique hash for
this state. If a string is passed instead, it is used as the
hash.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>adds a state object (args) to the history list.&lt;/p>
</summary><description>&lt;p>To support getting back button notifications, the object
argument should implement a function called either &amp;quot;back&amp;quot;,
&amp;quot;backButton&amp;quot;, or &amp;quot;handle&amp;quot;. The string &amp;quot;back&amp;quot; will be passed as
the first and only argument to this callback.

&lt;/p>
&lt;p>To support getting forward button notifications, the object
argument should implement a function called either &amp;quot;forward&amp;quot;,
&amp;quot;forwardButton&amp;quot;, or &amp;quot;handle&amp;quot;. The string &amp;quot;forward&amp;quot; will be
passed as the first and only argument to this callback.

&lt;/p>
&lt;p>If you want the browser location string to change, define &amp;quot;changeUrl&amp;quot; on the object. If the
value of &amp;quot;changeUrl&amp;quot; is true, then a unique number will be appended to the URL as a fragment
identifier (&lt;a href=&quot;http://some.domain.com/path#uniquenumber&quot;>http://some.domain.com/path#uniquenumber&lt;/a>). If it is any other value that does
not evaluate to false, that value will be used as the fragment identifier. For example,
if changeUrl: &amp;#39;page1&amp;#39;, then the URL will look like: &lt;a href=&quot;http://some.domain.com/path#page1&quot;>http://some.domain.com/path#page1&lt;/a>

&lt;/p>
&lt;p>There are problems with using dojo/back with semantically-named fragment identifiers
(&amp;quot;hash values&amp;quot; on an URL). In most browsers it will be hard for dojo/back to know
distinguish a back from a forward event in those cases. For back/forward support to
work best, the fragment ID should always be a unique value (something using new Date().getTime()
for example). If you want to detect hash changes using semantic fragment IDs, then
consider using dojo/hash instead (in Dojo 1.4+).
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  back.addToHistory({
    back: function(){ console.log(&amp;#39;back pressed&amp;#39;); },
    forward: function(){ console.log(&amp;#39;forward pressed&amp;#39;); },
    changeUrl: true
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_iframeLoaded" scope="normal" type="function" from="dojo/back"><parameters><parameter name="evt" type="undefined" usage="required"/><parameter name="ifrLoc" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>private method. Do not call this directly.&lt;/p>
</summary></method></methods><summary>&lt;p>Browser history management resources&lt;/p>
</summary></object><object location="dojo/behavior" type="instance"><properties><property name="_behaviors" scope="normal" type="object" from="dojo/behavior"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/behavior"><parameters/><return-types/><summary>&lt;p>Deprecated.   dojo/behavior&amp;#39;s functionality can be achieved using event delegation using dojo/on
and on.selector().&lt;/p>
</summary><description>&lt;p>A very simple, lightweight mechanism for applying code to
existing documents, based around &lt;code>dojo/query&lt;/code> (CSS3 selectors) for node selection,
and a simple two-command API: &lt;code>add()&lt;/code> and &lt;code>apply()&lt;/code>;

&lt;/p>
&lt;p>Behaviors apply to a given page, and are registered following the syntax
options described by &lt;code>add()&lt;/code> to match nodes to actions, or &amp;quot;behaviors&amp;quot;.

&lt;/p>
&lt;p>Added behaviors are applied to the current DOM when .apply() is called,
matching only new nodes found since .apply() was last called.&lt;/p>
</description></method><method name="add" scope="normal" type="function" from="dojo/behavior"><parameters><parameter name="behaviorObj" type="Object" usage="required"><summary>&lt;p>The behavior object that will be added to behaviors list. The behaviors
in the list will be applied the next time apply() is called.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add the specified behavior to the list of behaviors, ignoring existing
matches.&lt;/p>
</summary><description>&lt;p>Add the specified behavior to the list of behaviors which will
be applied the next time apply() is called. Calls to add() for
an already existing behavior do not replace the previous rules,
but are instead additive. New nodes which match the rule will
have all add()-ed behaviors applied to them when matched.

&lt;/p>
&lt;p>The &amp;quot;found&amp;quot; method is a generalized handler that&amp;#39;s called as soon
as the node matches the selector. Rules for values that follow also
apply to the &amp;quot;found&amp;quot; key.

&lt;/p>
&lt;p>The &amp;quot;on*&amp;quot; handlers are attached with &lt;code>dojo.connect()&lt;/code>, using the
matching node

&lt;/p>
&lt;p>If the value corresponding to the ID key is a function and not a
list, it&amp;#39;s treated as though it was the value of &amp;quot;found&amp;quot;.

&lt;/p>
&lt;p>dojo/behavior.add() can be called any number of times before
the DOM is ready. &lt;code>dojo/behavior.apply()&lt;/code> is called automatically
by &lt;code>dojo.addOnLoad&lt;/code>, though can be called to re-apply previously added
behaviors anytime the DOM changes.

&lt;/p>
&lt;p>There are a variety of formats permitted in the behaviorObject
&lt;/p>
</description><examples><example>&lt;p>Simple list of properties. &amp;quot;found&amp;quot; is special. &amp;quot;Found&amp;quot; is assumed if
no property object for a given selector, and property is a function.

&lt;/p>
&lt;pre>&lt;code>  behavior.add({
    &amp;quot;#id&amp;quot;: {
      &amp;quot;found&amp;quot;: function(element){
        // node match found
      },
      &amp;quot;onclick&amp;quot;: function(evt){
        // register onclick handler for found node
      }
    },
    &amp;quot;#otherid&amp;quot;: function(element){
      // assumes &amp;quot;found&amp;quot; with this syntax
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>If property is a string, a dojo.publish will be issued on the channel:

&lt;/p>
&lt;pre>&lt;code>  behavior.add({
    // topic.publish() whenever class=&amp;quot;noclick&amp;quot; found on anchors
    &amp;quot;a.noclick&amp;quot;: &amp;quot;/got/newAnchor&amp;quot;,
    &amp;quot;div.wrapper&amp;quot;: {
      &amp;quot;onclick&amp;quot;: &amp;quot;/node/wasClicked&amp;quot;
    }
  });
  topic.subscribe(&amp;quot;/got/newAnchor&amp;quot;, function(node){
    // handle node finding when dojo/behavior.apply() is called,
    // provided a newly matched node is found.
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Scoping can be accomplished by passing an object as a property to
a connection handle (on*):

&lt;/p>
&lt;pre>&lt;code>  behavior.add({
       &amp;quot;#id&amp;quot;: {
        // like calling dojo.hitch(foo,&amp;quot;bar&amp;quot;). execute foo.bar() in scope of foo
        &amp;quot;onmouseenter&amp;quot;: { targetObj: foo, targetFunc: &amp;quot;bar&amp;quot; },
        &amp;quot;onmouseleave&amp;quot;: { targetObj: foo, targetFunc: &amp;quot;baz&amp;quot; }
      }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Behaviors match on CSS3 Selectors, powered by dojo/query. Example selectors:

&lt;/p>
&lt;pre>&lt;code>  behavior.add({
    // match all direct descendants
    &amp;quot;#id4 &amp;gt; *&amp;quot;: function(element){
      // ...
    },

    // match the first child node that&amp;#39;s an element
    &amp;quot;#id4 &amp;gt; :first-child&amp;quot;: { ... },

    // match the last child node that&amp;#39;s an element
    &amp;quot;#id4 &amp;gt; :last-child&amp;quot;:  { ... },

    // all elements of type tagname
    &amp;quot;tagname&amp;quot;: {
      // ...
    },

    &amp;quot;tagname1 tagname2 tagname3&amp;quot;: {
      // ...
    },

    &amp;quot;.classname&amp;quot;: {
      // ...
    },

    &amp;quot;tagname.classname&amp;quot;: {
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="apply" scope="normal" type="function" from="dojo/behavior"><parameters/><return-types/><summary>&lt;p>Applies all currently registered behaviors to the document.
&lt;/p>
</summary><description>&lt;p>Applies all currently registered behaviors to the document,
taking care to ensure that only incremental updates are made
since the last time add() or apply() were called.

&lt;/p>
&lt;p>If new matching nodes have been added, all rules in a behavior will be
applied to that node. For previously matched nodes, only
behaviors which have been added since the last call to apply()
will be added to the nodes.

&lt;/p>
&lt;p>apply() is called once automatically by &lt;code>dojo.addOnLoad&lt;/code>, so
registering behaviors with &lt;code>dojo/behavior.add()&lt;/code> before the DOM is
ready is acceptable, provided the dojo.behavior module is ready.

&lt;/p>
&lt;p>Calling appy() manually after manipulating the DOM is required
to rescan the DOM and apply newly .add()ed behaviors, or to match
nodes that match existing behaviors when those nodes are added to
the DOM.
&lt;/p>
</description></method></methods><parameters/><return-types/><summary>&lt;p>Deprecated.   dojo/behavior&amp;#39;s functionality can be achieved using event delegation using dojo/on
and on.selector().&lt;/p>
</summary><description>&lt;p>A very simple, lightweight mechanism for applying code to
existing documents, based around &lt;code>dojo/query&lt;/code> (CSS3 selectors) for node selection,
and a simple two-command API: &lt;code>add()&lt;/code> and &lt;code>apply()&lt;/code>;

&lt;/p>
&lt;p>Behaviors apply to a given page, and are registered following the syntax
options described by &lt;code>add()&lt;/code> to match nodes to actions, or &amp;quot;behaviors&amp;quot;.

&lt;/p>
&lt;p>Added behaviors are applied to the current DOM when .apply() is called,
matching only new nodes found since .apply() was last called.&lt;/p>
</description></object><object location="dojo/cache" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/text"><parameters><parameter name="module" type="String||Object" usage="required"><summary>&lt;p>dojo/cldr/supplemental&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="required"><summary>&lt;p>The rest of the path to append to the path derived from the module argument. If
module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.&lt;/p>
</summary></parameter><parameter name="value" type="String||Object" usage="optional"><summary>&lt;p>If a String, the value to use in the cache for the module/url combination.
If an Object, it can have two properties: value and sanitize. The value property
should be the value to use in the cache, and sanitize can be set to true or false,
to indicate if XML declarations should be removed from the value and if the HTML
inside a body tag in the value should be extracted as the real value. The value argument
or the value property on the value argument are usually only used by the build system
as it inlines cache content.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A getter and setter for storing the string content associated with the
module and url arguments.&lt;/p>
</summary><description>&lt;p>If module is a string that contains slashes, then it is interpretted as a fully
resolved path (typically a result returned by require.toUrl), and url should not be
provided. This is the preferred signature. If module is a string that does not
contain slashes, then url must also be provided and module and url are used to
call &lt;code>dojo.moduleUrl()&lt;/code> to generate a module URL. This signature is deprecated.
If value is specified, the cache value for the moduleUrl will be set to
that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
in its internal cache and return that cached value for the URL. To clear
a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
the URL contents, only modules on the same domain of the page can use this capability.
The build system can inline the cache values though, to allow for xdomain hosting.&lt;/p>
</description><examples><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&amp;quot;cache&amp;quot;] style
of call is used to avoid an issue with the build system erroneously trying to intern
this example. To get the build system to intern your dojo.cache calls, use the
&amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot; that will be
 //the value for the text variable.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
(the dojo[&amp;quot;cache&amp;quot;] style of call is used to avoid an issue with the build system
erroneously trying to intern this example. To get the build system to intern your
dojo.cache calls, use the &amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;, {sanitize: true});&lt;/code>&lt;/pre>
</example><example>&lt;p>Same example as previous, but demonstrates how an object can be passed in as
the first argument, then the value argument can then be the second argument.&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](new dojo._Url(&amp;quot;my/module/template.html&amp;quot;), {sanitize: true});&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="module" type="String||Object" usage="required"><summary>&lt;p>dojo/cldr/supplemental&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="required"><summary>&lt;p>The rest of the path to append to the path derived from the module argument. If
module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.&lt;/p>
</summary></parameter><parameter name="value" type="String||Object" usage="optional"><summary>&lt;p>If a String, the value to use in the cache for the module/url combination.
If an Object, it can have two properties: value and sanitize. The value property
should be the value to use in the cache, and sanitize can be set to true or false,
to indicate if XML declarations should be removed from the value and if the HTML
inside a body tag in the value should be extracted as the real value. The value argument
or the value property on the value argument are usually only used by the build system
as it inlines cache content.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A getter and setter for storing the string content associated with the
module and url arguments.&lt;/p>
</summary><description>&lt;p>If module is a string that contains slashes, then it is interpretted as a fully
resolved path (typically a result returned by require.toUrl), and url should not be
provided. This is the preferred signature. If module is a string that does not
contain slashes, then url must also be provided and module and url are used to
call &lt;code>dojo.moduleUrl()&lt;/code> to generate a module URL. This signature is deprecated.
If value is specified, the cache value for the moduleUrl will be set to
that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
in its internal cache and return that cached value for the URL. To clear
a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
the URL contents, only modules on the same domain of the page can use this capability.
The build system can inline the cache values though, to allow for xdomain hosting.&lt;/p>
</description><examples><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&amp;quot;cache&amp;quot;] style
of call is used to avoid an issue with the build system erroneously trying to intern
this example. To get the build system to intern your dojo.cache calls, use the
&amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot; that will be
 //the value for the text variable.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
(the dojo[&amp;quot;cache&amp;quot;] style of call is used to avoid an issue with the build system
erroneously trying to intern this example. To get the build system to intern your
dojo.cache calls, use the &amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;, {sanitize: true});&lt;/code>&lt;/pre>
</example><example>&lt;p>Same example as previous, but demonstrates how an object can be passed in as
the first argument, then the value argument can then be the second argument.&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](new dojo._Url(&amp;quot;my/module/template.html&amp;quot;), {sanitize: true});&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/text" type="object"><properties><property name="dynamic" scope="normal" type="boolean" from="dojo/text"/></properties><methods><method name="normalize" scope="normal" type="function" from="dojo/text"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="toAbsMid" type="undefined" usage="required"/></parameters><return-types><return-type type="string"/></return-types></method><method name="load" scope="normal" type="function" from="dojo/text"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>Path to the resource.&lt;/p>
</summary></parameter><parameter name="require" type="Function" usage="required"><summary>&lt;p>Object that include the function toUrl with given id returns a valid URL from which to load the text.&lt;/p>
</summary></parameter><parameter name="load" type="Function" usage="required"><summary>&lt;p>Callback function which will be called, when the loading finished.&lt;/p>
</summary></parameter></parameters><return-types/></method></methods><summary>&lt;p>This module implements the dojo/text! plugin and the dojo.cache API.&lt;/p>
</summary><description>&lt;p>We choose to include our own plugin to leverage functionality already contained in dojo
and thereby reduce the size of the plugin compared to various foreign loader implementations.
Also, this allows foreign AMD loaders to be used without their plugins.

&lt;/p>
&lt;p>CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
loader. This feature is outside the scope of the CommonJS plugins specification.&lt;/p>
</description></object><object location="dojo/cldr/monetary" type="object"><properties/><methods><method name="getData" scope="normal" type="function" from="dojo/cldr/monetary"><parameters><parameter name="code" type="String" usage="required"><summary>&lt;p>an &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_4217&quot;>ISO 4217&lt;/a> currency code&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.&lt;/p>
</summary></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/cldr/supplemental" type="object"><properties/><methods><method name="getFirstDayOfWeek" scope="normal" type="function" from="dojo/cldr/supplemental"><parameters><parameter name="locale" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Returns a zero-based index for first day of the week&lt;/p>
</summary><description>&lt;p>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
e.g. Sunday (returns 0), or Monday (returns 1)&lt;/p>
</description></method><method name="_region" scope="normal" type="function" from="dojo/cldr/supplemental"><parameters><parameter name="locale" type="String" usage="optional"/></parameters><return-types/></method><method name="getWeekend" scope="normal" type="function" from="dojo/cldr/supplemental"><parameters><parameter name="locale" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Returns a hash containing the start and end days of the weekend&lt;/p>
</summary><description>&lt;p>Returns a hash containing the start and end days of the weekend according to local custom using locale,
or by default in the user&amp;#39;s locale.
e.g. {start:6, end:0}&lt;/p>
</description></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/i18n" type="object"><properties><property name="unitTests" scope="normal" type="Array" from="dojo/i18n"/><property name="dynamic" scope="normal" type="boolean" from="dojo/i18n"/><property name="cache" scope="normal" type="object" from="dojo/i18n"/></properties><methods><method name="normalizeLocale" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="locale" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_preloadLocalizations" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="bundlePrefix" type="String" usage="required"/><parameter name="localesGenerated" type="Array" usage="required"/><parameter name="guaranteedAmdFormat" type="boolean" usage="optional"/><parameter name="contextRequire" type="function" usage="optional"/></parameters><return-types/><summary>&lt;p>Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)&lt;/p>
</summary><description>&lt;p>Only called by built layer files. The entire locale hierarchy is loaded. For example,
if locale==&amp;quot;ab-cd&amp;quot;, then ROOT, &amp;quot;ab&amp;quot;, and &amp;quot;ab-cd&amp;quot; are loaded. This is different than v1.6-
in that the v1.6- would only load ab-cd...which was &lt;em>always&lt;/em> flattened.

&lt;/p>
&lt;p>If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
and the extra possible extra transaction.&lt;/p>
</description></method><method name="getLocalization" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="moduleName" type="undefined" usage="required"/><parameter name="bundleName" type="undefined" usage="required"/><parameter name="locale" type="undefined" usage="required"/></parameters><return-types/></method><method name="normalize" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="toAbsMid" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>id may be relative.
preload has form &lt;code>*preload*&amp;lt;path&amp;gt;/nls/&amp;lt;module&amp;gt;*&amp;lt;flattened locales&amp;gt;&lt;/code> and
therefore never looks like a relative&lt;/p>
</summary></method><method name="load" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="require" type="undefined" usage="required"/><parameter name="load" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>id is in one of the following formats

&lt;/p>
&lt;ol>
&lt;li>&lt;p>&lt;path>/nls/&lt;bundle>
=&amp;gt; load the bundle, localized to config.locale; load all bundles localized to
config.extraLocale (if any); return the loaded bundle localized to config.locale.&lt;/p>
&lt;/li>
&lt;li>&lt;p>&lt;path>/nls/&lt;locale>/&lt;bundle>
=&amp;gt; load then return the bundle localized to &lt;locale>&lt;/p>
&lt;/li>
&lt;li>&lt;p>&lt;em>preload&lt;/em>&lt;path>/nls/&lt;module>*&lt;JSON array of available locales>
=&amp;gt; for config.locale and all config.extraLocale, load all bundles found
in the best-matching bundle rollup. A value of 1 is returned, which
is meaningless other than to say the plugin is executing the requested
preloads&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>In cases 1 and 2, &lt;path> is always normalized to an absolute module id upon entry; see
normalize. In case 3, it &lt;path> is assumed to be absolute; this is arranged by the builder.

&lt;/p>
&lt;p>To load a bundle means to insert the bundle into the plugin&amp;#39;s cache and publish the bundle
value to the loader. Given &lt;path>, &lt;bundle>, and a particular &lt;locale>, the cache key

&lt;/p>
&lt;p>&lt;path>/nls/&lt;bundle>/&lt;locale>

&lt;/p>
&lt;p>will hold the value. Similarly, then plugin will publish this value to the loader by

&lt;/p>
&lt;p>define(&amp;quot;&lt;path>/nls/&lt;bundle>/&lt;locale>&amp;quot;, &lt;bundle-value>);

&lt;/p>
&lt;p>Given this algorithm, other machinery can provide fast load paths be preplacing
values in the plugin&amp;#39;s cache, which is public. When a load is demanded the
cache is inspected before starting any loading. Explicitly placing values in the plugin
cache is an advanced/experimental feature that should not be needed; use at your own risk.

&lt;/p>
&lt;p>For the normal AMD algorithm, the root bundle is loaded first, which instructs the
plugin what additional localized bundles are required for a particular locale. These
additional locales are loaded and a mix of the root and each progressively-specific
locale is returned. For example:

&lt;/p>
&lt;ol>
&lt;li>&lt;p>The client demands &amp;quot;dojo/i18n!some/path/nls/someBundle&lt;/p>
&lt;/li>
&lt;li>&lt;p>The loader demands load(some/path/nls/someBundle)&lt;/p>
&lt;/li>
&lt;li>&lt;p>This plugin require&amp;#39;s &amp;quot;some/path/nls/someBundle&amp;quot;, which is the root bundle.&lt;/p>
&lt;/li>
&lt;li>&lt;p>Assuming config.locale is &amp;quot;ab-cd-ef&amp;quot; and the root bundle indicates that localizations
are available for &amp;quot;ab&amp;quot; and &amp;quot;ab-cd-ef&amp;quot; (note the missing &amp;quot;ab-cd&amp;quot;, then the plugin
requires &amp;quot;some/path/nls/ab/someBundle&amp;quot; and &amp;quot;some/path/nls/ab-cd-ef/someBundle&amp;quot;&lt;/p>
&lt;/li>
&lt;li>&lt;p>Upon receiving all required bundles, the plugin constructs the value of the bundle
ab-cd-ef as...&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>mixin(mixin(mixin({}, require(&amp;quot;some/path/nls/someBundle&amp;quot;),
require(&amp;quot;some/path/nls/ab/someBundle&amp;quot;)),
require(&amp;quot;some/path/nls/ab-cd-ef/someBundle&amp;quot;));

&lt;/p>
&lt;p>This value is inserted into the cache and published to the loader at the
key/module-id some/path/nls/someBundle/ab-cd-ef.

&lt;/p>
&lt;p>The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
(further preload requests will be serviced) until all ongoing preloading has completed.

&lt;/p>
&lt;p>The preload signature instructs the plugin that a special rollup module is available that contains
one or more flattened, localized bundles. The JSON array of available locales indicates which locales
are available. Here is an example:

&lt;/p>
&lt;p>preload&lt;em>some/path/nls/someModule&lt;/em>[&amp;quot;root&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;ab-cd-ef&amp;quot;]

&lt;/p>
&lt;p>This indicates the following rollup modules are available:

&lt;/p>
&lt;p>some/path/nls/someModule_ROOT
some/path/nls/someModule_ab
some/path/nls/someModule_ab-cd-ef

&lt;/p>
&lt;p>Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
For example, assume someModule contained the bundles some/bundle/path/someBundle and
some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:

&lt;/p>
&lt;p>define({
some/bundle/path/someBundle:&lt;value of someBundle, flattened with respect to locale ab>,
some/bundle/path/someOtherBundle:&lt;value of someOtherBundle, flattened with respect to locale ab>,
});

&lt;/p>
&lt;p>E.g., given this design, preloading for locale==&amp;quot;ab&amp;quot; can execute the following algorithm:

&lt;/p>
&lt;p>require([&amp;quot;some/path/nls/someModule_ab&amp;quot;], function(rollup){
for(var p in rollup){
var id = p + &amp;quot;/ab&amp;quot;,
cache[id] = rollup[p];
define(id, rollup[p]);
}
});

&lt;/p>
&lt;p>Similarly, if &amp;quot;ab-cd&amp;quot; is requested, the algorithm can determine that &amp;quot;ab&amp;quot; is the best available and
load accordingly.

&lt;/p>
&lt;p>The builder will write such rollups for every layer if a non-empty localeList  profile property is
provided. Further, the builder will include the following cache entry in the cache associated with
any layer.

&lt;/p>
&lt;p>&amp;quot;&lt;em>now&amp;quot;:function(r){r([&amp;#39;dojo/i18n!&lt;/em>preload&lt;em>&lt;path>/nls/&lt;module>&lt;/em>&lt;JSON array of available locales>&amp;#39;]);}

&lt;/p>
&lt;p>The *now special cache module instructs the loader to apply the provided function to context-require
with respect to the particular layer being defined. This causes the plugin to hold all normal service
requests until all preloading is complete.

&lt;/p>
&lt;p>Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
where the target locale has a single segment and a layer depends on a single bundle:

&lt;/p>
&lt;p>Without Preloads:

&lt;/p>
&lt;ol>
&lt;li>Layer loads root bundle.&lt;/li>
&lt;li>bundle is demanded; plugin loads single localized bundle.&lt;/li>
&lt;/ol>
&lt;p>With Preloads:

&lt;/p>
&lt;ol>
&lt;li>Layer causes preloading of target bundle.&lt;/li>
&lt;li>bundle is demanded; service is delayed until preloading complete; bundle is returned.&lt;/li>
&lt;/ol>
&lt;p>In each case a single transaction is required to load the target bundle. In cases where multiple bundles
are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
the normal path requires an additional transaction for each additional bundle/locale-segment. However all
of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.&lt;/p>
</summary></method></methods><summary>&lt;p>This module implements the dojo/i18n! plugin and the v1.6- i18n API&lt;/p>
</summary><description>&lt;p>We choose to include our own plugin to leverage functionality already contained in dojo
and thereby reduce the size of the plugin compared to various loader implementations. Also, this
allows foreign AMD loaders to be used without their plugins.&lt;/p>
</description></object><object location="dojo/colors" type="object"><properties/><methods/><summary>&lt;p>Color utilities, extending Base dojo.Color&lt;/p>
</summary></object><object location="dojo/cookie" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/cookie"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of the cookie&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>Value for the cookie&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="optional"><summary>&lt;p>Properties for the cookie&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>expires (Date|String|Number, optional): &lt;p>If a number, the number of days from today at which the cookie
will expire. If a date, the date past which the cookie will expire.
If expires is in the past, the cookie will be deleted.
If expires is omitted or is 0, the cookie will expire when the browser closes.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>path (String, optional): &lt;p>The path to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>domain (String, optional): &lt;p>The domain to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>secure (Boolean, optional): &lt;p>Whether to only send the cookie on secure connections&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Get or set a cookie.&lt;/p>
</summary><description>&lt;p>If one argument is passed, returns the value of the cookie
For two or more arguments, acts as a setter.&lt;/p>
</description><examples><example>&lt;p>set a cookie with the JSON-serialized contents of an object which
will expire 5 days from now:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    cookie(&amp;quot;configObj&amp;quot;, json.stringify(config, {expires: 5 }));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>de-serialize a cookie back into a JavaScript object:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    config = json.parse(cookie(&amp;quot;configObj&amp;quot;));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>delete a cookie:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;], function(cookie){
    cookie(&amp;quot;configObj&amp;quot;, null, {expires: -1});
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="isSupported" scope="normal" type="function" from="dojo/cookie"><parameters/><return-types/><summary>&lt;p>Use to determine if the current browser supports cookies or not.

&lt;/p>
&lt;p>Returns true if user allows cookies.
Returns false if user doesn&amp;#39;t allow cookies.&lt;/p>
</summary></method></methods><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of the cookie&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>Value for the cookie&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="optional"><summary>&lt;p>Properties for the cookie&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>expires (Date|String|Number, optional): &lt;p>If a number, the number of days from today at which the cookie
will expire. If a date, the date past which the cookie will expire.
If expires is in the past, the cookie will be deleted.
If expires is omitted or is 0, the cookie will expire when the browser closes.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>path (String, optional): &lt;p>The path to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>domain (String, optional): &lt;p>The domain to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>secure (Boolean, optional): &lt;p>Whether to only send the cookie on secure connections&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Get or set a cookie.&lt;/p>
</summary><description>&lt;p>If one argument is passed, returns the value of the cookie
For two or more arguments, acts as a setter.&lt;/p>
</description><examples><example>&lt;p>set a cookie with the JSON-serialized contents of an object which
will expire 5 days from now:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    cookie(&amp;quot;configObj&amp;quot;, json.stringify(config, {expires: 5 }));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>de-serialize a cookie back into a JavaScript object:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    config = json.parse(cookie(&amp;quot;configObj&amp;quot;));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>delete a cookie:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;], function(cookie){
    cookie(&amp;quot;configObj&amp;quot;, null, {expires: -1});
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/regexp" type="object"><properties/><methods><method name="escapeString" scope="normal" type="function" from="dojo/regexp"><parameters><parameter name="str" type="String" usage="required"/><parameter name="except" type="String" usage="optional"><summary>&lt;p>a String with special characters to be left unescaped&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Adds escape sequences for special characters in regular expressions&lt;/p>
</summary></method><method name="buildGroupRE" scope="normal" type="function" from="dojo/regexp"><parameters><parameter name="arr" type="Object|Array" usage="required"><summary>&lt;p>A single value or an array of values.&lt;/p>
</summary></parameter><parameter name="re" type="Function" usage="required"><summary>&lt;p>A function. Takes one parameter and converts it to a regular
expression.&lt;/p>
</summary></parameter><parameter name="nonCapture" type="Boolean" usage="optional"><summary>&lt;p>If true, uses non-capturing match, otherwise matches are retained
by regular expression. Defaults to false&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Builds a regular expression that groups subexpressions&lt;/p>
</summary><description>&lt;p>A utility function used by some of the RE generators. The
subexpressions are constructed by the function, re, in the second
parameter.  re builds one subexpression for each elem in the array
a, in the first parameter. Returns a string for a regular
expression that groups all the subexpressions.&lt;/p>
</description></method><method name="group" scope="normal" type="function" from="dojo/regexp"><parameters><parameter name="expression" type="String" usage="required"/><parameter name="nonCapture" type="Boolean" usage="optional"><summary>&lt;p>If true, uses non-capturing match, otherwise matches are retained
by regular expression.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds group match to expression&lt;/p>
</summary></method></methods><summary>&lt;p>Regular expressions and Builder resources&lt;/p>
</summary></object><object location="dojo/currency" type="object"><properties/><methods><method name="_mixInDefaults" scope="normal" type="function" from="dojo/currency"><parameters><parameter name="options" type="undefined" usage="required"/></parameters><return-types/></method><method name="__FormatOptions" scope="normal" type="constructor" from="dojo/currency"><parameters/><return-types/></method><method name="format" scope="normal" type="function" from="dojo/currency"><parameters><parameter name="value" type="Number" usage="required"><summary>&lt;p>the number to be formatted.&lt;/p>
</summary></parameter><parameter name="options" type="__FormatOptions" usage="optional"/></parameters><return-types/><summary>&lt;p>Format a Number as a currency, using locale-specific settings
&lt;/p>
</summary><description>&lt;p>Create a string from a Number using a known, localized pattern.
&lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Elements&quot;>Formatting patterns&lt;/a>
appropriate to the locale are chosen from the &lt;a href=&quot;http://unicode.org/cldr&quot;>CLDR&lt;/a>
as well as the appropriate symbols and delimiters and number of decimal places.
&lt;/p>
</description></method><method name="regexp" scope="normal" type="function" from="dojo/currency"><parameters><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>type (String, optional): &lt;p>choose a format type based on the locale from the following:
decimal, scientific (not yet supported), percent, currency. decimal by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean, optional): &lt;p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number|String, optional): &lt;p>number of decimal places to accept: Infinity, a positive number, or
a range &amp;quot;n,m&amp;quot;.  Defined by pattern or Infinity if pattern not provided.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/></method><method name="__ParseOptions" scope="normal" type="constructor" from="dojo/currency"><parameters/><return-types/></method><method name="parse" scope="normal" type="function" from="dojo/currency"><parameters><parameter name="expression" type="String" usage="required"/><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>type (String, optional): &lt;p>Should not be set.  Value is assumed to be currency.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>currency (String, optional): &lt;p>an &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_4217&quot;>ISO4217&lt;/a> currency code, a three letter sequence like &amp;quot;USD&amp;quot;.
For use with dojo.currency only.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>symbol (String, optional): &lt;p>localized currency symbol. The default will be looked up in table of supported currencies in &lt;code>dojo.cldr&lt;/code>
A &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_4217&quot;>ISO4217&lt;/a> currency code will be used if not found.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number, optional): &lt;p>fixed number of decimal places to accept.  The default is determined based on which currency is used.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fractional (Boolean|Array, optional): &lt;p>Whether to include the fractional portion, where the number of decimal places are implied by the currency
or explicit &amp;#39;places&amp;#39; parameter.  The value [true,false] makes the fractional portion optional.
By default for currencies, it the fractional portion is optional.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.  Literal characters in patterns are not supported.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean, optional): &lt;p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/></method></methods><summary>&lt;p>localized formatting and parsing routines for currencies&lt;/p>
</summary><description>&lt;p>extends dojo.number to provide culturally-appropriate formatting of values
in various world currencies, including use of a currency symbol.  The currencies are specified
by a three-letter international symbol in all uppercase, and support for the currencies is
provided by the data in &lt;code>dojo.cldr&lt;/code>.  The scripts generating dojo.cldr specify which
currency support is included.  A fixed number of decimal places is determined based
on the currency type and is not determined by the &amp;#39;pattern&amp;#39; argument.  The fractional
portion is optional, by default, and variable length decimals are not supported.&lt;/p>
</description></object><object location="dojo/number" type="object"><properties><property name="_numberPatternRE" scope="normal" type="RegExp" from="dojo/number"/></properties><methods><method name="__FormatOptions" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="format" scope="normal" type="function" from="dojo/number"><parameters><parameter name="value" type="Number" usage="required"><summary>&lt;p>the number to be formatted&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.  Literal characters in patterns are not supported.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>type (String, optional): &lt;p>choose a format type based on the locale from the following:
decimal, scientific (not yet supported), percent, currency. decimal by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number, optional): &lt;p>fixed number of decimal places to show.  This overrides any
information in the provided pattern.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>round (Number, optional): &lt;p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
means do not round.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fractional (Boolean, optional): &lt;p>If false, show no decimal places, overriding places and pattern settings.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Format a Number as a String, using locale-specific settings&lt;/p>
</summary><description>&lt;p>Create a string from a Number using a known localized pattern.
Formatting patterns appropriate to the locale are chosen from the
&lt;a href=&quot;http://unicode.org/cldr&quot;>Common Locale Data Repository&lt;/a> as well as the appropriate symbols and
delimiters.
If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.&lt;/p>
</description></method><method name="_applyPattern" scope="normal" type="function" from="dojo/number"><parameters><parameter name="value" type="Number" usage="required"><summary>&lt;p>the number to be formatted.&lt;/p>
</summary></parameter><parameter name="pattern" type="String" usage="required"><summary>&lt;p>a pattern string as described by
&lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>unicode.org TR35&lt;/a>&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>_applyPattern is usually called via &lt;code>dojo/number.format()&lt;/code> which
populates an extra property in the options parameter, &amp;quot;customs&amp;quot;.
The customs object specifies group and decimal parameters if set.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.  Literal characters in patterns are not supported.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>type (String, optional): &lt;p>choose a format type based on the locale from the following:
decimal, scientific (not yet supported), percent, currency. decimal by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number, optional): &lt;p>fixed number of decimal places to show.  This overrides any
information in the provided pattern.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>round (Number, optional): &lt;p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
means do not round.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fractional (Boolean, optional): &lt;p>If false, show no decimal places, overriding places and pattern settings.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Apply pattern to format value as a string using options. Gives no
consideration to local customs.&lt;/p>
</summary></method><method name="round" scope="normal" type="function" from="dojo/number"><parameters><parameter name="value" type="Number" usage="required"><summary>&lt;p>The number to round&lt;/p>
</summary></parameter><parameter name="places" type="Number" usage="optional"><summary>&lt;p>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
Must be non-negative.&lt;/p>
</summary></parameter><parameter name="increment" type="Number" usage="optional"><summary>&lt;p>Rounds next place to nearest value of increment/10.  10 by default.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>Rounds to the nearest value with the given number of decimal places, away from zero&lt;/p>
</summary><description>&lt;p>Rounds to the nearest value with the given number of decimal places, away from zero if equal.
Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
fractional increments also, such as the nearest quarter.
NOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  &amp;gt;&amp;gt;&amp;gt; number.round(-0.5)
  -1
  &amp;gt;&amp;gt;&amp;gt; number.round(162.295, 2)
  162.29  // note floating point error.  Should be 162.3
  &amp;gt;&amp;gt;&amp;gt; number.round(10.71, 0, 2.5)
  10.75&lt;/code>&lt;/pre>
</example></examples></method><method name="__FormatAbsoluteOptions" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="_formatAbsolute" scope="normal" type="function" from="dojo/number"><parameters><parameter name="value" type="Number" usage="required"><summary>&lt;p>the number to be formatted, ignores sign&lt;/p>
</summary></parameter><parameter name="pattern" type="String" usage="required"><summary>&lt;p>the number portion of a pattern (e.g. &lt;code>#,##0.00&lt;/code>)&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>decimal (String, optional): &lt;p>the decimal separator&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>group (String, optional): &lt;p>the group separator&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number|String, optional): &lt;p>number of decimal places.  the range &amp;quot;n,m&amp;quot; will format to m places.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>round (Number, optional): &lt;p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
means don&amp;#39;t round.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Apply numeric pattern to absolute value using options. Gives no
consideration to local customs.&lt;/p>
</summary></method><method name="__RegexpOptions" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="regexp" scope="normal" type="function" from="dojo/number"><parameters><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>type (String, optional): &lt;p>choose a format type based on the locale from the following:
decimal, scientific (not yet supported), percent, currency. decimal by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean, optional): &lt;p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>places (Number|String, optional): &lt;p>number of decimal places to accept: Infinity, a positive number, or
a range &amp;quot;n,m&amp;quot;.  Defined by pattern or Infinity if pattern not provided.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Builds the regular needed to parse a number&lt;/p>
</summary><description>&lt;p>Returns regular expression with positive and negative match, group
and decimal separators&lt;/p>
</description></method><method name="_parseInfo" scope="normal" type="function" from="dojo/number"><parameters><parameter name="options" type="Object" usage="optional"/></parameters><return-types/></method><method name="__ParseOptions" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="parse" scope="normal" type="function" from="dojo/number"><parameters><parameter name="expression" type="String" usage="required"><summary>&lt;p>A string representation of a Number&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>pattern (String, optional): &lt;p>override &lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>formatting pattern&lt;/a>
with this string.  Default value is based on locale.  Overriding this property will defeat
localization.  Literal characters in patterns are not supported.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>type (String, optional): &lt;p>choose a format type based on the locale from the following:
decimal, scientific (not yet supported), percent, currency. decimal by default.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String, optional): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean, optional): &lt;p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fractional (Boolean|Array, optional): &lt;p>Whether to include the fractional portion, where the number of decimal places are implied by pattern
or explicit &amp;#39;places&amp;#39; parameter.  The value [true,false] makes the fractional portion optional.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Convert a properly formatted string to a primitive Number, using
locale-specific settings.&lt;/p>
</summary><description>&lt;p>Create a Number from a string using a known localized pattern.
Formatting patterns are chosen appropriate to the locale
and follow the syntax described by
&lt;a href=&quot;http://www.unicode.org/reports/tr35/#Number_Format_Patterns&quot;>unicode.org TR35&lt;/a>
Note that literal characters in patterns are not supported.&lt;/p>
</description></method><method name="__RealNumberRegexpFlags" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="_realNumberRegexp" scope="normal" type="function" from="dojo/number"><parameters><parameter name="flags" type="__RealNumberRegexpFlags" usage="optional"/></parameters><return-types/><summary>&lt;p>Builds a regular expression to match a real number in exponential
notation&lt;/p>
</summary></method><method name="__IntegerRegexpFlags" scope="normal" type="constructor" from="dojo/number"><parameters/><return-types/></method><method name="_integerRegexp" scope="normal" type="function" from="dojo/number"><parameters><parameter name="flags" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>signed (Boolean, optional): &lt;p>The leading plus-or-minus sign. Can be true, false, or &lt;code>[true,false]&lt;/code>.
Default is &lt;code>[true, false]&lt;/code>, (i.e. will match if it is signed
or unsigned).&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>separator (String, optional): &lt;p>The character used as the thousands separator. Default is no
separator. For more than one symbol use an array, e.g. &lt;code>[&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;]&lt;/code>,
makes &amp;#39;,&amp;#39; optional.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>groupSize (Number, optional): &lt;p>group size between separators&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>groupSize2 (Number, optional): &lt;p>second grouping, where separators 2..n have a different interval than the first separator (for India)&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Builds a regular expression that matches an integer&lt;/p>
</summary></method></methods><summary>&lt;p>localized formatting and parsing routines for Number&lt;/p>
</summary></object><object location="dojo/string" type="object"><properties/><methods><method name="rep" scope="normal" type="function" from="dojo/string"><parameters><parameter name="str" type="String" usage="required"><summary>&lt;p>the string to replicate&lt;/p>
</summary></parameter><parameter name="num" type="Integer" usage="required"><summary>&lt;p>number of times to replicate the string&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Efficiently replicate a string &lt;code>n&lt;/code> times.&lt;/p>
</summary></method><method name="pad" scope="normal" type="function" from="dojo/string"><parameters><parameter name="text" type="String" usage="required"><summary>&lt;p>the string to pad&lt;/p>
</summary></parameter><parameter name="size" type="Integer" usage="required"><summary>&lt;p>length to provide padding&lt;/p>
</summary></parameter><parameter name="ch" type="String" usage="optional"><summary>&lt;p>character to pad, defaults to &amp;#39;0&amp;#39;&lt;/p>
</summary></parameter><parameter name="end" type="Boolean" usage="optional"><summary>&lt;p>adds padding at the end if true, otherwise pads at start&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Pad a string to guarantee that it is at least &lt;code>size&lt;/code> length by
filling with the character &lt;code>ch&lt;/code> at either the start or end of the
string. Pads at the start, by default.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  // Fill the string to length 10 with &amp;quot;+&amp;quot; characters on the right.  Yields &amp;quot;Dojo++++++&amp;quot;.
  string.pad(&amp;quot;Dojo&amp;quot;, 10, &amp;quot;+&amp;quot;, true);&lt;/code>&lt;/pre>
</example></examples></method><method name="substitute" scope="normal" type="function" from="dojo/string"><parameters><parameter name="template" type="String" usage="required"><summary>&lt;p>a string with expressions in the form &lt;code>${key}&lt;/code> to be replaced or
&lt;code>${key:format}&lt;/code> which specifies a format function. keys are case-sensitive.&lt;/p>
</summary></parameter><parameter name="map" type="Object|Array" usage="required"><summary>&lt;p>hash to search for substitutions&lt;/p>
</summary></parameter><parameter name="transform" type="Function" usage="optional"><summary>&lt;p>a function to process all parameters before substitution takes
place, e.g. mylib.encodeXML&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>where to look for optional format function; default to the global
namespace&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Performs parameterized substitutions on a string. Throws an
exception if any parameter is unmatched.&lt;/p>
</summary><examples><example>&lt;p>Substitutes two expressions in a string from an Array or Object&lt;/p>
&lt;pre>&lt;code>  // returns &amp;quot;File &amp;#39;foo.html&amp;#39; is not found in directory &amp;#39;/temp&amp;#39;.&amp;quot;
  // by providing substitution data in an Array
  string.substitute(
    &amp;quot;File &amp;#39;${0}&amp;#39; is not found in directory &amp;#39;${1}&amp;#39;.&amp;quot;,
    [&amp;quot;foo.html&amp;quot;,&amp;quot;/temp&amp;quot;]
  );

  // also returns &amp;quot;File &amp;#39;foo.html&amp;#39; is not found in directory &amp;#39;/temp&amp;#39;.&amp;quot;
  // but provides substitution data in an Object structure.  Dotted
  // notation may be used to traverse the structure.
  string.substitute(
    &amp;quot;File &amp;#39;${name}&amp;#39; is not found in directory &amp;#39;${info.dir}&amp;#39;.&amp;quot;,
    { name: &amp;quot;foo.html&amp;quot;, info: { dir: &amp;quot;/temp&amp;quot; } }
  );&lt;/code>&lt;/pre>
</example><example>&lt;p>Use a transform function to modify the values:&lt;/p>
&lt;pre>&lt;code>  // returns &amp;quot;file &amp;#39;foo.html&amp;#39; is not found in directory &amp;#39;/temp&amp;#39;.&amp;quot;
  string.substitute(
    &amp;quot;${0} is not found in ${1}.&amp;quot;,
    [&amp;quot;foo.html&amp;quot;,&amp;quot;/temp&amp;quot;],
    function(str){
      // try to figure out the type
      var prefix = (str.charAt(0) == &amp;quot;/&amp;quot;) ? &amp;quot;directory&amp;quot;: &amp;quot;file&amp;quot;;
      return prefix + &amp;quot; &amp;#39;&amp;quot; + str + &amp;quot;&amp;#39;&amp;quot;;
    }
  );&lt;/code>&lt;/pre>
</example><example>&lt;p>Use a formatter&lt;/p>
&lt;pre>&lt;code>  // returns &amp;quot;thinger -- howdy&amp;quot;
  string.substitute(
    &amp;quot;${0:postfix}&amp;quot;, [&amp;quot;thinger&amp;quot;], null, {
      postfix: function(value, key){
        return value + &amp;quot; -- howdy&amp;quot;;
      }
    }
  );&lt;/code>&lt;/pre>
</example></examples></method><method name="trim" scope="normal" type="function" from="dojo/string"><parameters><parameter name="str" type="String" usage="required"><summary>&lt;p>String to be trimmed&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/></return-types><return-description>Returns the trimmed string</return-description><summary>&lt;p>Trims whitespace from both sides of the string&lt;/p>
</summary><description>&lt;p>This version of trim() was taken from &lt;a href=&quot;http://blog.stevenlevithan.com/archives/faster-trim-javascript&quot;>Steven Levithan&amp;#39;s blog&lt;/a>.
The short yet performant version of this function is dojo.trim(),
which is part of Dojo base.  Uses String.prototype.trim instead, if available.&lt;/p>
</description></method></methods><summary>&lt;p>String utilities for Dojo&lt;/p>
</summary></object><object location="dojo/data/ItemFileReadStore" type="constructor" classlike="true" superclass="dojo/Evented"><properties><property name="url" scope="prototype" type="string" from="dojo/data/ItemFileReadStore"/><property name="_ccUrl" scope="prototype" type="string" from="dojo/data/ItemFileReadStore"/><property name="data" scope="prototype" type="null" from="dojo/data/ItemFileReadStore"/><property name="typeMap" scope="prototype" type="null" from="dojo/data/ItemFileReadStore"/><property name="clearOnClose" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to allow users to specify if a close call should force a reload or not.
By default, it retains the old behavior of not clearing if close is called.  But
if set true, the store will be reset to default state.  Note that by doing this,
all item handles will become invalid and a new fetch must be issued.&lt;/p>
</summary></property><property name="urlPreventCache" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
Added for tracker: #6072&lt;/p>
</summary></property><property name="failOk" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter for specifying that it is OK for the xhrGet call to fail silently.&lt;/p>
</summary></property><property name="hierarchical" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to indicate to process data from the url as hierarchical
(data items can contain other data items in js form).  Default is true
for backwards compatibility.  False means only root items are processed
as items, all child objects outside of type-mapped objects and those in
specific reference format, are left straight JS data objects.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordParameters" type="Object" usage="required"><summary>&lt;p>{url: String} {data: jsonObject} {typeMap: object}
The structure of the typeMap object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    type0: function || object,
    type1: function || object,
    ...
    typeN: function || object
  }&lt;/code>&lt;/pre>
&lt;p>Where if it is a function, it is assumed to be an object constructor that takes the
value of _value as the initialization parameters.  If it is an object, then it is assumed
to be an object of general form:&lt;/p>
&lt;pre>&lt;code>  {
    type: function, //constructor.
    deserialize:  function(value) //The function that parses the value and constructs the object defined by type appropriately.
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>constructor&lt;/p>
</summary></method><method name="_assertIsItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to test for being contained by the store.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function tests whether the item passed in is indeed an item in the store.&lt;/p>
</summary></method><method name="_assertIsAttribute" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to test for being contained by the store.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function tests whether the item passed in is indeed a valid &amp;#39;attribute&amp;#39; like type for the store.&lt;/p>
</summary></method><method name="getValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="defaultValue" type="value" usage="optional"/></parameters><return-types><return-type type="value"/></return-types><summary>&lt;p>See dojo/data/api/Read.getValue()&lt;/p>
</summary></method><method name="getValues" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.getValues()&lt;/p>
</summary></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>See dojo/data/api/Read.getAttributes()&lt;/p>
</summary></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Read.hasAttribute()&lt;/p>
</summary></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="value" type="anything" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.containsValue()&lt;/p>
</summary></method><method name="_containsValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The data item to examine for attribute values.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to inspect.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match.&lt;/p>
</summary></parameter><parameter name="regexp" type="RegExp" usage="optional"><summary>&lt;p>Optional regular expression generated off value if value was of string type to handle wildcarding.
If present and attribute values are string, then it can be used for comparison instead of &amp;#39;value&amp;#39;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Internal function for looking at the values contained by the item.&lt;/p>
</summary><description>&lt;p>Internal function for looking at the values contained by the item.  This
function allows for denoting if the comparison should be case sensitive for
strings or not (for handling filtering cases where string case should not matter)&lt;/p>
</description></method><method name="isItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="something" type="anything" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Read.isItem()&lt;/p>
</summary></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="something" type="anything" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.isItemLoaded()&lt;/p>
</summary></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="object" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Read.loadItem()&lt;/p>
</summary></method><method name="getFeatures" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.getFeatures()&lt;/p>
</summary></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="number"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabel()&lt;/p>
</summary></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="null"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabelAttributes()&lt;/p>
</summary></method><method name="filter" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="requestArgs" type="Object" usage="required"/><parameter name="arrayOfItems" type="item[]" usage="required"/><parameter name="findCallback" type="Function" usage="required"/></parameters><return-types/><summary>&lt;p>This method handles the basic filtering needs for ItemFile* based stores.&lt;/p>
</summary></method><method name="_fetchItems" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="Object" usage="required"/><parameter name="findCallback" type="Function" usage="required"/><parameter name="errorCallback" type="Function" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/util.simpleFetch.fetch()&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="_handleQueuedFetches" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types/><summary>&lt;p>Internal function to execute delayed request in the store.&lt;/p>
</summary></method><method name="_getItemsArray" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="queryOptions" type="object" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Internal function to determine which list of items to search over.&lt;/p>
</summary></method><method name="close" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="request" type="dojo/data/api/Request|Object" usage="optional"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Read.close()&lt;/p>
</summary></method><method name="_getItemsFromLoadedData" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="dataObject" type="Object" usage="required"><summary>&lt;p>The JS data object containing the raw data to convery into item format.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><return-description>Array of items in store item format.</return-description><summary>&lt;p>Function to parse the loaded data into item format and build the internal items array.&lt;/p>
</summary><description>&lt;p>Function to parse the loaded data into item format and build the internal items array.&lt;/p>
</description></method><method name="_addReferenceToMap" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="refItem" type="item" usage="required"><summary>&lt;p>The item that is referenced.&lt;/p>
</summary></parameter><parameter name="parentItem" type="item" usage="required"><summary>&lt;p>The item that holds the new reference to refItem.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute on parentItem that contains the new reference.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Method to add an reference map entry for an item and attribute.&lt;/p>
</summary><description>&lt;p>Method to add an reference map entry for an item and attribute.&lt;/p>
</description></method><method name="getIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>See dojo/data/api/Identity.getIdentity()&lt;/p>
</summary></method><method name="fetchItemByIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Identity.fetchItemByIdentity()&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="_getItemByIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="identity" type="Object" usage="required"/></parameters><return-types><return-type type="null"/></return-types><summary>&lt;p>Internal function to look an item up by its identity map.&lt;/p>
</summary></method><method name="getIdentityAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="null"/><return-type type="Array"/></return-types><summary>&lt;p>See dojo/data/api/Identity.getIdentityAttributes()&lt;/p>
</summary></method><method name="_forceLoad" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types/><summary>&lt;p>Internal function to force a load of the store if it hasn&amp;#39;t occurred yet.  This is required
for specific functions to work properly.&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="errorHandler" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="errorData" type="Object" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The error handler when there is an error fetching items.  This function should not be called
directly and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetchHandler" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="items" type="Array" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The handler when items are sucessfully fetched.  This function should not be called directly
and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="request" type="Object" usage="optional"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean  // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The simpleFetch mixin is designed to serve as a set of function(s) that can
be mixed into other datastore implementations to accelerate their development.&lt;/p>
</summary><description>&lt;p>The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
call by returning an array of all the found items that matched the query.  The simpleFetch mixin
is not designed to work for datastores that respond to a fetch() call by incrementally
loading items, or sequentially loading partial batches of the result
set.  For datastores that mixin simpleFetch, simpleFetch
implements a fetch method that automatically handles eight of the fetch()
arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
The class mixing in simpleFetch should not implement fetch(),
but should instead implement a _fetchItems() method.  The _fetchItems()
method takes three arguments, the keywordArgs object that was passed
to fetch(), a callback function to be called when the result array is
available, and an error callback to be called if something goes wrong.
The _fetchItems() method should ignore any keywordArgs parameters for
start, count, onBegin, onItem, onComplete, onError, sort, and scope.
The _fetchItems() method needs to correctly handle any other keywordArgs
parameters, including the query parameter and any optional parameters
(such as includeChildren).  The _fetchItems() method should create an array of
result items and pass it to the fetchHandler along with the original request object --
or, the _fetchItems() method may, if it wants to, create an new request object
with other specifics about the request that are specific to the datastore and pass
that as the request object to the handler.

&lt;/p>
&lt;p>For more information on this specific function, see dojo/data/api/Read.fetch()
&lt;/p>
</description></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters><parameter name="keywordParameters" type="Object" usage="required"><summary>&lt;p>{url: String} {data: jsonObject} {typeMap: object}
The structure of the typeMap object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    type0: function || object,
    type1: function || object,
    ...
    typeN: function || object
  }&lt;/code>&lt;/pre>
&lt;p>Where if it is a function, it is assumed to be an object constructor that takes the
value of _value as the initialization parameters.  If it is an object, then it is assumed
to be an object of general form:&lt;/p>
&lt;pre>&lt;code>  {
    type: function, //constructor.
    deserialize:  function(value) //The function that parses the value and constructs the object defined by type appropriately.
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>The ItemFileReadStore implements the dojo/data/api/Read API and reads
data from JSON files that have contents in this format --&lt;/p>
&lt;pre>&lt;code>  { items: [
    { name:&amp;#39;Kermit&amp;#39;, color:&amp;#39;green&amp;#39;, age:12, friends:[&amp;#39;Gonzo&amp;#39;, {_reference:{name:&amp;#39;Fozzie Bear&amp;#39;}}]},
    { name:&amp;#39;Fozzie Bear&amp;#39;, wears:[&amp;#39;hat&amp;#39;, &amp;#39;tie&amp;#39;]},
    { name:&amp;#39;Miss Piggy&amp;#39;, pets:&amp;#39;Foo-Foo&amp;#39;}
  ]}&lt;/code>&lt;/pre>
&lt;p>Note that it can also contain an &amp;#39;identifier&amp;#39; property that specified which attribute on the items
in the array of items that acts as the unique identifier for that item.&lt;/p>
</summary></object><object location="dojo/data/util/filter" type="object"><properties/><methods><method name="patternToRegExp" scope="normal" type="function" from="dojo/data/util/filter"><parameters><parameter name="pattern" type="string" usage="required"><summary>&lt;p>A simple matching pattern to convert that follows basic rules:

&lt;/p>
&lt;ul>
&lt;li>&lt;ul>
&lt;li>Means match anything, so ca* means match anything starting with ca&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>? Means match single character.  So, b?b will match to bob and bab, and so on.&lt;/li>
&lt;li>\ is an escape character.  So for example, * means do not treat &lt;em> as a match, but literal character &lt;/em>.&lt;/li>
&lt;/ul>
&lt;p>To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
represented by \ to be treated as an ordinary \ character instead of an escape.&lt;/p>
</summary></parameter><parameter name="ignoreCase" type="boolean" usage="optional"><summary>&lt;p>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
By default, it is assumed case sensitive.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Helper function to convert a simple pattern to a regular expression for matching.&lt;/p>
</summary><description>&lt;p>Returns a regular expression object that conforms to the defined conversion rules.
For example:

&lt;/p>
&lt;ul>
&lt;li>ca&lt;em>   -&amp;gt; /^ca.&lt;/em>$/&lt;/li>
&lt;li>&lt;em>ca&lt;/em>  -&amp;gt; /^.&lt;em>ca.&lt;/em>$/&lt;/li>
&lt;li>&lt;em>c\&lt;/em>a&lt;em>  -&amp;gt; /^.&lt;/em>c*a.*$/&lt;/li>
&lt;li>&lt;em>c\&lt;/em>a?&lt;em>  -&amp;gt; /^.&lt;/em>c*a..*$/&lt;/li>
&lt;/ul>
&lt;p>and so on.&lt;/p>
</description></method></methods></object><object location="dojo/data/util/simpleFetch" type="object"><properties/><methods><method name="errorHandler" scope="normal" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="errorData" type="Object" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The error handler when there is an error fetching items.  This function should not be called
directly and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetchHandler" scope="normal" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="items" type="Array" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The handler when items are sucessfully fetched.  This function should not be called directly
and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetch" scope="normal" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="request" type="Object" usage="optional"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean  // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The simpleFetch mixin is designed to serve as a set of function(s) that can
be mixed into other datastore implementations to accelerate their development.&lt;/p>
</summary><description>&lt;p>The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
call by returning an array of all the found items that matched the query.  The simpleFetch mixin
is not designed to work for datastores that respond to a fetch() call by incrementally
loading items, or sequentially loading partial batches of the result
set.  For datastores that mixin simpleFetch, simpleFetch
implements a fetch method that automatically handles eight of the fetch()
arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
The class mixing in simpleFetch should not implement fetch(),
but should instead implement a _fetchItems() method.  The _fetchItems()
method takes three arguments, the keywordArgs object that was passed
to fetch(), a callback function to be called when the result array is
available, and an error callback to be called if something goes wrong.
The _fetchItems() method should ignore any keywordArgs parameters for
start, count, onBegin, onItem, onComplete, onError, sort, and scope.
The _fetchItems() method needs to correctly handle any other keywordArgs
parameters, including the query parameter and any optional parameters
(such as includeChildren).  The _fetchItems() method should create an array of
result items and pass it to the fetchHandler along with the original request object --
or, the _fetchItems() method may, if it wants to, create an new request object
with other specifics about the request that are specific to the datastore and pass
that as the request object to the handler.

&lt;/p>
&lt;p>For more information on this specific function, see dojo/data/api/Read.fetch()
&lt;/p>
</description></method></methods></object><object location="dojo/data/util/sorter" type="object"><properties/><methods><method name="basicComparator" scope="normal" type="function" from="dojo/data/util/sorter"><parameters><parameter name="a" type="anything" usage="required"/><parameter name="b" type="anything" usage="required"/></parameters><return-types/><summary>&lt;p>Basic comparison function that compares if an item is greater or less than another item&lt;/p>
</summary><description>&lt;p>returns 1 if a &amp;gt; b, -1 if a &amp;lt; b, 0 if equal.
&amp;#39;null&amp;#39; values (null, undefined) are treated as larger values so that they&amp;#39;re pushed to the end of the list.
And compared to each other, null is equivalent to undefined.&lt;/p>
</description></method><method name="createSortFunction" scope="normal" type="function" from="dojo/data/util/sorter"><parameters><parameter name="sortSpec" type="attributes[]" usage="required"><summary>&lt;p>A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
The objects should be formatted as follows:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: &amp;quot;attributeName-string&amp;quot; || attribute,
    descending: true|false;   // Default is false.
  }&lt;/code>&lt;/pre>
</summary></parameter><parameter name="store" type="dojo/data/api/Read" usage="required"><summary>&lt;p>The datastore object to look up item values from.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Helper function to generate the sorting function based off the list of sort attributes.&lt;/p>
</summary><description>&lt;p>The sort function creation will look for a property on the store called &amp;#39;comparatorMap&amp;#39;.  If it exists
it will look in the mapping for comparisons function for the attributes.  If one is found, it will
use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
Returns the sorting function for this particular list of attributes and sorting directions.&lt;/p>
</description></method></methods></object><object location="dojo/data/ItemFileWriteStore" type="constructor" classlike="true" superclass="dojo/data/ItemFileReadStore"><properties><property name="referenceIntegrity" scope="prototype" type="boolean" from="dojo/data/ItemFileWriteStore"/><property name="url" scope="prototype" type="string" from="dojo/data/ItemFileReadStore"/><property name="_ccUrl" scope="prototype" type="string" from="dojo/data/ItemFileReadStore"/><property name="data" scope="prototype" type="null" from="dojo/data/ItemFileReadStore"/><property name="typeMap" scope="prototype" type="null" from="dojo/data/ItemFileReadStore"/><property name="clearOnClose" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to allow users to specify if a close call should force a reload or not.
By default, it retains the old behavior of not clearing if close is called.  But
if set true, the store will be reset to default state.  Note that by doing this,
all item handles will become invalid and a new fetch must be issued.&lt;/p>
</summary></property><property name="urlPreventCache" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
Added for tracker: #6072&lt;/p>
</summary></property><property name="failOk" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter for specifying that it is OK for the xhrGet call to fail silently.&lt;/p>
</summary></property><property name="hierarchical" scope="prototype" type="Boolean" from="dojo/data/ItemFileReadStore"><summary>&lt;p>Parameter to indicate to process data from the url as hierarchical
(data items can contain other data items in js form).  Default is true
for backwards compatibility.  False means only root items are processed
as items, all child objects outside of type-mapped objects and those in
specific reference format, are left straight JS data objects.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="keywordParameters" type="object" usage="required"><summary>&lt;p>The structure of the typeMap object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    type0: function || object,
    type1: function || object,
    ...
    typeN: function || object
  }&lt;/code>&lt;/pre>
&lt;p>Where if it is a function, it is assumed to be an object constructor that takes the
value of _value as the initialization parameters.  It is serialized assuming object.toString()
serialization.  If it is an object, then it is assumed
to be an object of general form:&lt;/p>
&lt;pre>&lt;code>  {
    type: function, //constructor.
    deserialize:  function(value) //The function that parses the value and constructs the object defined by type appropriately.
    serialize:  function(object) //The function that converts the object back into the proper file format form.
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/></method><method name="_assert" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="condition" type="boolean" usage="required"/></parameters><return-types/></method><method name="_getIdentifierAttribute" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters/><return-types><return-type type="undefined"/></return-types></method><method name="newItem" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="keywordArgs" type="Object" usage="optional"/><parameter name="parentInfo" type="Object" usage="optional"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>See dojo/data/api/Write.newItem()&lt;/p>
</summary></method><method name="_removeArrayElement" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="array" type="Array" usage="required"/><parameter name="element" type="anything" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types></method><method name="deleteItem" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Write.deleteItem()&lt;/p>
</summary></method><method name="setValue" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="value" type="almost anything" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Write.set()&lt;/p>
</summary></method><method name="setValues" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="values" type="array" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Write.setValues()&lt;/p>
</summary></method><method name="unsetAttribute" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Write.unsetAttribute()&lt;/p>
</summary></method><method name="_setValueOrValues" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="newValueOrValues" type="anything" usage="required"/><parameter name="callOnSet" type="boolean" usage="optional"/></parameters><return-types><return-type type="boolean"/></return-types></method><method name="_addReferenceToMap" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="refItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item that is referenced.&lt;/p>
</summary></parameter><parameter name="parentItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item that holds the new reference to refItem.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute on parentItem that contains the new reference.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Method to add an reference map entry for an item and attribute.&lt;/p>
</summary><description>&lt;p>Method to add an reference map entry for an item and attribute.&lt;/p>
</description></method><method name="_removeReferenceFromMap" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="refItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item that is referenced.&lt;/p>
</summary></parameter><parameter name="parentItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item holding a reference to refItem.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute on parentItem that contains the reference.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Method to remove an reference map entry for an item and attribute.&lt;/p>
</summary><description>&lt;p>Method to remove an reference map entry for an item and attribute.  This will
also perform cleanup on the map such that if there are no more references at all to
the item, its reference object and entry are removed.&lt;/p>
</description></method><method name="_dumpReferenceMap" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters/><return-types/><summary>&lt;p>Function to dump the reverse reference map of all items in the store for debug purposes.&lt;/p>
</summary><description>&lt;p>Function to dump the reverse reference map of all items in the store for debug purposes.&lt;/p>
</description></method><method name="_getValueOrValues" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_flatten" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="value" type="anything" usage="required"/></parameters><return-types><return-type type="object"/><return-type type="anything"/></return-types></method><method name="_getNewFileContentString" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Generate a string that can be saved to a file.
The result should look similar to:
&lt;a href=&quot;http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json&quot;>http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json&lt;/a>&lt;/p>
</summary></method><method name="_isEmpty" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="something" type="undefined" usage="required"><summary>&lt;p>The array or object to examine.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Function to determine if an array or object has no properties or values.&lt;/p>
</summary></method><method name="save" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="keywordArgs" type="object" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Write.save()&lt;/p>
</summary></method><method name="revert" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters/><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Write.revert()&lt;/p>
</summary></method><method name="isDirty" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="item" usage="optional"/></parameters><return-types><return-type type="undefined"/><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Write.isDirty()&lt;/p>
</summary></method><method name="onSet" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="oldValue" type="object|array" usage="required"/><parameter name="newValue" type="object|array" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Notification.onSet()&lt;/p>
</summary></method><method name="onNew" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="newItem" type="dojo/data/api/Item" usage="required"/><parameter name="parentInfo" type="object" usage="optional"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Notification.onNew()&lt;/p>
</summary></method><method name="onDelete" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="deletedItem" type="dojo/data/api/Item" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Notification.onDelete()&lt;/p>
</summary></method><method name="close" scope="prototype" type="function" from="dojo/data/ItemFileWriteStore"><parameters><parameter name="request" type="object" usage="optional"/></parameters><return-types/><summary>&lt;p>Over-ride of base close function of ItemFileReadStore to add in check for store state.&lt;/p>
</summary><description>&lt;p>Over-ride of base close function of ItemFileReadStore to add in check for store state.
If the store is still dirty (unsaved changes), then an error will be thrown instead of
clearing the internal state for reload from the url.&lt;/p>
</description></method><method name="_assertIsItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to test for being contained by the store.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function tests whether the item passed in is indeed an item in the store.&lt;/p>
</summary></method><method name="_assertIsAttribute" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to test for being contained by the store.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function tests whether the item passed in is indeed a valid &amp;#39;attribute&amp;#39; like type for the store.&lt;/p>
</summary></method><method name="getValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="defaultValue" type="value" usage="optional"/></parameters><return-types><return-type type="value"/></return-types><summary>&lt;p>See dojo/data/api/Read.getValue()&lt;/p>
</summary></method><method name="getValues" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.getValues()&lt;/p>
</summary></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>See dojo/data/api/Read.getAttributes()&lt;/p>
</summary></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Read.hasAttribute()&lt;/p>
</summary></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/><parameter name="attribute" type="attribute-name-string" usage="required"/><parameter name="value" type="anything" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.containsValue()&lt;/p>
</summary></method><method name="_containsValue" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The data item to examine for attribute values.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to inspect.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match.&lt;/p>
</summary></parameter><parameter name="regexp" type="RegExp" usage="optional"><summary>&lt;p>Optional regular expression generated off value if value was of string type to handle wildcarding.
If present and attribute values are string, then it can be used for comparison instead of &amp;#39;value&amp;#39;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Internal function for looking at the values contained by the item.&lt;/p>
</summary><description>&lt;p>Internal function for looking at the values contained by the item.  This
function allows for denoting if the comparison should be case sensitive for
strings or not (for handling filtering cases where string case should not matter)&lt;/p>
</description></method><method name="isItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="something" type="anything" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>See dojo/data/api/Read.isItem()&lt;/p>
</summary></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="something" type="anything" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.isItemLoaded()&lt;/p>
</summary></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="object" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Read.loadItem()&lt;/p>
</summary></method><method name="getFeatures" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.getFeatures()&lt;/p>
</summary></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="number"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabel()&lt;/p>
</summary></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="null"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabelAttributes()&lt;/p>
</summary></method><method name="filter" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="requestArgs" type="Object" usage="required"/><parameter name="arrayOfItems" type="item[]" usage="required"/><parameter name="findCallback" type="Function" usage="required"/></parameters><return-types/><summary>&lt;p>This method handles the basic filtering needs for ItemFile* based stores.&lt;/p>
</summary></method><method name="_fetchItems" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="Object" usage="required"/><parameter name="findCallback" type="Function" usage="required"/><parameter name="errorCallback" type="Function" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/util.simpleFetch.fetch()&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="_handleQueuedFetches" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types/><summary>&lt;p>Internal function to execute delayed request in the store.&lt;/p>
</summary></method><method name="_getItemsArray" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="queryOptions" type="object" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Internal function to determine which list of items to search over.&lt;/p>
</summary></method><method name="_getItemsFromLoadedData" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="dataObject" type="Object" usage="required"><summary>&lt;p>The JS data object containing the raw data to convery into item format.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><return-description>Array of items in store item format.</return-description><summary>&lt;p>Function to parse the loaded data into item format and build the internal items array.&lt;/p>
</summary><description>&lt;p>Function to parse the loaded data into item format and build the internal items array.&lt;/p>
</description></method><method name="getIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>See dojo/data/api/Identity.getIdentity()&lt;/p>
</summary></method><method name="fetchItemByIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="keywordArgs" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>See dojo/data/api/Identity.fetchItemByIdentity()&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="_getItemByIdentity" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="identity" type="Object" usage="required"/></parameters><return-types><return-type type="null"/></return-types><summary>&lt;p>Internal function to look an item up by its identity map.&lt;/p>
</summary></method><method name="getIdentityAttributes" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="null"/><return-type type="Array"/></return-types><summary>&lt;p>See dojo/data/api/Identity.getIdentityAttributes()&lt;/p>
</summary></method><method name="_forceLoad" scope="prototype" type="function" from="dojo/data/ItemFileReadStore"><parameters/><return-types/><summary>&lt;p>Internal function to force a load of the store if it hasn&amp;#39;t occurred yet.  This is required
for specific functions to work properly.&lt;/p>
</summary><deprecated>undefined:  To change the url, set the url property of the store, not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0</deprecated></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="errorHandler" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="errorData" type="Object" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The error handler when there is an error fetching items.  This function should not be called
directly and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetchHandler" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="items" type="Array" usage="required"/><parameter name="requestObject" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>The handler when items are sucessfully fetched.  This function should not be called directly
and is used by simpleFetch.fetch().&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/util/simpleFetch"><parameters><parameter name="request" type="Object" usage="optional"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean  // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The simpleFetch mixin is designed to serve as a set of function(s) that can
be mixed into other datastore implementations to accelerate their development.&lt;/p>
</summary><description>&lt;p>The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
call by returning an array of all the found items that matched the query.  The simpleFetch mixin
is not designed to work for datastores that respond to a fetch() call by incrementally
loading items, or sequentially loading partial batches of the result
set.  For datastores that mixin simpleFetch, simpleFetch
implements a fetch method that automatically handles eight of the fetch()
arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
The class mixing in simpleFetch should not implement fetch(),
but should instead implement a _fetchItems() method.  The _fetchItems()
method takes three arguments, the keywordArgs object that was passed
to fetch(), a callback function to be called when the result array is
available, and an error callback to be called if something goes wrong.
The _fetchItems() method should ignore any keywordArgs parameters for
start, count, onBegin, onItem, onComplete, onError, sort, and scope.
The _fetchItems() method needs to correctly handle any other keywordArgs
parameters, including the query parameter and any optional parameters
(such as includeChildren).  The _fetchItems() method should create an array of
result items and pass it to the fetchHandler along with the original request object --
or, the _fetchItems() method may, if it wants to, create an new request object
with other specifics about the request that are specific to the datastore and pass
that as the request object to the handler.

&lt;/p>
&lt;p>For more information on this specific function, see dojo/data/api/Read.fetch()
&lt;/p>
</description></method></methods><mixins><mixin location="dojo/data/ItemFileReadStore"/></mixins><parameters><parameter name="keywordParameters" type="object" usage="required"><summary>&lt;p>The structure of the typeMap object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    type0: function || object,
    type1: function || object,
    ...
    typeN: function || object
  }&lt;/code>&lt;/pre>
&lt;p>Where if it is a function, it is assumed to be an object constructor that takes the
value of _value as the initialization parameters.  It is serialized assuming object.toString()
serialization.  If it is an object, then it is assumed
to be an object of general form:&lt;/p>
&lt;pre>&lt;code>  {
    type: function, //constructor.
    deserialize:  function(value) //The function that parses the value and constructs the object defined by type appropriately.
    serialize:  function(object) //The function that converts the object back into the proper file format form.
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/data/ObjectStore" type="constructor" classlike="true" superclass="dojo/Evented"><properties><property name="objectStore" scope="prototype" type="null" from="dojo/data/ObjectStore"/><property name="labelProperty" scope="prototype" type="string" from="dojo/data/ObjectStore"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="options" type="undefined" usage="required"><summary>&lt;p>The configuration information to pass into the data store.

&lt;/p>
&lt;ul>
&lt;li>options.objectStore:&lt;/li>
&lt;/ul>
&lt;p>The object store to use as the source provider for this data store&lt;/p>
</summary></parameter></parameters><return-types/></method><method name="getValue" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to get the value from&lt;/p>
</summary></parameter><parameter name="property" type="String" usage="required"><summary>&lt;p>property to look up value for&lt;/p>
</summary></parameter><parameter name="defaultValue" type="value" usage="optional"><summary>&lt;p>the default value&lt;/p>
</summary></parameter></parameters><return-types><return-type type="value"/></return-types><return-description>&lt;p>the default value&lt;/p>
</return-description><summary>&lt;p>Gets the value of an item&amp;#39;s &amp;#39;property&amp;#39;&lt;/p>
</summary></method><method name="getValues" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"/><parameter name="property" type="String" usage="required"><summary>&lt;p>property to look up value for&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Gets the value of an item&amp;#39;s &amp;#39;property&amp;#39; and returns
it. If this value is an array it is just returned,
if not, the value is added to an array and that is returned.&lt;/p>
</summary></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Gets the available attributes of an item&amp;#39;s &amp;#39;property&amp;#39; and returns
it as an array.&lt;/p>
</summary></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to check&lt;/p>
</summary></parameter><parameter name="attribute" type="String" usage="required"><summary>&lt;p>The attribute to check&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Checks to see if item has attribute&lt;/p>
</summary></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to check&lt;/p>
</summary></parameter><parameter name="attribute" type="String" usage="required"><summary>&lt;p>The attribute to check&lt;/p>
</summary></parameter><parameter name="value" type="Anything" usage="required"><summary>&lt;p>The value to look for&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Checks to see if &amp;#39;item&amp;#39; has &amp;#39;value&amp;#39; at &amp;#39;attribute&amp;#39;&lt;/p>
</summary></method><method name="isItem" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to check&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Checks to see if the argument is an item&lt;/p>
</summary></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to check&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks to see if the item is loaded.&lt;/p>
</summary></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>See dojo/data/api/Read.fetch()&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Loads an item and calls the callback handler. Note, that this will call the callback
handler even if the item is loaded. Consequently, you can use loadItem to ensure
that an item is loaded is situations when the item may or may not be loaded yet.
If you access a value directly through property access, you can use this to load
a lazy value as well (doesn&amp;#39;t need to be an item).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  store.loadItem({
    item: item, // this item may or may not be loaded
    onItem: function(item){
      // do something with the item
    }
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="close" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="request" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.close()&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.fetch()&lt;/p>
</summary></method><method name="getFeatures" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters/><return-types><return-type type="object"/></return-types><summary>&lt;p>return the store feature set&lt;/p>
</summary></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabel()&lt;/p>
</summary></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>See dojo/data/api/Read.getLabelAttributes()&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns the identity of the given item
See dojo/data/api/Read.getIdentity()&lt;/p>
</summary></method><method name="getIdentityAttributes" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>returns the attributes which are used to make up the
identity of an item.  Basically returns this.objectStore.idProperty
See dojo/data/api/Read.getIdentityAttributes()&lt;/p>
</summary></method><method name="fetchItemByIdentity" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>fetch an item by its identity, by looking in our index of what we have loaded&lt;/p>
</summary></method><method name="newItem" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="data" type="Object" usage="required"><summary>&lt;p>See dojo/data/api/Write.newItem()&lt;/p>
</summary></parameter><parameter name="parentInfo" type="undefined" usage="required"/></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>See dojo/data/api/Write.newItem()&lt;/p>
</return-description><summary>&lt;p>adds a new item to the store at the specified point.
Takes two parameters, data, and options.&lt;/p>
</summary></method><method name="deleteItem" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"><summary>&lt;p>item to delete&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>deletes item and any references to that item from the store.&lt;/p>
</summary></method><method name="setValue" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"/><parameter name="attribute" type="undefined" usage="required"/><parameter name="value" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>sets &amp;#39;attribute&amp;#39; on &amp;#39;item&amp;#39; to &amp;#39;value&amp;#39;
See dojo/data/api/Write.setValue()&lt;/p>
</summary></method><method name="setValues" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"/><parameter name="attribute" type="undefined" usage="required"/><parameter name="values" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>sets &amp;#39;attribute&amp;#39; on &amp;#39;item&amp;#39; to &amp;#39;value&amp;#39; value
must be an array.
See dojo/data/api/Write.setValues()&lt;/p>
</summary></method><method name="unsetAttribute" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="undefined" usage="required"/><parameter name="attribute" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>unsets &amp;#39;attribute&amp;#39; on &amp;#39;item&amp;#39;
See dojo/data/api/Write.unsetAttribute()&lt;/p>
</summary></method><method name="changing" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>Indicates that the given object is changing and should be marked as 
dirty for the next save&lt;/p>
</summary></parameter><parameter name="_deleting" type="Boolean" usage="required"/></parameters><return-types/><summary>&lt;p>adds an object to the list of dirty objects.  This object
contains a reference to the object itself as well as a
cloned and trimmed version of old object for use with
revert.&lt;/p>
</summary></method><method name="save" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="kwArgs" type="undefined" usage="required"><summary>&lt;ul>
&lt;li>&lt;p>kwArgs.global:
This will cause the save to commit the dirty data for all
ObjectStores as a single transaction.&lt;/p>
&lt;/li>
&lt;li>&lt;p>kwArgs.revertOnError:
This will cause the changes to be reverted if there is an
error on the save. By default a revert is executed unless
a value of false is provide for this parameter.&lt;/p>
&lt;/li>
&lt;li>&lt;p>kwArgs.onError:
Called when an error occurs in the commit&lt;/p>
&lt;/li>
&lt;li>&lt;p>kwArgs.onComplete:
Called when an the save/commit is completed&lt;/p>
&lt;/li>
&lt;/ul>
</summary></parameter></parameters><return-types/><summary>&lt;p>Saves the dirty data using object store provider. See dojo/data/api/Write for API.&lt;/p>
</summary></method><method name="revert" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters/><return-types/><summary>&lt;p>returns any modified data to its original state prior to a save();&lt;/p>
</summary></method><method name="isDirty" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="item" type="Object" usage="required"><summary>&lt;p>The item to check&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/><return-type type="undefined"/></return-types><summary>&lt;p>returns true if the item is marked as dirty or true if there are any dirty items&lt;/p>
</summary></method><method name="onSet" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters/><return-types/><summary>&lt;p>See dojo/data/api/Notification.onSet()&lt;/p>
</summary></method><method name="onNew" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters/><return-types/><summary>&lt;p>See dojo/data/api/Notification.onNew()&lt;/p>
</summary></method><method name="onDelete" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters/><return-types/><summary>&lt;p>See dojo/data/api/Notification.onDelete()&lt;/p>
</summary></method><method name="onFetch" scope="prototype" type="function" from="dojo/data/ObjectStore"><parameters><parameter name="results" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Called when a fetch occurs&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters><parameter name="options" type="undefined" usage="required"><summary>&lt;p>The configuration information to pass into the data store.

&lt;/p>
&lt;ul>
&lt;li>options.objectStore:&lt;/li>
&lt;/ul>
&lt;p>The object store to use as the source provider for this data store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A Dojo Data implementation that wraps Dojo object stores for backwards
compatibility.&lt;/p>
</summary></object><object location="dojo/data/api/Identity" type="constructor" classlike="true" superclass="dojo/data/api/Read"><properties/><methods><method name="getFeatures" scope="prototype" type="function" from="dojo/data/api/Identity"><parameters/><return-types><return-type type="object"/></return-types><summary>&lt;p>See dojo/data/api/Read.getFeatures()&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/data/api/Identity"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item from the store from which to obtain its identifier.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a unique identifier for an item.  The return value will be
either a string or something that has a toString() method (such as,
for example, a dojox/uuid object).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var itemId = store.getIdentity(kermit);
  assert(kermit === store.findByIdentity(store.getIdentity(kermit)));&lt;/code>&lt;/pre>
</example></examples></method><method name="getIdentityAttributes" scope="prototype" type="function" from="dojo/data/api/Identity"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item from the store from which to obtain the array of public attributes that
compose the identifier, if any.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns an array of attribute names that are used to generate the identity.
For most stores, this is a single attribute, but for some complex stores
such as RDB backed stores that use compound (multi-attribute) identifiers
it can be more than one.  If the identity is not composed of attributes
on the item, it will return null.  This function is intended to identify
the attributes that comprise the identity so that so that during a render
of all attributes, the UI can hide the the identity information if it
chooses.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var itemId = store.getIdentity(kermit);
  var identifiers = store.getIdentityAttributes(itemId);
  assert(typeof identifiers === &amp;quot;array&amp;quot; || identifiers === null);&lt;/code>&lt;/pre>
</example></examples></method><method name="fetchItemByIdentity" scope="prototype" type="function" from="dojo/data/api/Identity"><parameters><parameter name="keywordArgs" type="object" usage="required"><summary>&lt;p>An anonymous object that defines the item to locate and callbacks to invoke when the
item has been located and load has completed.  The format of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    identity: string|object,
    onItem: Function,
    onError: Function,
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>identity&lt;/em> parameter&lt;/h4>
&lt;p>The identity parameter is the identity of the item you wish to locate and load
This attribute is required.  It should be a string or an object that toString()
can be called on.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter&lt;/h4>
&lt;p>Function(item)
The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
parameter, the item located, or null if none found.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter&lt;/h4>
&lt;p>Function(error)
The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
parameter, the error object

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onError, etc) will be invoked in the context of the scope object.
In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global.
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global, item, request)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given the identity of an item, this method returns the item that has
that identity through the onItem callback.  Conforming implementations
should return null if there is no item with the given identity.
Implementations of fetchItemByIdentity() may sometimes return an item
from a local cache and may sometimes fetch an item from a remote server,&lt;/p>
</summary></method><method name="getValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="value" usage="optional"><summary>&lt;p>Optional.  A default value to use for the getValue return in the attribute does not exist or has no value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>a literal, an item, null, or undefined (never an array)</return-description><summary>&lt;p>Returns a single attribute value.
Returns defaultValue if and only if &lt;em>item&lt;/em> does not have a value for &lt;em>attribute&lt;/em>.
Returns null if and only if null was explicitly set as the attribute value.
Returns undefined if and only if the item does not have a value for the
given attribute (which is the same as saying the item does not have the attribute).&lt;/p>
</summary><description>&lt;p>Saying that an &amp;quot;item x does not have a value for an attribute y&amp;quot;
is identical to saying that an &amp;quot;item x does not have attribute y&amp;quot;.
It is an oxymoron to say &amp;quot;that attribute is present but has no values&amp;quot;
or &amp;quot;the item has that attribute but does not have any attribute values&amp;quot;.
If store.hasAttribute(item, attribute) returns false, then
store.getValue(item, attribute) will return undefined.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var darthVader = store.getValue(lukeSkywalker, &amp;quot;father&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getValues" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>an array that may contain literals and items</return-description><summary>&lt;p>This getValues() method works just like the getValue() method, but getValues()
always returns an array rather than a single attribute value.  The array
may be empty, may contain a single attribute value, or may contain
many attribute values.
If the item does not have a value for the given attribute, then getValues()
will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
has a return of false, then store.getValues(item, attribute) will return [].)&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var friendsOfLuke = store.getValues(lukeSkywalker, &amp;quot;friends&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns an array with all the attributes that this item has.  This
method will always return an array; if the item has no attributes
at all, getAttributes() will return an empty array: [].&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var array = store.getAttributes(kermit);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>item&lt;/em> has a value for the given &lt;em>attribute&lt;/em>.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.hasAttribute(kermit, &amp;quot;color&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match as a value for the attribute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>value&lt;/em> is one of the values that getValues()
would return.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.containsValue(kermit, &amp;quot;color&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if &lt;em>something&lt;/em> is an item and came from the store instance.
Returns false if &lt;em>something&lt;/em> is a literal, an item from another store instance,
or is any object other than an item.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItem(store.newItem());
  var no  = store.isItem(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns false if isItem(something) is false.  Returns false if
if isItem(something) is true but the the item is not yet loaded
in local memory (for example, if the item has not yet been read
from the server).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItemLoaded(store.newItem());
  var no  = store.isItemLoaded(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>An anonymous object that defines the item to load and callbacks to invoke when the
load has completed.  The format of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    item: object,
    onItem: Function,
    onError: Function,
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>item&lt;/em> parameter&lt;/h4>
&lt;p>The item parameter is an object that represents the item in question that should be
contained by the store.  This attribute is required.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter&lt;/h4>
&lt;p>Function(item)
The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
parameter, the fully loaded item.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter&lt;/h4>
&lt;p>Function(error)
The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
parameter, the error object

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onError, etc) will be invoked in the context of the scope object.
In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given an item, this method loads the item so that a subsequent call
to store.isItemLoaded(item) will return true.  If a call to
isItemLoaded() returns true before loadItem() is even called,
then loadItem() need not do any work at all and will not even invoke
the callback handlers.  So, before invoking this method, check that
the item has not already been loaded.&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean   // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The fetch() method will return a javascript object conforming to the API
defined in dojo/data/api/Request.  In general, it will be the keywordArgs
object returned with the required functions in Request.js attached.
Its general purpose is to provide a convenient way for a caller to abort an
ongoing fetch.

The Request object may also have additional properties when it is returned
such as request.store property, which is a pointer to the datastore object that
fetch() is a method of.</return-description><summary>&lt;p>Given a query and set of defined options, such as a start and count of items to return,
this method executes the query and makes the results available as data items.
The format and expectations of stores is that they operate in a generally asynchronous
manner, therefore callbacks are always used to return items located by the fetch parameters.&lt;/p>
</summary><description>&lt;p>A Request object will always be returned and is returned immediately.
The basic request is nothing more than the keyword args passed to fetch and
an additional function attached, abort().  The returned request object may then be used
to cancel a fetch.  All data items returns are passed through the callbacks defined in the
fetch parameters and are not present on the &amp;#39;request&amp;#39; object.

&lt;/p>
&lt;p>This does not mean that custom stores can not add methods and properties to the request object
returned, only that the API does not require it.  For more info about the Request API,
see dojo/data/api/Request&lt;/p>
</description><examples><example>&lt;p>Fetch all books identified by the query and call &amp;#39;showBooks&amp;#39; when complete&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items in the story and call &amp;#39;showEverything&amp;#39; when complete.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch(onComplete: showEverything);&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch only 10 books that match the query &amp;#39;all books&amp;#39;, starting at the fifth book found during the search.
This demonstrates how paging can be done for specific queries.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, start: 4, count: 10, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items that match the query, calling &amp;#39;callback&amp;#39; each time an item is located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;foo/bar&amp;quot;, onItem:callback});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, sort: [{ attribute: &amp;quot;title&amp;quot;, descending: true}, {attribute: &amp;quot;publisher&amp;quot;}], ,start: 0, count:100, onComplete: &amp;#39;showKing&amp;#39;});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King*&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors ending with &amp;#39;ing&amp;#39;, but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;?ing&amp;quot;}, start: 0, count:100, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Paging&lt;/p>
&lt;pre>&lt;code>  var store = new LargeRdbmsStore({url:&amp;quot;jdbc:odbc:foobar&amp;quot;});
  var fetchArgs = {
    query: {type:&amp;quot;employees&amp;quot;, name:&amp;quot;Hillary *&amp;quot;}, // string matching
    sort: [{attribute:&amp;quot;department&amp;quot;, descending:true}],
    start: 0,
    count: 20,
    scope: displayer,
    onBegin: showThrobber,
    onItem: displayItem,
    onComplete: stopThrobber,
    onError: handleFetchError,
  };
  store.fetch(fetchArgs);
  ...&lt;/code>&lt;/pre>
&lt;p>and then when the user presses the &amp;quot;Next Page&amp;quot; button...&lt;/p>
&lt;pre>&lt;code>  fetchArgs.start += 20;
  store.fetch(fetchArgs);  // get the next 20 items&lt;/code>&lt;/pre>
</example></examples></method><method name="close" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="request" type="dojo/data/api/Request|Object" usage="optional"><summary>&lt;p>An instance of a request for the store to use to identify what to close out.
If no request is passed, then the store should clear all internal caches (if any)
and close out all &amp;#39;open&amp;#39; connections.  It does not render the store unusable from
there on, it merely cleans out any current data and resets the store to initial
state.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.&lt;/p>
</summary><description>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.  In general, this API
expects to receive as a parameter a request object returned from a fetch.
It will then close out anything associated with that request, such as
clearing any internal datastore caches and closing any &amp;#39;open&amp;#39; connections.
For some store implementations, this call may be a no-op.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var request = store.fetch({onComplete: doSomething});
  ...
  store.close(request);&lt;/code>&lt;/pre>
</example></examples></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the label for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A user-readable string representing the item or undefined if no user-readable label can
be generated.</return-description><summary>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.  In general
most labels will be a specific attribute value or collection of the attribute
values that combine to label the item in some manner.  For example for an item
that represents a person it may return the label as:  &amp;quot;firstname lastlame&amp;quot; where
the firstname and lastname are attributes on the item.  If the store is unable
to determine an adequate human readable label, it should return undefined.  Users that wish
to customize how a store instance labels items should replace the getLabel() function on
their instance of the store, or extend the store and replace the function in
the extension class.&lt;/p>
</description></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the list of label attributes for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>An array of attribute names that were used to generate the label, or null if public attributes
were not used to generate the label.</return-description><summary>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.  This function is to assist UI developers in knowing what
attributes can be ignored out of the attributes an item has when displaying it, in cases
where the UI is using the label as an overall identifer should they wish to hide
redundant information.&lt;/p>
</description></method></methods><mixins><mixin location="dojo/data/api/Read"/></mixins><summary>&lt;p>This is an abstract API that data provider implementations conform to.
This file defines methods signatures and intentionally leaves all the
methods unimplemented.&lt;/p>
</summary></object><object location="dojo/data/api/Read" type="constructor" classlike="true"><properties/><methods><method name="getValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="value" usage="optional"><summary>&lt;p>Optional.  A default value to use for the getValue return in the attribute does not exist or has no value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>a literal, an item, null, or undefined (never an array)</return-description><summary>&lt;p>Returns a single attribute value.
Returns defaultValue if and only if &lt;em>item&lt;/em> does not have a value for &lt;em>attribute&lt;/em>.
Returns null if and only if null was explicitly set as the attribute value.
Returns undefined if and only if the item does not have a value for the
given attribute (which is the same as saying the item does not have the attribute).&lt;/p>
</summary><description>&lt;p>Saying that an &amp;quot;item x does not have a value for an attribute y&amp;quot;
is identical to saying that an &amp;quot;item x does not have attribute y&amp;quot;.
It is an oxymoron to say &amp;quot;that attribute is present but has no values&amp;quot;
or &amp;quot;the item has that attribute but does not have any attribute values&amp;quot;.
If store.hasAttribute(item, attribute) returns false, then
store.getValue(item, attribute) will return undefined.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var darthVader = store.getValue(lukeSkywalker, &amp;quot;father&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getValues" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>an array that may contain literals and items</return-description><summary>&lt;p>This getValues() method works just like the getValue() method, but getValues()
always returns an array rather than a single attribute value.  The array
may be empty, may contain a single attribute value, or may contain
many attribute values.
If the item does not have a value for the given attribute, then getValues()
will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
has a return of false, then store.getValues(item, attribute) will return [].)&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var friendsOfLuke = store.getValues(lukeSkywalker, &amp;quot;friends&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns an array with all the attributes that this item has.  This
method will always return an array; if the item has no attributes
at all, getAttributes() will return an empty array: [].&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var array = store.getAttributes(kermit);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>item&lt;/em> has a value for the given &lt;em>attribute&lt;/em>.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.hasAttribute(kermit, &amp;quot;color&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match as a value for the attribute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>value&lt;/em> is one of the values that getValues()
would return.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.containsValue(kermit, &amp;quot;color&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if &lt;em>something&lt;/em> is an item and came from the store instance.
Returns false if &lt;em>something&lt;/em> is a literal, an item from another store instance,
or is any object other than an item.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItem(store.newItem());
  var no  = store.isItem(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns false if isItem(something) is false.  Returns false if
if isItem(something) is true but the the item is not yet loaded
in local memory (for example, if the item has not yet been read
from the server).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItemLoaded(store.newItem());
  var no  = store.isItemLoaded(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>An anonymous object that defines the item to load and callbacks to invoke when the
load has completed.  The format of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    item: object,
    onItem: Function,
    onError: Function,
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>item&lt;/em> parameter&lt;/h4>
&lt;p>The item parameter is an object that represents the item in question that should be
contained by the store.  This attribute is required.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter&lt;/h4>
&lt;p>Function(item)
The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
parameter, the fully loaded item.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter&lt;/h4>
&lt;p>Function(error)
The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
parameter, the error object

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onError, etc) will be invoked in the context of the scope object.
In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given an item, this method loads the item so that a subsequent call
to store.isItemLoaded(item) will return true.  If a call to
isItemLoaded() returns true before loadItem() is even called,
then loadItem() need not do any work at all and will not even invoke
the callback handlers.  So, before invoking this method, check that
the item has not already been loaded.&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean   // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The fetch() method will return a javascript object conforming to the API
defined in dojo/data/api/Request.  In general, it will be the keywordArgs
object returned with the required functions in Request.js attached.
Its general purpose is to provide a convenient way for a caller to abort an
ongoing fetch.

The Request object may also have additional properties when it is returned
such as request.store property, which is a pointer to the datastore object that
fetch() is a method of.</return-description><summary>&lt;p>Given a query and set of defined options, such as a start and count of items to return,
this method executes the query and makes the results available as data items.
The format and expectations of stores is that they operate in a generally asynchronous
manner, therefore callbacks are always used to return items located by the fetch parameters.&lt;/p>
</summary><description>&lt;p>A Request object will always be returned and is returned immediately.
The basic request is nothing more than the keyword args passed to fetch and
an additional function attached, abort().  The returned request object may then be used
to cancel a fetch.  All data items returns are passed through the callbacks defined in the
fetch parameters and are not present on the &amp;#39;request&amp;#39; object.

&lt;/p>
&lt;p>This does not mean that custom stores can not add methods and properties to the request object
returned, only that the API does not require it.  For more info about the Request API,
see dojo/data/api/Request&lt;/p>
</description><examples><example>&lt;p>Fetch all books identified by the query and call &amp;#39;showBooks&amp;#39; when complete&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items in the story and call &amp;#39;showEverything&amp;#39; when complete.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch(onComplete: showEverything);&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch only 10 books that match the query &amp;#39;all books&amp;#39;, starting at the fifth book found during the search.
This demonstrates how paging can be done for specific queries.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, start: 4, count: 10, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items that match the query, calling &amp;#39;callback&amp;#39; each time an item is located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;foo/bar&amp;quot;, onItem:callback});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, sort: [{ attribute: &amp;quot;title&amp;quot;, descending: true}, {attribute: &amp;quot;publisher&amp;quot;}], ,start: 0, count:100, onComplete: &amp;#39;showKing&amp;#39;});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King*&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors ending with &amp;#39;ing&amp;#39;, but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;?ing&amp;quot;}, start: 0, count:100, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Paging&lt;/p>
&lt;pre>&lt;code>  var store = new LargeRdbmsStore({url:&amp;quot;jdbc:odbc:foobar&amp;quot;});
  var fetchArgs = {
    query: {type:&amp;quot;employees&amp;quot;, name:&amp;quot;Hillary *&amp;quot;}, // string matching
    sort: [{attribute:&amp;quot;department&amp;quot;, descending:true}],
    start: 0,
    count: 20,
    scope: displayer,
    onBegin: showThrobber,
    onItem: displayItem,
    onComplete: stopThrobber,
    onError: handleFetchError,
  };
  store.fetch(fetchArgs);
  ...&lt;/code>&lt;/pre>
&lt;p>and then when the user presses the &amp;quot;Next Page&amp;quot; button...&lt;/p>
&lt;pre>&lt;code>  fetchArgs.start += 20;
  store.fetch(fetchArgs);  // get the next 20 items&lt;/code>&lt;/pre>
</example></examples></method><method name="getFeatures" scope="prototype" type="function" from="dojo/data/api/Read"><parameters/><return-types><return-type type="object"/></return-types><summary>&lt;p>The getFeatures() method returns an simple keyword values object
that specifies what interface features the datastore implements.
A simple CsvStore may be read-only, and the only feature it
implements will be the &amp;#39;dojo/data/api/Read&amp;#39; interface, so the
getFeatures() method will return an object like this one:
{&amp;#39;dojo.data.api.Read&amp;#39;: true}.
A more sophisticated datastore might implement a variety of
interface features, like &amp;#39;dojo.data.api.Read&amp;#39;, &amp;#39;dojo/data/api/Write&amp;#39;,
&amp;#39;dojo.data.api.Identity&amp;#39;, and &amp;#39;dojo/data/api/Attribution&amp;#39;.&lt;/p>
</summary></method><method name="close" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="request" type="dojo/data/api/Request|Object" usage="optional"><summary>&lt;p>An instance of a request for the store to use to identify what to close out.
If no request is passed, then the store should clear all internal caches (if any)
and close out all &amp;#39;open&amp;#39; connections.  It does not render the store unusable from
there on, it merely cleans out any current data and resets the store to initial
state.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.&lt;/p>
</summary><description>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.  In general, this API
expects to receive as a parameter a request object returned from a fetch.
It will then close out anything associated with that request, such as
clearing any internal datastore caches and closing any &amp;#39;open&amp;#39; connections.
For some store implementations, this call may be a no-op.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var request = store.fetch({onComplete: doSomething});
  ...
  store.close(request);&lt;/code>&lt;/pre>
</example></examples></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the label for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A user-readable string representing the item or undefined if no user-readable label can
be generated.</return-description><summary>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.  In general
most labels will be a specific attribute value or collection of the attribute
values that combine to label the item in some manner.  For example for an item
that represents a person it may return the label as:  &amp;quot;firstname lastlame&amp;quot; where
the firstname and lastname are attributes on the item.  If the store is unable
to determine an adequate human readable label, it should return undefined.  Users that wish
to customize how a store instance labels items should replace the getLabel() function on
their instance of the store, or extend the store and replace the function in
the extension class.&lt;/p>
</description></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the list of label attributes for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>An array of attribute names that were used to generate the label, or null if public attributes
were not used to generate the label.</return-description><summary>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.  This function is to assist UI developers in knowing what
attributes can be ignored out of the attributes an item has when displaying it, in cases
where the UI is using the label as an overall identifer should they wish to hide
redundant information.&lt;/p>
</description></method></methods><summary>&lt;p>This is an abstract API that data provider implementations conform to.
This file defines methods signatures and intentionally leaves all the
methods unimplemented.  For more information on the dojo.data APIs,
please visit: &lt;a href=&quot;http://www.dojotoolkit.org/node/98&quot;>http://www.dojotoolkit.org/node/98&lt;/a>&lt;/p>
</summary></object><object location="dojo/data/api/Item" type="constructor" classlike="true"><properties/><methods/><summary>&lt;p>An item in a dojo/data store
Class for documentation purposes only. An item can take any form, so no
properties or methods are defined here.&lt;/p>
</summary></object><object location="dojo/data/api/Notification" type="constructor" classlike="true" superclass="dojo/data/api/Read"><properties/><methods><method name="getFeatures" scope="prototype" type="function" from="dojo/data/api/Notification"><parameters/><return-types><return-type type="object"/></return-types><summary>&lt;p>See dojo/data/api/Read.getFeatures()&lt;/p>
</summary></method><method name="onSet" scope="prototype" type="function" from="dojo/data/api/Notification"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item being modified.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute being changed represented as a string name.&lt;/p>
</summary></parameter><parameter name="oldValue" type="object|array" usage="required"><summary>&lt;p>The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,
this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case of
multi-valued attributes, it will be an array.&lt;/p>
</summary></parameter><parameter name="newValue" type="object|array" usage="required"><summary>&lt;p>The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
it will be an array.  In the case of unsetAttribute, the new value will be &amp;#39;undefined&amp;#39;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Nothing.</return-description><summary>&lt;p>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.&lt;/p>
</summary><description>&lt;p>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
in a simple manner.  The general expected usage is to dojo.connect() to the store&amp;#39;s
implementation and be called after the store function is called.&lt;/p>
</description></method><method name="onNew" scope="prototype" type="function" from="dojo/data/api/Notification"><parameters><parameter name="newItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item created.&lt;/p>
</summary></parameter><parameter name="parentInfo" type="object" usage="optional"><summary>&lt;p>An optional javascript object that is passed when the item created was placed in the store
hierarchy as a value f another item&amp;#39;s attribute, instead of a root level item.  Note that if this
function is invoked with a value for parentInfo, then onSet is not invoked stating the attribute of
the parent item was modified.  This is to avoid getting two notification  events occurring when a new item
with a parent is created.  The structure passed in is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    item: someItem,              //The parent item
    attribute:  &amp;quot;attribute-name-string&amp;quot;,  //The attribute the new item was assigned to.
    oldValue: something  //Whatever was the previous value for the attribute.
          //If it is a single-value attribute only, then this value will be a single value.
          //If it was a multi-valued attribute, then this will be an array of all the values minus the new one.
    newValue: something  //The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
          //generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
          //it will be an array.
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Nothing.</return-description><summary>&lt;p>This function is called any time a new item is created in the store.
It is called immediately after the store newItem processing has completed.&lt;/p>
</summary><description>&lt;p>This function is called any time a new item is created in the store.
It is called immediately after the store newItem processing has completed.&lt;/p>
</description></method><method name="onDelete" scope="prototype" type="function" from="dojo/data/api/Notification"><parameters><parameter name="deletedItem" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item deleted.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Nothing.</return-description><summary>&lt;p>This function is called any time an item is deleted from the store.
It is called immediately after the store deleteItem processing has completed.&lt;/p>
</summary><description>&lt;p>This function is called any time an item is deleted from the store.
It is called immediately after the store deleteItem processing has completed.&lt;/p>
</description></method><method name="getValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="value" usage="optional"><summary>&lt;p>Optional.  A default value to use for the getValue return in the attribute does not exist or has no value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>a literal, an item, null, or undefined (never an array)</return-description><summary>&lt;p>Returns a single attribute value.
Returns defaultValue if and only if &lt;em>item&lt;/em> does not have a value for &lt;em>attribute&lt;/em>.
Returns null if and only if null was explicitly set as the attribute value.
Returns undefined if and only if the item does not have a value for the
given attribute (which is the same as saying the item does not have the attribute).&lt;/p>
</summary><description>&lt;p>Saying that an &amp;quot;item x does not have a value for an attribute y&amp;quot;
is identical to saying that an &amp;quot;item x does not have attribute y&amp;quot;.
It is an oxymoron to say &amp;quot;that attribute is present but has no values&amp;quot;
or &amp;quot;the item has that attribute but does not have any attribute values&amp;quot;.
If store.hasAttribute(item, attribute) returns false, then
store.getValue(item, attribute) will return undefined.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var darthVader = store.getValue(lukeSkywalker, &amp;quot;father&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getValues" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>an array that may contain literals and items</return-description><summary>&lt;p>This getValues() method works just like the getValue() method, but getValues()
always returns an array rather than a single attribute value.  The array
may be empty, may contain a single attribute value, or may contain
many attribute values.
If the item does not have a value for the given attribute, then getValues()
will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
has a return of false, then store.getValues(item, attribute) will return [].)&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var friendsOfLuke = store.getValues(lukeSkywalker, &amp;quot;friends&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns an array with all the attributes that this item has.  This
method will always return an array; if the item has no attributes
at all, getAttributes() will return an empty array: [].&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var array = store.getAttributes(kermit);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>item&lt;/em> has a value for the given &lt;em>attribute&lt;/em>.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.hasAttribute(kermit, &amp;quot;color&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match as a value for the attribute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>value&lt;/em> is one of the values that getValues()
would return.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.containsValue(kermit, &amp;quot;color&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if &lt;em>something&lt;/em> is an item and came from the store instance.
Returns false if &lt;em>something&lt;/em> is a literal, an item from another store instance,
or is any object other than an item.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItem(store.newItem());
  var no  = store.isItem(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns false if isItem(something) is false.  Returns false if
if isItem(something) is true but the the item is not yet loaded
in local memory (for example, if the item has not yet been read
from the server).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItemLoaded(store.newItem());
  var no  = store.isItemLoaded(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>An anonymous object that defines the item to load and callbacks to invoke when the
load has completed.  The format of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    item: object,
    onItem: Function,
    onError: Function,
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>item&lt;/em> parameter&lt;/h4>
&lt;p>The item parameter is an object that represents the item in question that should be
contained by the store.  This attribute is required.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter&lt;/h4>
&lt;p>Function(item)
The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
parameter, the fully loaded item.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter&lt;/h4>
&lt;p>Function(error)
The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
parameter, the error object

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onError, etc) will be invoked in the context of the scope object.
In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given an item, this method loads the item so that a subsequent call
to store.isItemLoaded(item) will return true.  If a call to
isItemLoaded() returns true before loadItem() is even called,
then loadItem() need not do any work at all and will not even invoke
the callback handlers.  So, before invoking this method, check that
the item has not already been loaded.&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean   // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The fetch() method will return a javascript object conforming to the API
defined in dojo/data/api/Request.  In general, it will be the keywordArgs
object returned with the required functions in Request.js attached.
Its general purpose is to provide a convenient way for a caller to abort an
ongoing fetch.

The Request object may also have additional properties when it is returned
such as request.store property, which is a pointer to the datastore object that
fetch() is a method of.</return-description><summary>&lt;p>Given a query and set of defined options, such as a start and count of items to return,
this method executes the query and makes the results available as data items.
The format and expectations of stores is that they operate in a generally asynchronous
manner, therefore callbacks are always used to return items located by the fetch parameters.&lt;/p>
</summary><description>&lt;p>A Request object will always be returned and is returned immediately.
The basic request is nothing more than the keyword args passed to fetch and
an additional function attached, abort().  The returned request object may then be used
to cancel a fetch.  All data items returns are passed through the callbacks defined in the
fetch parameters and are not present on the &amp;#39;request&amp;#39; object.

&lt;/p>
&lt;p>This does not mean that custom stores can not add methods and properties to the request object
returned, only that the API does not require it.  For more info about the Request API,
see dojo/data/api/Request&lt;/p>
</description><examples><example>&lt;p>Fetch all books identified by the query and call &amp;#39;showBooks&amp;#39; when complete&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items in the story and call &amp;#39;showEverything&amp;#39; when complete.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch(onComplete: showEverything);&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch only 10 books that match the query &amp;#39;all books&amp;#39;, starting at the fifth book found during the search.
This demonstrates how paging can be done for specific queries.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, start: 4, count: 10, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items that match the query, calling &amp;#39;callback&amp;#39; each time an item is located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;foo/bar&amp;quot;, onItem:callback});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, sort: [{ attribute: &amp;quot;title&amp;quot;, descending: true}, {attribute: &amp;quot;publisher&amp;quot;}], ,start: 0, count:100, onComplete: &amp;#39;showKing&amp;#39;});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King*&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors ending with &amp;#39;ing&amp;#39;, but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;?ing&amp;quot;}, start: 0, count:100, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Paging&lt;/p>
&lt;pre>&lt;code>  var store = new LargeRdbmsStore({url:&amp;quot;jdbc:odbc:foobar&amp;quot;});
  var fetchArgs = {
    query: {type:&amp;quot;employees&amp;quot;, name:&amp;quot;Hillary *&amp;quot;}, // string matching
    sort: [{attribute:&amp;quot;department&amp;quot;, descending:true}],
    start: 0,
    count: 20,
    scope: displayer,
    onBegin: showThrobber,
    onItem: displayItem,
    onComplete: stopThrobber,
    onError: handleFetchError,
  };
  store.fetch(fetchArgs);
  ...&lt;/code>&lt;/pre>
&lt;p>and then when the user presses the &amp;quot;Next Page&amp;quot; button...&lt;/p>
&lt;pre>&lt;code>  fetchArgs.start += 20;
  store.fetch(fetchArgs);  // get the next 20 items&lt;/code>&lt;/pre>
</example></examples></method><method name="close" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="request" type="dojo/data/api/Request|Object" usage="optional"><summary>&lt;p>An instance of a request for the store to use to identify what to close out.
If no request is passed, then the store should clear all internal caches (if any)
and close out all &amp;#39;open&amp;#39; connections.  It does not render the store unusable from
there on, it merely cleans out any current data and resets the store to initial
state.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.&lt;/p>
</summary><description>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.  In general, this API
expects to receive as a parameter a request object returned from a fetch.
It will then close out anything associated with that request, such as
clearing any internal datastore caches and closing any &amp;#39;open&amp;#39; connections.
For some store implementations, this call may be a no-op.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var request = store.fetch({onComplete: doSomething});
  ...
  store.close(request);&lt;/code>&lt;/pre>
</example></examples></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the label for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A user-readable string representing the item or undefined if no user-readable label can
be generated.</return-description><summary>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.  In general
most labels will be a specific attribute value or collection of the attribute
values that combine to label the item in some manner.  For example for an item
that represents a person it may return the label as:  &amp;quot;firstname lastlame&amp;quot; where
the firstname and lastname are attributes on the item.  If the store is unable
to determine an adequate human readable label, it should return undefined.  Users that wish
to customize how a store instance labels items should replace the getLabel() function on
their instance of the store, or extend the store and replace the function in
the extension class.&lt;/p>
</description></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the list of label attributes for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>An array of attribute names that were used to generate the label, or null if public attributes
were not used to generate the label.</return-description><summary>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.  This function is to assist UI developers in knowing what
attributes can be ignored out of the attributes an item has when displaying it, in cases
where the UI is using the label as an overall identifer should they wish to hide
redundant information.&lt;/p>
</description></method></methods><mixins><mixin location="dojo/data/api/Read"/></mixins><summary>&lt;p>This is an abstract API that data provider implementations conform to.
This file defines functions signatures and intentionally leaves all the
functions unimplemented.&lt;/p>
</summary><description>&lt;p>This API defines a set of APIs that all datastores that conform to the
Notifications API must implement.  In general, most stores will implement
these APIs as no-op functions for users who wish to monitor them to be able
to connect to then via dojo.connect().  For non-users of dojo.connect,
they should be able to just replace the function on the store to obtain
notifications.  Both read-only and read-write stores may implement
this feature.  In the case of a read-only store, this feature makes sense if
the store itself does internal polling to a back-end server and periodically updates
its cache of items (deletes, adds, and updates).&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  function onSet(item, attribute, oldValue, newValue){
    //Do something with the information...
  };
  var store = new some.newStore();
  dojo.connect(store, &amp;quot;onSet&amp;quot;, onSet);&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/data/api/Request" type="constructor" classlike="true"><properties/><methods><method name="abort" scope="prototype" type="function" from="dojo/data/api/Request"><parameters/><return-types/><summary>&lt;p>This function is a hook point for stores to provide as a way for
a fetch to be halted mid-processing.&lt;/p>
</summary><description>&lt;p>This function is a hook point for stores to provide as a way for
a fetch to be halted mid-processing.  For more details on the fetch() api,
please see dojo/data/api/Read.fetch().&lt;/p>
</description></method></methods><summary>&lt;p>This class defines out the semantics of what a &amp;#39;Request&amp;#39; object looks like
when returned from a fetch() method.  In general, a request object is
nothing more than the original keywordArgs from fetch with an abort function
attached to it to allow users to abort a particular request if they so choose.
No other functions are required on a general Request object return.  That does not
inhibit other store implementations from adding extensions to it, of course.

&lt;/p>
&lt;p>This is an abstract API that data provider implementations conform to.
This file defines methods signatures and intentionally leaves all the
methods unimplemented.

&lt;/p>
&lt;p>For more details on fetch, see dojo/data/api/Read.fetch().&lt;/p>
</summary></object><object location="dojo/data/api/Write" type="constructor" classlike="true" superclass="dojo/data/api/Read"><properties/><methods><method name="getFeatures" scope="prototype" type="function" from="dojo/data/api/Write"><parameters/><return-types><return-type type="object"/></return-types><summary>&lt;p>See dojo/data/api/Read.getFeatures()&lt;/p>
</summary></method><method name="newItem" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="keywordArgs" type="Object" usage="optional"><summary>&lt;p>A javascript object defining the initial content of the item as a set of JavaScript &amp;#39;property name: value&amp;#39; pairs.&lt;/p>
</summary></parameter><parameter name="parentInfo" type="Object" usage="optional"><summary>&lt;p>An optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),
and what attribute of that parent to assign the new item to.  If this is present, and the attribute specified
is a multi-valued attribute, it will append this item into the array of values for that attribute.  The structure
of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    parent: someItem,
    attribute: &amp;quot;attribute-name-string&amp;quot;
  }&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a newly created item.  Sets the attributes of the new
item based on the &lt;em>keywordArgs&lt;/em> provided.  In general, the attribute
names in the keywords become the attributes in the new item and as for
the attribute values in keywordArgs, they become the values of the attributes
in the new item.  In addition, for stores that support hierarchical item
creation, an optional second parameter is accepted that defines what item is the parent
of the new item and what attribute of that item should the new item be assigned to.
In general, this will assume that the attribute targeted is multi-valued and a new item
is appended onto the list of values for that attribute.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var kermit = store.newItem({name: &amp;quot;Kermit&amp;quot;, color:[blue, green]});&lt;/code>&lt;/pre>
</example></examples></method><method name="deleteItem" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to delete.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deletes an item from the store.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var success = store.deleteItem(kermit);&lt;/code>&lt;/pre>
</example></examples></method><method name="setValue" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to modify.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute of the item to change represented as a string name.&lt;/p>
</summary></parameter><parameter name="value" type="almost anything" usage="required"><summary>&lt;p>The value to assign to the item.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the value of an attribute on an item.
Replaces any previous value or values.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var success = store.set(kermit, &amp;quot;color&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setValues" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to modify.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute of the item to change represented as a string name.&lt;/p>
</summary></parameter><parameter name="values" type="array" usage="required"><summary>&lt;p>An array of values to assign to the attribute..&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds each value in the &lt;em>values&lt;/em> array as a value of the given
attribute on the given item.
Replaces any previous value or values.
Calling store.setValues(x, y, []) (with &lt;em>values&lt;/em> as an empty array) has
the same effect as calling store.unsetAttribute(x, y).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var success = store.setValues(kermit, &amp;quot;color&amp;quot;, [&amp;quot;green&amp;quot;, &amp;quot;aqua&amp;quot;]);
  success = store.setValues(kermit, &amp;quot;color&amp;quot;, []);
  if (success){assert(!store.hasAttribute(kermit, &amp;quot;color&amp;quot;));}&lt;/code>&lt;/pre>
</example></examples></method><method name="unsetAttribute" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to modify.&lt;/p>
</summary></parameter><parameter name="attribute" type="string" usage="required"><summary>&lt;p>The attribute of the item to unset represented as a string.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deletes all the values of an attribute on an item.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var success = store.unsetAttribute(kermit, &amp;quot;color&amp;quot;);
  if (success){assert(!store.hasAttribute(kermit, &amp;quot;color&amp;quot;));}&lt;/code>&lt;/pre>
</example></examples></method><method name="save" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="keywordArgs" type="object" usage="required"><summary>&lt;pre>&lt;code>  {
    onComplete: function
    onError: function
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function();

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the save has completed.  No parameters
are generally passed to the onComplete.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the save.  The onError function will be based one parameter, the
error.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback function (
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global.
For example, onComplete.call(scope) vs.
onComplete.call(dojo.global)&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>Nothing.  Since the saves are generally asynchronous, there is
no need to return anything.  All results are passed via callbacks.</return-description><summary>&lt;p>Saves to the server all the changes that have been made locally.
The save operation may take some time and is generally performed
in an asynchronous fashion.  The outcome of the save action is
is passed into the set of supported callbacks for the save.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  store.save({onComplete: onSave});
  store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});&lt;/code>&lt;/pre>
</example></examples></method><method name="revert" scope="prototype" type="function" from="dojo/data/api/Write"><parameters/><return-types/><summary>&lt;p>Discards any unsaved changes.&lt;/p>
</summary><description>&lt;p>Discards any unsaved changes.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var success = store.revert();&lt;/code>&lt;/pre>
</example></examples></method><method name="isDirty" scope="prototype" type="function" from="dojo/data/api/Write"><parameters><parameter name="item" type="item" usage="optional"><summary>&lt;p>The item to check.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given an item, isDirty() returns true if the item has been modified
since the last save().  If isDirty() is called with no &lt;em>item&lt;/em> argument,
then this function returns true if any item has been modified since
the last save().&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
  var trueOrFalse = store.isDirty();       // true if any item is dirty&lt;/code>&lt;/pre>
</example></examples></method><method name="getValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="value" usage="optional"><summary>&lt;p>Optional.  A default value to use for the getValue return in the attribute does not exist or has no value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>a literal, an item, null, or undefined (never an array)</return-description><summary>&lt;p>Returns a single attribute value.
Returns defaultValue if and only if &lt;em>item&lt;/em> does not have a value for &lt;em>attribute&lt;/em>.
Returns null if and only if null was explicitly set as the attribute value.
Returns undefined if and only if the item does not have a value for the
given attribute (which is the same as saying the item does not have the attribute).&lt;/p>
</summary><description>&lt;p>Saying that an &amp;quot;item x does not have a value for an attribute y&amp;quot;
is identical to saying that an &amp;quot;item x does not have attribute y&amp;quot;.
It is an oxymoron to say &amp;quot;that attribute is present but has no values&amp;quot;
or &amp;quot;the item has that attribute but does not have any attribute values&amp;quot;.
If store.hasAttribute(item, attribute) returns false, then
store.getValue(item, attribute) will return undefined.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var darthVader = store.getValue(lukeSkywalker, &amp;quot;father&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getValues" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>an array that may contain literals and items</return-description><summary>&lt;p>This getValues() method works just like the getValue() method, but getValues()
always returns an array rather than a single attribute value.  The array
may be empty, may contain a single attribute value, or may contain
many attribute values.
If the item does not have a value for the given attribute, then getValues()
will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
has a return of false, then store.getValues(item, attribute) will return [].)&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var friendsOfLuke = store.getValues(lukeSkywalker, &amp;quot;friends&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="getAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns an array with all the attributes that this item has.  This
method will always return an array; if the item has no attributes
at all, getAttributes() will return an empty array: [].&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var array = store.getAttributes(kermit);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttribute" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access attributes on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>item&lt;/em> has a value for the given &lt;em>attribute&lt;/em>.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.hasAttribute(kermit, &amp;quot;color&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="containsValue" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to access values on.&lt;/p>
</summary></parameter><parameter name="attribute" type="attribute-name-string" usage="required"><summary>&lt;p>The attribute to access represented as a string.&lt;/p>
</summary></parameter><parameter name="value" type="anything" usage="required"><summary>&lt;p>The value to match as a value for the attribute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if the given &lt;em>value&lt;/em> is one of the values that getValues()
would return.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var trueOrFalse = store.containsValue(kermit, &amp;quot;color&amp;quot;, &amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if &lt;em>something&lt;/em> is an item and came from the store instance.
Returns false if &lt;em>something&lt;/em> is a literal, an item from another store instance,
or is any object other than an item.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItem(store.newItem());
  var no  = store.isItem(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="isItemLoaded" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="something" type="anything" usage="required"><summary>&lt;p>Can be anything.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns false if isItem(something) is false.  Returns false if
if isItem(something) is true but the the item is not yet loaded
in local memory (for example, if the item has not yet been read
from the server).&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var yes = store.isItemLoaded(store.newItem());
  var no  = store.isItemLoaded(&amp;quot;green&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="loadItem" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>An anonymous object that defines the item to load and callbacks to invoke when the
load has completed.  The format of the object is as follows:&lt;/p>
&lt;pre>&lt;code>  {
    item: object,
    onItem: Function,
    onError: Function,
    scope: object
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>item&lt;/em> parameter&lt;/h4>
&lt;p>The item parameter is an object that represents the item in question that should be
contained by the store.  This attribute is required.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter&lt;/h4>
&lt;p>Function(item)
The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
parameter, the fully loaded item.

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter&lt;/h4>
&lt;p>Function(error)
The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
parameter, the error object

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onError, etc) will be invoked in the context of the scope object.
In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Given an item, this method loads the item so that a subsequent call
to store.isItemLoaded(item) will return true.  If a call to
isItemLoaded() returns true before loadItem() is even called,
then loadItem() need not do any work at all and will not even invoke
the callback handlers.  So, before invoking this method, check that
the item has not already been loaded.&lt;/p>
</summary></method><method name="fetch" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="keywordArgs" type="Object" usage="required"><summary>&lt;p>The keywordArgs parameter may either be an instance of
conforming to dojo/data/api/Request or may be a simple anonymous object
that may contain any of the following:&lt;/p>
&lt;pre>&lt;code>  {
    query: query-object or query-string,
    queryOptions: object,
    onBegin: Function,
    onItem: Function,
    onComplete: Function,
    onError: Function,
    scope: object,
    start: int
    count: int
    sort: array
  }&lt;/code>&lt;/pre>
&lt;p>All implementations should accept keywordArgs objects with any of
the 9 standard properties: query, onBegin, onItem, onComplete, onError
scope, sort, start, and count.  Some implementations may accept additional
properties in the keywordArgs object as valid parameters, such as
{includeOutliers:true}.

&lt;/p>
&lt;h4>The &lt;em>query&lt;/em> parameter&lt;/h4>
&lt;p>The query may be optional in some data store implementations.
The dojo/data/api/Read API does not specify the syntax or semantics
of the query itself -- each different data store implementation
may have its own notion of what a query should look like.
However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
and dojox.data support an object structure query, where the object is a set of
name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
dijit widgets, such as ComboBox assume this to be the case when working with a datastore
when they dynamically update the query.  Therefore, for maximum compatibility with dijit
widgets the recommended query parameter is a key/value object.  That does not mean that the
the datastore may not take alternative query forms, such as a simple string, a Date, a number,
or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
format.

&lt;/p>
&lt;p>Further note:  In general for query objects that accept strings as attribute
value matches, the store should also support basic filtering capability, such as &lt;em>
(match any character) and ? (match single character).  An example query that is a query object
would be like: { attrFoo: &amp;quot;value&lt;/em>&amp;quot;}.  Which generally means match all items where they have
an attribute named attrFoo, with a value that starts with &amp;#39;value&amp;#39;.

&lt;/p>
&lt;h4>The &lt;em>queryOptions&lt;/em> parameter&lt;/h4>
&lt;p>The queryOptions parameter is an optional parameter used to specify options that may modify
the query in some fashion, such as doing a case insensitive search, or doing a deep search
where all items in a hierarchical representation of data are scanned instead of just the root
items.  It currently defines two options that all datastores should attempt to honor if possible:&lt;/p>
&lt;pre>&lt;code>  {
    ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
    deep: boolean   // Whether or not a fetch should do a deep search of items and all child
            // items instead of just root-level items in a datastore.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;h4>The &lt;em>onBegin&lt;/em> parameter.&lt;/h4>
&lt;p>function(size, request);
If an onBegin callback function is provided, the callback function
will be called just once, before the first onItem callback is called.
The onBegin callback function will be passed two arguments, the
the total number of items identified and the Request object.  If the total number is
unknown, then size will be -1.  Note that size is not necessarily the size of the
collection of items returned from the query, as the request may have specified to return only a
subset of the total set of items through the use of the start and count parameters.

&lt;/p>
&lt;h4>The &lt;em>onItem&lt;/em> parameter.&lt;/h4>
&lt;p>function(item, request);

&lt;/p>
&lt;p>If an onItem callback function is provided, the callback function
will be called as each item in the result is received. The callback
function will be passed two arguments: the item itself, and the
Request object.

&lt;/p>
&lt;h4>The &lt;em>onComplete&lt;/em> parameter.&lt;/h4>
&lt;p>function(items, request);

&lt;/p>
&lt;p>If an onComplete callback function is provided, the callback function
will be called just once, after the last onItem callback is called.
Note that if the onItem callback is not present, then onComplete will be passed
an array containing all items which matched the query and the request object.
If the onItem callback is present, then onComplete is called as:
onComplete(null, request).

&lt;/p>
&lt;h4>The &lt;em>onError&lt;/em> parameter.&lt;/h4>
&lt;p>function(errorData, request);

&lt;/p>
&lt;p>If an onError callback function is provided, the callback function
will be called if there is any sort of error while attempting to
execute the query.
The onError callback function will be passed two arguments:
an Error object and the Request object.

&lt;/p>
&lt;h4>The &lt;em>scope&lt;/em> parameter.&lt;/h4>
&lt;p>If a scope object is provided, all of the callback functions (onItem,
onComplete, onError, etc) will be invoked in the context of the scope
object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
keyword will be the scope object.   If no scope object is provided,
the callback functions will be called in the context of dojo.global().
For example, onItem.call(scope, item, request) vs.
onItem.call(dojo.global(), item, request)

&lt;/p>
&lt;h4>The &lt;em>start&lt;/em> parameter.&lt;/h4>
&lt;p>If a start parameter is specified, this is a indication to the datastore to
only start returning items once the start number of items have been located and
skipped.  When this parameter is paired with &amp;#39;count&amp;#39;, the store should be able
to page across queries with millions of hits by only returning subsets of the
hits for each query

&lt;/p>
&lt;h4>The &lt;em>count&lt;/em> parameter.&lt;/h4>
&lt;p>If a count parameter is specified, this is a indication to the datastore to
only return up to that many items.  This allows a fetch call that may have
millions of item matches to be paired down to something reasonable.

&lt;/p>
&lt;h4>The &lt;em>sort&lt;/em> parameter.&lt;/h4>
&lt;p>If a sort parameter is specified, this is a indication to the datastore to
sort the items in some manner before returning the items.  The array is an array of
javascript objects that must conform to the following format to be applied to the
fetching of items:&lt;/p>
&lt;pre>&lt;code>  {
    attribute: attribute || attribute-name-string,
    descending: true|false;   // Optional.  Default is false.
  }&lt;/code>&lt;/pre>
&lt;p>Note that when comparing attributes, if an item contains no value for the attribute
(undefined), then it the default ascending sort logic should push it to the bottom
of the list.  In the descending order case, it such items should appear at the top of the list.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The fetch() method will return a javascript object conforming to the API
defined in dojo/data/api/Request.  In general, it will be the keywordArgs
object returned with the required functions in Request.js attached.
Its general purpose is to provide a convenient way for a caller to abort an
ongoing fetch.

The Request object may also have additional properties when it is returned
such as request.store property, which is a pointer to the datastore object that
fetch() is a method of.</return-description><summary>&lt;p>Given a query and set of defined options, such as a start and count of items to return,
this method executes the query and makes the results available as data items.
The format and expectations of stores is that they operate in a generally asynchronous
manner, therefore callbacks are always used to return items located by the fetch parameters.&lt;/p>
</summary><description>&lt;p>A Request object will always be returned and is returned immediately.
The basic request is nothing more than the keyword args passed to fetch and
an additional function attached, abort().  The returned request object may then be used
to cancel a fetch.  All data items returns are passed through the callbacks defined in the
fetch parameters and are not present on the &amp;#39;request&amp;#39; object.

&lt;/p>
&lt;p>This does not mean that custom stores can not add methods and properties to the request object
returned, only that the API does not require it.  For more info about the Request API,
see dojo/data/api/Request&lt;/p>
</description><examples><example>&lt;p>Fetch all books identified by the query and call &amp;#39;showBooks&amp;#39; when complete&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items in the story and call &amp;#39;showEverything&amp;#39; when complete.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch(onComplete: showEverything);&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch only 10 books that match the query &amp;#39;all books&amp;#39;, starting at the fifth book found during the search.
This demonstrates how paging can be done for specific queries.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;all books&amp;quot;, start: 4, count: 10, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch all items that match the query, calling &amp;#39;callback&amp;#39; each time an item is located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:&amp;quot;foo/bar&amp;quot;, onItem:callback});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, sort: [{ attribute: &amp;quot;title&amp;quot;, descending: true}, {attribute: &amp;quot;publisher&amp;quot;}], ,start: 0, count:100, onComplete: &amp;#39;showKing&amp;#39;});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King*&amp;quot;}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by authors ending with &amp;#39;ing&amp;#39;, but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;?ing&amp;quot;}, start: 0, count:100, onComplete: showBooks});&lt;/code>&lt;/pre>
</example><example>&lt;p>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.&lt;/p>
&lt;pre>&lt;code>  var request = store.fetch({query:{author:&amp;quot;King&amp;quot;}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});&lt;/code>&lt;/pre>
</example><example>&lt;p>Paging&lt;/p>
&lt;pre>&lt;code>  var store = new LargeRdbmsStore({url:&amp;quot;jdbc:odbc:foobar&amp;quot;});
  var fetchArgs = {
    query: {type:&amp;quot;employees&amp;quot;, name:&amp;quot;Hillary *&amp;quot;}, // string matching
    sort: [{attribute:&amp;quot;department&amp;quot;, descending:true}],
    start: 0,
    count: 20,
    scope: displayer,
    onBegin: showThrobber,
    onItem: displayItem,
    onComplete: stopThrobber,
    onError: handleFetchError,
  };
  store.fetch(fetchArgs);
  ...&lt;/code>&lt;/pre>
&lt;p>and then when the user presses the &amp;quot;Next Page&amp;quot; button...&lt;/p>
&lt;pre>&lt;code>  fetchArgs.start += 20;
  store.fetch(fetchArgs);  // get the next 20 items&lt;/code>&lt;/pre>
</example></examples></method><method name="close" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="request" type="dojo/data/api/Request|Object" usage="optional"><summary>&lt;p>An instance of a request for the store to use to identify what to close out.
If no request is passed, then the store should clear all internal caches (if any)
and close out all &amp;#39;open&amp;#39; connections.  It does not render the store unusable from
there on, it merely cleans out any current data and resets the store to initial
state.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.&lt;/p>
</summary><description>&lt;p>The close() method is intended for instructing the store to &amp;#39;close&amp;#39; out
any information associated with a particular request.  In general, this API
expects to receive as a parameter a request object returned from a fetch.
It will then close out anything associated with that request, such as
clearing any internal datastore caches and closing any &amp;#39;open&amp;#39; connections.
For some store implementations, this call may be a no-op.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var request = store.fetch({onComplete: doSomething});
  ...
  store.close(request);&lt;/code>&lt;/pre>
</example></examples></method><method name="getLabel" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the label for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A user-readable string representing the item or undefined if no user-readable label can
be generated.</return-description><summary>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return a user-readable &amp;#39;label&amp;#39; for the item
that provides a general/adequate description of what the item is.  In general
most labels will be a specific attribute value or collection of the attribute
values that combine to label the item in some manner.  For example for an item
that represents a person it may return the label as:  &amp;quot;firstname lastlame&amp;quot; where
the firstname and lastname are attributes on the item.  If the store is unable
to determine an adequate human readable label, it should return undefined.  Users that wish
to customize how a store instance labels items should replace the getLabel() function on
their instance of the store, or extend the store and replace the function in
the extension class.&lt;/p>
</description></method><method name="getLabelAttributes" scope="prototype" type="function" from="dojo/data/api/Read"><parameters><parameter name="item" type="dojo/data/api/Item" usage="required"><summary>&lt;p>The item to return the list of label attributes for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>An array of attribute names that were used to generate the label, or null if public attributes
were not used to generate the label.</return-description><summary>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.&lt;/p>
</summary><description>&lt;p>Method to inspect the item and return an array of what attributes of the item were used
to generate its label, if any.  This function is to assist UI developers in knowing what
attributes can be ignored out of the attributes an item has when displaying it, in cases
where the UI is using the label as an overall identifer should they wish to hide
redundant information.&lt;/p>
</description></method></methods><mixins><mixin location="dojo/data/api/Read"/></mixins><summary>&lt;p>This is an abstract API that data provider implementations conform to.
This file defines function signatures and intentionally leaves all the
functions unimplemented.&lt;/p>
</summary></object><object location="dojo/date/locale" type="object"><properties/><methods><method name="__FormatOptions" scope="normal" type="constructor" from="dojo/date/locale"><parameters/><return-types/></method><method name="_getZone" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="dateObject" type="Date" usage="required"><summary>&lt;p>the date and/or time being formatted.
&lt;/p>
</summary></parameter><parameter name="getName" type="boolean" usage="required"><summary>&lt;p>Whether to return the timezone string (if true), or the offset (if false)
&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>The options being used for formatting&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>choice of &amp;#39;time&amp;#39;,&amp;#39;date&amp;#39; (default: date and time)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>formatLength (String): &lt;p>choice of long, short, medium or full (plus any custom additions).  Defaults to &amp;#39;short&amp;#39;&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>datePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>am (String): &lt;p>override strings for am in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pm (String): &lt;p>override strings for pm in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fullYear (Boolean): &lt;p>(format only) use 4 digit years whenever 2 digit years are called for&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean): &lt;p>(parse only) strict parsing, off by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Returns the zone (or offset) for the given date and options.  This
is broken out into a separate function so that it can be overridden
by timezone-aware code.
&lt;/p>
</summary></method><method name="format" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="dateObject" type="Date" usage="required"><summary>&lt;p>the date and/or time to be formatted.  If a time only is formatted,
the values in the year, month, and day fields are irrelevant.  The
opposite is true when formatting only dates.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>choice of &amp;#39;time&amp;#39;,&amp;#39;date&amp;#39; (default: date and time)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>formatLength (String): &lt;p>choice of long, short, medium or full (plus any custom additions).  Defaults to &amp;#39;short&amp;#39;&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>datePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>am (String): &lt;p>override strings for am in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pm (String): &lt;p>override strings for pm in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fullYear (Boolean): &lt;p>(format only) use 4 digit years whenever 2 digit years are called for&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean): &lt;p>(parse only) strict parsing, off by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Format a Date object as a String, using locale-specific settings.
&lt;/p>
</summary><description>&lt;p>Create a string from a Date object using a known localized pattern.
By default, this method formats both date and time from dateObject.
Formatting patterns are chosen appropriate to the locale.  Different
formatting lengths may be chosen, with &amp;quot;full&amp;quot; used by default.
Custom patterns may be used or registered with translations using
the dojo/date/locale.addCustomFormats() method.
Formatting patterns are implemented using &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns&quot;>the syntax described at
unicode.org&lt;/a>
&lt;/p>
</description></method><method name="regexp" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>choice of &amp;#39;time&amp;#39;,&amp;#39;date&amp;#39; (default: date and time)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>formatLength (String): &lt;p>choice of long, short, medium or full (plus any custom additions).  Defaults to &amp;#39;short&amp;#39;&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>datePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>am (String): &lt;p>override strings for am in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pm (String): &lt;p>override strings for pm in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fullYear (Boolean): &lt;p>(format only) use 4 digit years whenever 2 digit years are called for&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean): &lt;p>(parse only) strict parsing, off by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Builds the regular needed to parse a localized date&lt;/p>
</summary></method><method name="_parseInfo" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>choice of &amp;#39;time&amp;#39;,&amp;#39;date&amp;#39; (default: date and time)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>formatLength (String): &lt;p>choice of long, short, medium or full (plus any custom additions).  Defaults to &amp;#39;short&amp;#39;&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>datePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>am (String): &lt;p>override strings for am in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pm (String): &lt;p>override strings for pm in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fullYear (Boolean): &lt;p>(format only) use 4 digit years whenever 2 digit years are called for&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean): &lt;p>(parse only) strict parsing, off by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/></method><method name="parse" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="value" type="String" usage="required"><summary>&lt;p>A string representation of a date&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>selector (String): &lt;p>choice of &amp;#39;time&amp;#39;,&amp;#39;date&amp;#39; (default: date and time)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>formatLength (String): &lt;p>choice of long, short, medium or full (plus any custom additions).  Defaults to &amp;#39;short&amp;#39;&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>datePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timePattern (String): &lt;p>override pattern with this string&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>am (String): &lt;p>override strings for am in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>pm (String): &lt;p>override strings for pm in times&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>locale (String): &lt;p>override the locale used to determine formatting rules&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fullYear (Boolean): &lt;p>(format only) use 4 digit years whenever 2 digit years are called for&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>strict (Boolean): &lt;p>(parse only) strict parsing, off by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Convert a properly formatted string to a primitive Date object,
using locale-specific settings.
&lt;/p>
</summary><description>&lt;p>Create a Date object from a string using a known localized pattern.
By default, this method parses looking for both date and time in the string.
Formatting patterns are chosen appropriate to the locale.  Different
formatting lengths may be chosen, with &amp;quot;full&amp;quot; used by default.
Custom patterns may be used or registered with translations using
the dojo/date/locale.addCustomFormats() method.

&lt;/p>
&lt;p>Formatting patterns are implemented using &lt;a href=&quot;http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns&quot;>the syntax described at
unicode.org&lt;/a>
When two digit years are used, a century is chosen according to a sliding
window of 80 years before and 20 years after present year, for both &lt;code>yy&lt;/code> and &lt;code>yyyy&lt;/code> patterns.
year &amp;lt; 100CE requires strict mode.
&lt;/p>
</description></method><method name="addCustomFormats" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="packageName" type="String" usage="required"/><parameter name="bundleName" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Add a reference to a bundle containing localized custom formats to be
used by date/time formatting and parsing routines.
&lt;/p>
</summary><description>&lt;p>The user may add custom localized formats where the bundle has properties following the
same naming convention used by dojo.cldr: &lt;code>dateFormat-xxxx&lt;/code> / &lt;code>timeFormat-xxxx&lt;/code>
The pattern string should match the format used by the CLDR.
See dojo/date/locale.format() for details.
The resources must be loaded by dojo.requireLocalization() prior to use&lt;/p>
</description></method><method name="_getGregorianBundle" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="locale" type="String" usage="required"/></parameters><return-types/></method><method name="getNames" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="item" type="String" usage="required"><summary>&lt;p>&amp;#39;months&amp;#39; || &amp;#39;days&amp;#39;&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>&amp;#39;wide&amp;#39; || &amp;#39;abbr&amp;#39; || &amp;#39;narrow&amp;#39; (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)&lt;/p>
</summary></parameter><parameter name="context" type="String" usage="optional"><summary>&lt;p>&amp;#39;standAlone&amp;#39; || &amp;#39;format&amp;#39; (default)&lt;/p>
</summary></parameter><parameter name="locale" type="String" usage="optional"><summary>&lt;p>override locale used to find the names&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Used to get localized strings from dojo.cldr for day or month names.
&lt;/p>
</summary></method><method name="isWeekend" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="dateObject" type="Date" usage="optional"/><parameter name="locale" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Determines if the date falls on a weekend, according to local custom.&lt;/p>
</summary></method><method name="_getDayOfYear" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="dateObject" type="Date" usage="required"/></parameters><return-types/><summary>&lt;p>gets the day of the year as represented by dateObject&lt;/p>
</summary></method><method name="_getWeekOfYear" scope="normal" type="function" from="dojo/date/locale"><parameters><parameter name="dateObject" type="Date" usage="required"/><parameter name="firstDayOfWeek" type="Number" usage="required"/></parameters><return-types/></method></methods><summary>&lt;p>This modules defines dojo/date/locale, localization methods for Date.&lt;/p>
</summary></object><object location="dojo/date" type="object"><properties/><methods><method name="getDaysInMonth" scope="normal" type="function" from="dojo/date"><parameters><parameter name="dateObject" type="Date" usage="required"/></parameters><return-types/><summary>&lt;p>Returns the number of days in the month used by dateObject&lt;/p>
</summary></method><method name="isLeapYear" scope="normal" type="function" from="dojo/date"><parameters><parameter name="dateObject" type="Date" usage="required"/></parameters><return-types/><summary>&lt;p>Determines if the year of the dateObject is a leap year&lt;/p>
</summary><description>&lt;p>Leap years are years with an additional day YYYY-02-29, where the
year number is a multiple of four with the following exception: If
a year is a multiple of 100, then it is only a leap year if it is
also a multiple of 400. For example, 1900 was not a leap year, but
2000 is one.&lt;/p>
</description></method><method name="getTimezoneName" scope="normal" type="function" from="dojo/date"><parameters><parameter name="dateObject" type="Date" usage="required"><summary>&lt;p>Needed because the timezone may vary with time (daylight savings)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get the user&amp;#39;s time zone as provided by the browser&lt;/p>
</summary><description>&lt;p>Try to get time zone info from toString or toLocaleString method of
the Date object -- UTC offset is not a time zone.  See
&lt;a href=&quot;http://www.twinsun.com/tz/tz-link.htm&quot;>http://www.twinsun.com/tz/tz-link.htm&lt;/a> Note: results may be
inconsistent across browsers.&lt;/p>
</description></method><method name="compare" scope="normal" type="function" from="dojo/date"><parameters><parameter name="date1" type="Date" usage="required"><summary>&lt;p>Date object&lt;/p>
</summary></parameter><parameter name="date2" type="Date" usage="optional"><summary>&lt;p>Date object.  If not specified, the current Date is used.&lt;/p>
</summary></parameter><parameter name="portion" type="String" usage="optional"><summary>&lt;p>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Compare two date objects by date, time, or both.&lt;/p>
</summary><description>&lt;p>Returns 0 if equal, positive if a &amp;gt; b, else negative.&lt;/p>
</description></method><method name="add" scope="normal" type="function" from="dojo/date"><parameters><parameter name="date" type="Date" usage="required"><summary>&lt;p>Date object to start with&lt;/p>
</summary></parameter><parameter name="interval" type="String" usage="required"><summary>&lt;p>A string representing the interval.  One of the following:
&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;&lt;/p>
</summary></parameter><parameter name="amount" type="int" usage="required"><summary>&lt;p>How much to add to the date.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add to a Date in intervals of different size, from milliseconds to years&lt;/p>
</summary></method><method name="difference" scope="normal" type="function" from="dojo/date"><parameters><parameter name="date1" type="Date" usage="required"><summary>&lt;p>Date object&lt;/p>
</summary></parameter><parameter name="date2" type="Date" usage="optional"><summary>&lt;p>Date object.  If not specified, the current Date is used.&lt;/p>
</summary></parameter><parameter name="interval" type="String" usage="optional"><summary>&lt;p>A string representing the interval.  One of the following:
&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;

&lt;/p>
&lt;p>Defaults to &amp;quot;day&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get the difference in a specific unit of time (e.g., number of
months, weeks, days, etc.) between two dates, rounded to the
nearest integer.&lt;/p>
</summary></method></methods><summary>&lt;p>Date manipulation utilities&lt;/p>
</summary></object><object location="dojo/dnd/AutoSource" type="constructor" classlike="true" superclass="dojo/dnd/Source"><properties><property name="isSource" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="horizontal" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="copyOnly" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfCopy" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfAccept" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="skipForm" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="withHandles" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="autoSync" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="delay" scope="prototype" type="number" from="dojo/dnd/Source"/><property name="accept" scope="prototype" type="Array" from="dojo/dnd/Source"/><property name="generateText" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selection" scope="prototype" type="object" from="dojo/dnd/Selector"><summary>&lt;p>The set of id&amp;#39;s that are currently selected, such that this.selection[id] == 1
if the node w/that id is selected.  Can iterate over selected node&amp;#39;s id&amp;#39;s like:&lt;/p>
&lt;pre>&lt;code>    for(var id in this.selection)&lt;/code>&lt;/pre>
</summary></property><property name="singular" scope="prototype" type="boolean" from="dojo/dnd/Selector"/><property name="allowNested" scope="prototype" type="Boolean" from="dojo/dnd/Container"><summary>&lt;p>Indicates whether to allow dnd item nodes to be nested within other elements.
By default this is false, indicating that only direct children of the container can
be draggable dnd item nodes&lt;/p>
</summary></property><property name="current" scope="prototype" type="DomNode" from="dojo/dnd/Container"><summary>&lt;p>The DOM node the mouse is currently hovered over&lt;/p>
</summary></property><property name="map" scope="prototype" type="object" from="dojo/dnd/Container"><summary>&lt;p>Map from an item&amp;#39;s id (which is also the DOMNode&amp;#39;s id) to
the dojo/dnd/Container.Item itself.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/AutoSource"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="params" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>constructor of the AutoSource --- see the Source constructor for details&lt;/p>
</summary></method><method name="checkAcceptance" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if the target can accept nodes from this source&lt;/p>
</summary></method><method name="copyState" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="keyPressed" type="Boolean" usage="required"><summary>&lt;p>the &amp;quot;copy&amp;quot; key was pressed&lt;/p>
</summary></parameter><parameter name="self" type="Boolean" usage="optional"><summary>&lt;p>optional flag that means that we are about to drop on itself&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns true if we need to copy items, false to move.
It is separated to be overwritten dynamically, if needed.&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>prepares the object to be garbage-collected&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup&lt;/p>
</summary></method><method name="onDndSourceOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which has the mouse over it&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/source/over, called when detected a current source&lt;/p>
</summary></method><method name="onDndStart" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/start, called to initiate the DnD operation&lt;/p>
</summary></method><method name="onDndDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter><parameter name="target" type="Object" usage="required"><summary>&lt;p>the target which accepts items&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/drop, called to finish the DnD operation&lt;/p>
</summary></method><method name="onDndCancel" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>topic event processor for /dnd/cancel, called to cancel the DnD operation&lt;/p>
</summary></method><method name="onDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed&lt;/p>
</summary></method><method name="onDropExternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from an external source&lt;/p>
</summary></method><method name="onDropInternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from the same target/source&lt;/p>
</summary></method><method name="onDraggingOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged over this target, and it is not disabled&lt;/p>
</summary></method><method name="onDraggingOut" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged away from this target, and it is not disabled&lt;/p>
</summary></method><method name="onOverEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is over our container&lt;/p>
</summary></method><method name="onOutEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is out of our container&lt;/p>
</summary></method><method name="_markTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before, if true, after otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_unmarkTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_markDndStatus" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="copy" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>changes source&amp;#39;s state based on &amp;quot;copy&amp;quot; status&lt;/p>
</summary></method><method name="_legalMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if user clicked on &amp;quot;approved&amp;quot; items&lt;/p>
</summary></method><method name="getSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>returns a list (an array) of selected nodes&lt;/p>
</summary></method><method name="selectNone" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="selectAll" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>selects all items&lt;/p>
</summary></method><method name="deleteSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>deletes all selected items&lt;/p>
</return-description><summary>&lt;p>deletes all selected items&lt;/p>
</summary></method><method name="forInSelectedItems" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>iterates over selected items;
see &lt;code>dojo/dnd/Container.forInItems()&lt;/code> for details&lt;/p>
</summary></method><method name="sync" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>sync up the node list with the data map&lt;/p>
</return-description><summary>&lt;p>sync up the node list with the data map&lt;/p>
</summary></method><method name="insertNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="addSelected" type="Boolean" usage="required"><summary>&lt;p>all new nodes will be added to selected items, if true, no selection change otherwise&lt;/p>
</summary></parameter><parameter name="data" type="Array" usage="required"><summary>&lt;p>a list of data items, which should be processed by the creator function&lt;/p>
</summary></parameter><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before the anchor, if true, and after the anchor otherwise&lt;/p>
</summary></parameter><parameter name="anchor" type="Node" usage="required"><summary>&lt;p>the anchor node to be used as a point of insertion&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</return-description><summary>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</summary></method><method name="_removeSelection" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>unselects all items&lt;/p>
</return-description><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="_removeAnchor" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types></method><method name="creator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>creator function, dummy at the moment&lt;/p>
</summary></method><method name="getItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a data item by its key (id)&lt;/p>
</summary></method><method name="setItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/><parameter name="data" type="Container.Item" usage="required"/></parameters><return-types/><summary>&lt;p>associates a data item with its key (id)&lt;/p>
</summary></method><method name="delItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>removes a data item from the map by its key (id)&lt;/p>
</summary></method><method name="forInItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>iterates over a data map skipping members that
are present in the empty object (IE and/or 3rd-party libraries).&lt;/p>
</summary></method><method name="clearItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>removes all data items from the map&lt;/p>
</summary></method><method name="getAllNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a list (an array) of all valid child nodes&lt;/p>
</summary></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="startup" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>collects valid child items and populate the map&lt;/p>
</summary></method><method name="onMouseOver" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseover or touch, to mark that element as the current element&lt;/p>
</summary></method><method name="onMouseOut" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseout&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="_changeState" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>a name of the state to change&lt;/p>
</summary></parameter><parameter name="newState" type="String" usage="required"><summary>&lt;p>new state&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes a named state to new state value&lt;/p>
</summary></method><method name="_addItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>a variable suffix for a class name&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_removeItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String[]" usage="required"><summary>&lt;p>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_getChildByEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>gets a child, which is under the mouse at the moment, or null&lt;/p>
</summary></method><method name="_normalizedCreator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="item" type="Container.Item" usage="required"/><parameter name="hint" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>adds all necessary data to the output of the user-supplied creator function&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/dnd/Source"/></mixins><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="params" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>a source that syncs its DnD nodes by default&lt;/p>
</summary></object><object location="dojo/dnd/Source" type="constructor" classlike="true" superclass="dojo/dnd/Selector"><properties><property name="isSource" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="horizontal" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="copyOnly" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfCopy" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfAccept" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="skipForm" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="withHandles" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="autoSync" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="delay" scope="prototype" type="number" from="dojo/dnd/Source"/><property name="accept" scope="prototype" type="Array" from="dojo/dnd/Source"/><property name="generateText" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selection" scope="prototype" type="object" from="dojo/dnd/Selector"><summary>&lt;p>The set of id&amp;#39;s that are currently selected, such that this.selection[id] == 1
if the node w/that id is selected.  Can iterate over selected node&amp;#39;s id&amp;#39;s like:&lt;/p>
&lt;pre>&lt;code>    for(var id in this.selection)&lt;/code>&lt;/pre>
</summary></property><property name="singular" scope="prototype" type="boolean" from="dojo/dnd/Selector"/><property name="allowNested" scope="prototype" type="Boolean" from="dojo/dnd/Container"><summary>&lt;p>Indicates whether to allow dnd item nodes to be nested within other elements.
By default this is false, indicating that only direct children of the container can
be draggable dnd item nodes&lt;/p>
</summary></property><property name="current" scope="prototype" type="DomNode" from="dojo/dnd/Container"><summary>&lt;p>The DOM node the mouse is currently hovered over&lt;/p>
</summary></property><property name="map" scope="prototype" type="object" from="dojo/dnd/Container"><summary>&lt;p>Map from an item&amp;#39;s id (which is also the DOMNode&amp;#39;s id) to
the dojo/dnd/Container.Item itself.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the source on&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="optional"><summary>&lt;p>any property of this class may be configured via the params
object which is mixed-in to the &lt;code>dojo/dnd/Source&lt;/code> instance&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>isSource (Boolean, optional): &lt;p>can be used as a DnD source. Defaults to true.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>accept (Array, optional): &lt;p>list of accepted types (text strings) for a target; defaults to
[&amp;quot;text&amp;quot;]&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>autoSync (Boolean): &lt;p>if true refreshes the node list on every operation; false by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>copyOnly (Boolean, optional): &lt;p>copy items, if true, use a state of Ctrl key otherwise,
see selfCopy and selfAccept for more details&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>delay (Number): &lt;p>the move delay in pixels before detecting a drag; 0 by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>horizontal (Boolean, optional): &lt;p>a horizontal container, if true, vertical otherwise or when omitted&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>selfCopy (Boolean, optional): &lt;p>copy items by default when dropping on itself,
false by default, works only if copyOnly is true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>selfAccept (Boolean, optional): &lt;p>accept its own items when copyOnly is true,
true by default, works only if copyOnly is true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>withHandles (Boolean, optional): &lt;p>allows dragging only by handles, false by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>generateText (Boolean, optional): &lt;p>generate text node for drag and drop, true by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>a constructor of the Source&lt;/p>
</summary></method><method name="checkAcceptance" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if the target can accept nodes from this source&lt;/p>
</summary></method><method name="copyState" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="keyPressed" type="Boolean" usage="required"><summary>&lt;p>the &amp;quot;copy&amp;quot; key was pressed&lt;/p>
</summary></parameter><parameter name="self" type="Boolean" usage="optional"><summary>&lt;p>optional flag that means that we are about to drop on itself&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns true if we need to copy items, false to move.
It is separated to be overwritten dynamically, if needed.&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>prepares the object to be garbage-collected&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup&lt;/p>
</summary></method><method name="onDndSourceOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which has the mouse over it&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/source/over, called when detected a current source&lt;/p>
</summary></method><method name="onDndStart" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/start, called to initiate the DnD operation&lt;/p>
</summary></method><method name="onDndDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter><parameter name="target" type="Object" usage="required"><summary>&lt;p>the target which accepts items&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/drop, called to finish the DnD operation&lt;/p>
</summary></method><method name="onDndCancel" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>topic event processor for /dnd/cancel, called to cancel the DnD operation&lt;/p>
</summary></method><method name="onDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed&lt;/p>
</summary></method><method name="onDropExternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from an external source&lt;/p>
</summary></method><method name="onDropInternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from the same target/source&lt;/p>
</summary></method><method name="onDraggingOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged over this target, and it is not disabled&lt;/p>
</summary></method><method name="onDraggingOut" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged away from this target, and it is not disabled&lt;/p>
</summary></method><method name="onOverEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is over our container&lt;/p>
</summary></method><method name="onOutEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is out of our container&lt;/p>
</summary></method><method name="_markTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before, if true, after otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_unmarkTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_markDndStatus" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="copy" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>changes source&amp;#39;s state based on &amp;quot;copy&amp;quot; status&lt;/p>
</summary></method><method name="_legalMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if user clicked on &amp;quot;approved&amp;quot; items&lt;/p>
</summary></method><method name="getSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>returns a list (an array) of selected nodes&lt;/p>
</summary></method><method name="selectNone" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="selectAll" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>selects all items&lt;/p>
</summary></method><method name="deleteSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>deletes all selected items&lt;/p>
</return-description><summary>&lt;p>deletes all selected items&lt;/p>
</summary></method><method name="forInSelectedItems" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>iterates over selected items;
see &lt;code>dojo/dnd/Container.forInItems()&lt;/code> for details&lt;/p>
</summary></method><method name="sync" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>sync up the node list with the data map&lt;/p>
</return-description><summary>&lt;p>sync up the node list with the data map&lt;/p>
</summary></method><method name="insertNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="addSelected" type="Boolean" usage="required"><summary>&lt;p>all new nodes will be added to selected items, if true, no selection change otherwise&lt;/p>
</summary></parameter><parameter name="data" type="Array" usage="required"><summary>&lt;p>a list of data items, which should be processed by the creator function&lt;/p>
</summary></parameter><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before the anchor, if true, and after the anchor otherwise&lt;/p>
</summary></parameter><parameter name="anchor" type="Node" usage="required"><summary>&lt;p>the anchor node to be used as a point of insertion&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</return-description><summary>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</summary></method><method name="_removeSelection" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>unselects all items&lt;/p>
</return-description><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="_removeAnchor" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types></method><method name="creator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>creator function, dummy at the moment&lt;/p>
</summary></method><method name="getItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a data item by its key (id)&lt;/p>
</summary></method><method name="setItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/><parameter name="data" type="Container.Item" usage="required"/></parameters><return-types/><summary>&lt;p>associates a data item with its key (id)&lt;/p>
</summary></method><method name="delItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>removes a data item from the map by its key (id)&lt;/p>
</summary></method><method name="forInItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>iterates over a data map skipping members that
are present in the empty object (IE and/or 3rd-party libraries).&lt;/p>
</summary></method><method name="clearItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>removes all data items from the map&lt;/p>
</summary></method><method name="getAllNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a list (an array) of all valid child nodes&lt;/p>
</summary></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="startup" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>collects valid child items and populate the map&lt;/p>
</summary></method><method name="onMouseOver" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseover or touch, to mark that element as the current element&lt;/p>
</summary></method><method name="onMouseOut" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseout&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="_changeState" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>a name of the state to change&lt;/p>
</summary></parameter><parameter name="newState" type="String" usage="required"><summary>&lt;p>new state&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes a named state to new state value&lt;/p>
</summary></method><method name="_addItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>a variable suffix for a class name&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_removeItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String[]" usage="required"><summary>&lt;p>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_getChildByEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>gets a child, which is under the mouse at the moment, or null&lt;/p>
</summary></method><method name="_normalizedCreator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="item" type="Container.Item" usage="required"/><parameter name="hint" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>adds all necessary data to the output of the user-supplied creator function&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/dnd/Selector"/></mixins><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the source on&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="optional"><summary>&lt;p>any property of this class may be configured via the params
object which is mixed-in to the &lt;code>dojo/dnd/Source&lt;/code> instance&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>isSource (Boolean, optional): &lt;p>can be used as a DnD source. Defaults to true.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>accept (Array, optional): &lt;p>list of accepted types (text strings) for a target; defaults to
[&amp;quot;text&amp;quot;]&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>autoSync (Boolean): &lt;p>if true refreshes the node list on every operation; false by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>copyOnly (Boolean, optional): &lt;p>copy items, if true, use a state of Ctrl key otherwise,
see selfCopy and selfAccept for more details&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>delay (Number): &lt;p>the move delay in pixels before detecting a drag; 0 by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>horizontal (Boolean, optional): &lt;p>a horizontal container, if true, vertical otherwise or when omitted&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>selfCopy (Boolean, optional): &lt;p>copy items by default when dropping on itself,
false by default, works only if copyOnly is true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>selfAccept (Boolean, optional): &lt;p>accept its own items when copyOnly is true,
true by default, works only if copyOnly is true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>withHandles (Boolean, optional): &lt;p>allows dragging only by handles, false by default&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>generateText (Boolean, optional): &lt;p>generate text node for drag and drop, true by default&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>a Source object, which can be used as a DnD source, or a DnD target&lt;/p>
</summary></object><object location="dojo/dnd/common" type="object"><properties><property name="_uniqueId" scope="normal" type="number" from="dojo/dnd/common"/><property name="_empty" scope="normal" type="object" from="dojo/dnd/common"/><property name="_defaultCreatorNodes" scope="normal" type="object" from="dojo/dnd/Container"/><property name="_manager" scope="normal" type="instance" from="dojo/dnd/Source"/></properties><methods><method name="getCopyKeyState" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>Event object to examine&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)&lt;/p>
</summary></method><method name="getUniqueId" scope="normal" type="function" from="dojo/dnd/common"><parameters/><return-types><return-type type="string"/></return-types><summary>&lt;p>returns a unique string for use with any DOM element&lt;/p>
</summary></method><method name="isFormElement" scope="normal" type="function" from="dojo/dnd/common"><parameters><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>returns true if user clicked on a form element&lt;/p>
</summary></method><method name="_createNode" scope="normal" type="function" from="dojo/dnd/Container"><parameters><parameter name="tag" type="String" usage="required"><summary>&lt;p>a tag name or empty for SPAN&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>returns a function, which creates an element of given tag
(SPAN by default) and sets its innerHTML to given text&lt;/p>
</summary></method><method name="_createTrTd" scope="normal" type="function" from="dojo/dnd/Container"><parameters><parameter name="text" type="String" usage="required"><summary>&lt;p>a text for TD&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>creates a TR/TD structure with given text as an innerHTML of TD&lt;/p>
</summary></method><method name="_createSpan" scope="normal" type="function" from="dojo/dnd/Container"><parameters><parameter name="text" type="String" usage="required"><summary>&lt;p>a text for SPAN&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>creates a SPAN element with given text as its innerHTML&lt;/p>
</summary></method><method name="_defaultCreator" scope="normal" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a container node&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>takes a parent node, and returns an appropriate creator function&lt;/p>
</summary></method><method name="manager" scope="normal" type="function" from="dojo/dnd/Manager"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns the current DnD manager.  Creates one if it is not created yet.&lt;/p>
</summary></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/dnd/Selector" type="constructor" classlike="true" superclass="dojo/dnd/Container"><properties><property name="selection" scope="prototype" type="object" from="dojo/dnd/Selector"><summary>&lt;p>The set of id&amp;#39;s that are currently selected, such that this.selection[id] == 1
if the node w/that id is selected.  Can iterate over selected node&amp;#39;s id&amp;#39;s like:&lt;/p>
&lt;pre>&lt;code>    for(var id in this.selection)&lt;/code>&lt;/pre>
</summary></property><property name="singular" scope="prototype" type="boolean" from="dojo/dnd/Selector"/><property name="skipForm" scope="prototype" type="boolean" from="dojo/dnd/Container"/><property name="allowNested" scope="prototype" type="Boolean" from="dojo/dnd/Container"><summary>&lt;p>Indicates whether to allow dnd item nodes to be nested within other elements.
By default this is false, indicating that only direct children of the container can
be draggable dnd item nodes&lt;/p>
</summary></property><property name="current" scope="prototype" type="DomNode" from="dojo/dnd/Container"><summary>&lt;p>The DOM node the mouse is currently hovered over&lt;/p>
</summary></property><property name="map" scope="prototype" type="object" from="dojo/dnd/Container"><summary>&lt;p>Map from an item&amp;#39;s id (which is also the DOMNode&amp;#39;s id) to
the dojo/dnd/Container.Item itself.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="node" type="Node||String" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the selector on&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="optional"><summary>&lt;p>a dictionary of parameters&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>singular (Boolean): &lt;p>allows selection of only one element, if true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>autoSync (Boolean): &lt;p>autosynchronizes the source with its list of DnD nodes,&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>creator: &lt;p>a creator function, which takes a data item, and returns an object like that:
{node: newNode, data: usedData, type: arrayOfStrings}&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>skipForm (Boolean): &lt;p>don&amp;#39;t start the drag operation, if clicked on form elements&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>dropParent (Node||String): &lt;p>node or node&amp;#39;s id to use as the parent node for dropped items
(must be underneath the &amp;#39;node&amp;#39; parameter in the DOM)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>_skipStartup (Boolean): &lt;p>skip startup(), which collects children, for deferred initialization
(this is used in the markup mode)&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>constructor of the Selector&lt;/p>
</summary></method><method name="getSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>returns a list (an array) of selected nodes&lt;/p>
</summary></method><method name="selectNone" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="selectAll" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>selects all items&lt;/p>
</summary></method><method name="deleteSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>deletes all selected items&lt;/p>
</return-description><summary>&lt;p>deletes all selected items&lt;/p>
</summary></method><method name="forInSelectedItems" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>iterates over selected items;
see &lt;code>dojo/dnd/Container.forInItems()&lt;/code> for details&lt;/p>
</summary></method><method name="sync" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>sync up the node list with the data map&lt;/p>
</return-description><summary>&lt;p>sync up the node list with the data map&lt;/p>
</summary></method><method name="insertNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="addSelected" type="Boolean" usage="required"><summary>&lt;p>all new nodes will be added to selected items, if true, no selection change otherwise&lt;/p>
</summary></parameter><parameter name="data" type="Array" usage="required"><summary>&lt;p>a list of data items, which should be processed by the creator function&lt;/p>
</summary></parameter><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before the anchor, if true, and after the anchor otherwise&lt;/p>
</summary></parameter><parameter name="anchor" type="Node" usage="required"><summary>&lt;p>the anchor node to be used as a point of insertion&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</return-description><summary>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types/><summary>&lt;p>prepares the object to be garbage-collected&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove&lt;/p>
</summary></method><method name="onOverEvent" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is over our container&lt;/p>
</summary></method><method name="onOutEvent" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is out of our container&lt;/p>
</summary></method><method name="_removeSelection" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>unselects all items&lt;/p>
</return-description><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="_removeAnchor" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types></method><method name="creator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>creator function, dummy at the moment&lt;/p>
</summary></method><method name="getItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a data item by its key (id)&lt;/p>
</summary></method><method name="setItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/><parameter name="data" type="Container.Item" usage="required"/></parameters><return-types/><summary>&lt;p>associates a data item with its key (id)&lt;/p>
</summary></method><method name="delItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>removes a data item from the map by its key (id)&lt;/p>
</summary></method><method name="forInItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>iterates over a data map skipping members that
are present in the empty object (IE and/or 3rd-party libraries).&lt;/p>
</summary></method><method name="clearItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>removes all data items from the map&lt;/p>
</summary></method><method name="getAllNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a list (an array) of all valid child nodes&lt;/p>
</summary></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="startup" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>collects valid child items and populate the map&lt;/p>
</summary></method><method name="onMouseOver" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseover or touch, to mark that element as the current element&lt;/p>
</summary></method><method name="onMouseOut" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseout&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="_changeState" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>a name of the state to change&lt;/p>
</summary></parameter><parameter name="newState" type="String" usage="required"><summary>&lt;p>new state&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes a named state to new state value&lt;/p>
</summary></method><method name="_addItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>a variable suffix for a class name&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_removeItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String[]" usage="required"><summary>&lt;p>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_getChildByEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>gets a child, which is under the mouse at the moment, or null&lt;/p>
</summary></method><method name="_normalizedCreator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="item" type="Container.Item" usage="required"/><parameter name="hint" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>adds all necessary data to the output of the user-supplied creator function&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/dnd/Container"/></mixins><parameters><parameter name="node" type="Node||String" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the selector on&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="optional"><summary>&lt;p>a dictionary of parameters&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>singular (Boolean): &lt;p>allows selection of only one element, if true&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>autoSync (Boolean): &lt;p>autosynchronizes the source with its list of DnD nodes,&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>creator: &lt;p>a creator function, which takes a data item, and returns an object like that:
{node: newNode, data: usedData, type: arrayOfStrings}&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>skipForm (Boolean): &lt;p>don&amp;#39;t start the drag operation, if clicked on form elements&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>dropParent (Node||String): &lt;p>node or node&amp;#39;s id to use as the parent node for dropped items
(must be underneath the &amp;#39;node&amp;#39; parameter in the DOM)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>_skipStartup (Boolean): &lt;p>skip startup(), which collects children, for deferred initialization
(this is used in the markup mode)&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>a Selector object, which knows how to select its children&lt;/p>
</summary></object><object location="dojo/touch" type="object"><properties/><methods><method name="press" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;touchstart&amp;#39;|&amp;#39;mousedown&amp;#39; for the given node&lt;/p>
</summary></method><method name="move" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;touchmove&amp;#39;|&amp;#39;mousemove&amp;#39; for the given node&lt;/p>
</summary></method><method name="release" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;touchend&amp;#39;|&amp;#39;mouseup&amp;#39; for the given node&lt;/p>
</summary></method><method name="cancel" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;touchcancel&amp;#39;|&amp;#39;mouseleave&amp;#39; for the given node&lt;/p>
</summary></method><method name="over" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;mouseover&amp;#39; or touch equivalent for the given node&lt;/p>
</summary></method><method name="out" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to &amp;#39;mouseout&amp;#39; or touch equivalent for the given node&lt;/p>
</summary></method><method name="enter" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to mouse.enter or touch equivalent for the given node&lt;/p>
</summary></method><method name="leave" scope="normal" type="function" from="dojo/touch"><parameters><parameter name="node" type="Dom" usage="required"><summary>&lt;p>Target node to listen to&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>Callback function&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A handle which will be used to remove the listener by handle.remove()</return-description><summary>&lt;p>Register a listener to mouse.leave or touch equivalent for the given node&lt;/p>
</summary></method></methods><summary>&lt;p>This module provides unified touch event handlers by exporting
press, move, release and cancel which can also run well on desktop.
Based on &lt;a href=&quot;http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&quot;>http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&lt;/a>
&lt;/p>
</summary><examples><example>&lt;p>Used with dojo.on&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/touch&amp;quot;], function(on, touch){
    on(node, touch.press, function(e){});
    on(node, touch.move, function(e){});
    on(node, touch.release, function(e){});
    on(node, touch.cancel, function(e){});&lt;/code>&lt;/pre>
</example><example>&lt;p>Used with touch.* directly&lt;/p>
&lt;pre>&lt;code>  touch.press(node, function(e){});
  touch.move(node, function(e){});
  touch.release(node, function(e){});
  touch.cancel(node, function(e){});&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/dnd/Container" type="constructor" classlike="true" superclass="dojo/Evented"><properties><property name="skipForm" scope="prototype" type="boolean" from="dojo/dnd/Container"/><property name="allowNested" scope="prototype" type="Boolean" from="dojo/dnd/Container"><summary>&lt;p>Indicates whether to allow dnd item nodes to be nested within other elements.
By default this is false, indicating that only direct children of the container can
be draggable dnd item nodes&lt;/p>
</summary></property><property name="current" scope="prototype" type="DomNode" from="dojo/dnd/Container"><summary>&lt;p>The DOM node the mouse is currently hovered over&lt;/p>
</summary></property><property name="map" scope="prototype" type="object" from="dojo/dnd/Container"><summary>&lt;p>Map from an item&amp;#39;s id (which is also the DOMNode&amp;#39;s id) to
the dojo/dnd/Container.Item itself.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the container on&lt;/p>
</summary></parameter><parameter name="params" type="Container.__ContainerArgs" usage="required"><summary>&lt;p>a dictionary of parameters&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>a constructor of the Container&lt;/p>
</summary></method><method name="creator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>creator function, dummy at the moment&lt;/p>
</summary></method><method name="getItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a data item by its key (id)&lt;/p>
</summary></method><method name="setItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/><parameter name="data" type="Container.Item" usage="required"/></parameters><return-types/><summary>&lt;p>associates a data item with its key (id)&lt;/p>
</summary></method><method name="delItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>removes a data item from the map by its key (id)&lt;/p>
</summary></method><method name="forInItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>iterates over a data map skipping members that
are present in the empty object (IE and/or 3rd-party libraries).&lt;/p>
</summary></method><method name="clearItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>removes all data items from the map&lt;/p>
</summary></method><method name="getAllNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a list (an array) of all valid child nodes&lt;/p>
</summary></method><method name="sync" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>sync up the node list with the data map&lt;/p>
</return-description><summary>&lt;p>sync up the node list with the data map&lt;/p>
</summary></method><method name="insertNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="data" type="Object" usage="required"><summary>&lt;p>Logical representation of the object being dragged.
If the drag object&amp;#39;s type is &amp;quot;text&amp;quot; then data is a String,
if it&amp;#39;s another type then data could be a different Object,
perhaps a name/value hash.&lt;/p>
</summary></parameter><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before the anchor, if true, and after the anchor otherwise&lt;/p>
</summary></parameter><parameter name="anchor" type="Node" usage="required"><summary>&lt;p>the anchor node to be used as a point of insertion&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>inserts an array of new nodes before/after an anchor node&lt;/p>
</return-description><summary>&lt;p>inserts an array of new nodes before/after an anchor node&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>prepares this object to be garbage-collected&lt;/p>
</summary></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="startup" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>collects valid child items and populate the map&lt;/p>
</summary></method><method name="onMouseOver" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseover or touch, to mark that element as the current element&lt;/p>
</summary></method><method name="onMouseOut" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseout&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="onOverEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is over our container&lt;/p>
</summary></method><method name="onOutEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is out of our container&lt;/p>
</summary></method><method name="_changeState" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>a name of the state to change&lt;/p>
</summary></parameter><parameter name="newState" type="String" usage="required"><summary>&lt;p>new state&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes a named state to new state value&lt;/p>
</summary></method><method name="_addItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>a variable suffix for a class name&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_removeItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String[]" usage="required"><summary>&lt;p>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_getChildByEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>gets a child, which is under the mouse at the moment, or null&lt;/p>
</summary></method><method name="_normalizedCreator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="item" type="Container.Item" usage="required"/><parameter name="hint" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>adds all necessary data to the output of the user-supplied creator function&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="__ContainerArgs" scope="normal" type="constructor" from="dojo/dnd/Container"><parameters/><return-types/></method><method name="Item" scope="normal" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>Represents (one of) the source node(s) being dragged.
Contains (at least) the &amp;quot;type&amp;quot; and &amp;quot;data&amp;quot; attributes.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>node or node&amp;#39;s id to build the container on&lt;/p>
</summary></parameter><parameter name="params" type="Container.__ContainerArgs" usage="required"><summary>&lt;p>a dictionary of parameters&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>a Container object, which knows when mouse hovers over it,
and over which element it hovers&lt;/p>
</summary></object><object location="dojo/dnd/Manager" type="constructor" classlike="true" superclass="dojo/Evented"><properties><property name="OFFSET_X" scope="prototype" type="number" from="dojo/dnd/Manager"/><property name="OFFSET_Y" scope="prototype" type="number" from="dojo/dnd/Manager"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters/><return-types/></method><method name="overSource" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the reporter&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called when a source detected a mouse-over condition&lt;/p>
</summary></method><method name="outSource" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the reporter&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called when a source detected a mouse-out condition&lt;/p>
</summary></method><method name="startDrag" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called to initiate the DnD operation&lt;/p>
</summary></method><method name="canDrop" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="flag" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>called to notify if the current target can accept items&lt;/p>
</summary></method><method name="stopDrag" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters/><return-types/><summary>&lt;p>stop the DnD in progress&lt;/p>
</summary></method><method name="makeAvatar" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>makes the avatar; it is separate to be overwritten dynamically, if needed&lt;/p>
</summary></method><method name="updateAvatar" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters/><return-types/><summary>&lt;p>updates the avatar; it is separate to be overwritten dynamically, if needed&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup&lt;/p>
</summary></method><method name="onKeyDown" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>keyboard event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onkeydown:
watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag&lt;/p>
</summary></method><method name="onKeyUp" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>keyboard event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onkeyup, watching for CTRL for copy/move status&lt;/p>
</summary></method><method name="_setCopyStatus" scope="prototype" type="function" from="dojo/dnd/Manager"><parameters><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>the copy status&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes the copy status&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="manager" scope="normal" type="function" from="dojo/dnd/Manager"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns the current DnD manager.  Creates one if it is not created yet.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters/><return-types/><summary>&lt;p>the manager of DnD operations (usually a singleton)&lt;/p>
</summary></object><object location="dojo/dnd/autoscroll" type="object"><properties><property name="V_TRIGGER_AUTOSCROLL" scope="normal" type="number" from="dojo/dnd/autoscroll"/><property name="H_TRIGGER_AUTOSCROLL" scope="normal" type="number" from="dojo/dnd/autoscroll"/><property name="V_AUTOSCROLL_VALUE" scope="normal" type="number" from="dojo/dnd/autoscroll"/><property name="H_AUTOSCROLL_VALUE" scope="normal" type="number" from="dojo/dnd/autoscroll"/><property name="_validNodes" scope="normal" type="object" from="dojo/dnd/autoscroll"/><property name="_validOverflow" scope="normal" type="object" from="dojo/dnd/autoscroll"/></properties><methods><method name="getViewport" scope="normal" type="function" from="dojo/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns the dimensions and scroll position of the viewable area of a browser window&lt;/p>
</summary></method><method name="autoScrollStart" scope="normal" type="function" from="dojo/dnd/autoscroll"><parameters><parameter name="d" type="Document" usage="required"><summary>&lt;p>The document of the node being dragged.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Called at the start of a drag.&lt;/p>
</summary></method><method name="autoScroll" scope="normal" type="function" from="dojo/dnd/autoscroll"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mousemove/touchmove event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>a handler for mousemove and touchmove events, which scrolls the window, if
necessary&lt;/p>
</summary></method><method name="autoScrollNodes" scope="normal" type="function" from="dojo/dnd/autoscroll"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mousemove/touchmove event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>a handler for mousemove and touchmove events, which scrolls the first available
Dom element, it falls back to exports.autoScroll()&lt;/p>
</summary></method></methods><summary>&lt;p>Used by dojo/dnd/Manager to scroll document or internal node when the user
drags near the edge of the viewport or a scrollable node&lt;/p>
</summary></object><object location="dojo/window" type="object"><properties/><methods><method name="getBox" scope="normal" type="function" from="dojo/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns the dimensions and scroll position of the viewable area of a browser window&lt;/p>
</summary></method><method name="get" scope="normal" type="function" from="dojo/window"><parameters><parameter name="doc" type="Document" usage="required"><summary>&lt;p>The document to get the associated window for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Get window object associated with document doc.&lt;/p>
</summary></method><method name="scrollIntoView" scope="normal" type="function" from="dojo/window"><parameters><parameter name="node" type="DomNode" usage="required"/><parameter name="pos" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>Scroll the passed node into view, if it is not already.&lt;/p>
</summary></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/dnd/Avatar" type="constructor" classlike="true"><properties><property name="manager" scope="prototype" type="Object" from="dojo/dnd/Avatar"><summary>&lt;p>a DnD manager object&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Avatar"><parameters><parameter name="manager" type="undefined" usage="required"/></parameters><return-types/></method><method name="construct" scope="prototype" type="function" from="dojo/dnd/Avatar"><parameters/><return-types/><summary>&lt;p>constructor function;
it is separate so it can be (dynamically) overwritten in case of need&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Avatar"><parameters/><return-types/><summary>&lt;p>destructor for the avatar; called to remove all references so it can be garbage-collected&lt;/p>
</summary></method><method name="update" scope="prototype" type="function" from="dojo/dnd/Avatar"><parameters/><return-types/><summary>&lt;p>updates the avatar to reflect the current DnD state&lt;/p>
</summary></method><method name="_generateText" scope="prototype" type="function" from="dojo/dnd/Avatar"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>generates a proper text to reflect copying or moving of items&lt;/p>
</summary></method></methods><parameters><parameter name="manager" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Object that represents transferred DnD items visually&lt;/p>
</summary></object><object location="dojo/hccss" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/hccss"><parameters/><return-types/><summary>&lt;p>Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
Defines &lt;code>has(&amp;quot;highcontrast&amp;quot;)&lt;/code> and sets &lt;code>dj_a11y&lt;/code> CSS class on &lt;code>&amp;lt;body&amp;gt;&lt;/code> if machine is in high contrast mode.
Returns &lt;code>has()&lt;/code> method;&lt;/p>
</summary></method></methods><parameters/><return-types/><summary>&lt;p>Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
Defines &lt;code>has(&amp;quot;highcontrast&amp;quot;)&lt;/code> and sets &lt;code>dj_a11y&lt;/code> CSS class on &lt;code>&amp;lt;body&amp;gt;&lt;/code> if machine is in high contrast mode.
Returns &lt;code>has()&lt;/code> method;&lt;/p>
</summary></object><object location="dojo/dnd/Moveable" type="constructor" classlike="true" superclass="dojo/Evented"><properties><property name="handle" scope="prototype" type="string" from="dojo/dnd/Moveable"/><property name="delay" scope="prototype" type="number" from="dojo/dnd/Moveable"/><property name="skip" scope="prototype" type="boolean" from="dojo/dnd/Moveable"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="params" type="Moveable.__MoveableArgs" usage="optional"><summary>&lt;p>optional parameters&lt;/p>
</summary></parameter></parameters><return-types/></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters/><return-types/><summary>&lt;p>stops watching for possible move, deletes all references, so the object can be garbage-collected&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse/touch event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown/ontouchstart, creates a Mover for the node&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse/touch event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove/ontouchmove, used only for delayed drags&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup, used only for delayed drags&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="onDragDetected" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>called when the drag is detected;
responsible for creation of the mover&lt;/p>
</summary></method><method name="onMoveStart" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/></parameters><return-types/><summary>&lt;p>called before every move operation&lt;/p>
</summary></method><method name="onMoveStop" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/></parameters><return-types/><summary>&lt;p>called after every move operation&lt;/p>
</summary></method><method name="onFirstMove" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>called during the very first move notification;
can be used to initialize coordinates, can be overwritten.&lt;/p>
</summary></method><method name="onMove" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>called during every move notification;
should actually move the node; can be overwritten.&lt;/p>
</summary></method><method name="onMoving" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>called before every incremental move; can be overwritten.&lt;/p>
</summary></method><method name="onMoved" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>called after every incremental move; can be overwritten.&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="__MoveableArgs" scope="normal" type="constructor" from="dojo/dnd/Moveable"><parameters/><return-types/></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="params" type="Moveable.__MoveableArgs" usage="optional"><summary>&lt;p>optional parameters&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>an object, which makes a node movable&lt;/p>
</summary></object><object location="dojo/dnd/Mover" type="constructor" classlike="true" superclass="dojo/Evented"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Mover"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event, which started the move;
only pageX and pageY properties are used&lt;/p>
</summary></parameter><parameter name="host" type="Object" usage="optional"><summary>&lt;p>object which implements the functionality of the move,
and defines proper events (onMoveStart and onMoveStop)&lt;/p>
</summary></parameter></parameters><return-types/></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Mover"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse/touch event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove/ontouchmove&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Mover"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="onFirstMove" scope="prototype" type="function" from="dojo/dnd/Mover"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>makes the node absolute; it is meant to be called only once.
relative and absolutely positioned nodes are assumed to use pixel units&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Mover"><parameters/><return-types/><summary>&lt;p>stops the move, deletes all references, so the object can be garbage-collected&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/Evented"/></mixins><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event, which started the move;
only pageX and pageY properties are used&lt;/p>
</summary></parameter><parameter name="host" type="Object" usage="optional"><summary>&lt;p>object which implements the functionality of the move,
and defines proper events (onMoveStart and onMoveStop)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>an object which makes a node follow the mouse, or touch-drag on touch devices.
Used as a default mover, and as a base class for custom movers.&lt;/p>
</summary></object><object location="dojo/dnd/Target" type="constructor" classlike="true" superclass="dojo/dnd/Source"><properties><property name="isSource" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="horizontal" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="copyOnly" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfCopy" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selfAccept" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="skipForm" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="withHandles" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="autoSync" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="delay" scope="prototype" type="number" from="dojo/dnd/Source"/><property name="accept" scope="prototype" type="Array" from="dojo/dnd/Source"/><property name="generateText" scope="prototype" type="boolean" from="dojo/dnd/Source"/><property name="selection" scope="prototype" type="object" from="dojo/dnd/Selector"><summary>&lt;p>The set of id&amp;#39;s that are currently selected, such that this.selection[id] == 1
if the node w/that id is selected.  Can iterate over selected node&amp;#39;s id&amp;#39;s like:&lt;/p>
&lt;pre>&lt;code>    for(var id in this.selection)&lt;/code>&lt;/pre>
</summary></property><property name="singular" scope="prototype" type="boolean" from="dojo/dnd/Selector"/><property name="allowNested" scope="prototype" type="Boolean" from="dojo/dnd/Container"><summary>&lt;p>Indicates whether to allow dnd item nodes to be nested within other elements.
By default this is false, indicating that only direct children of the container can
be draggable dnd item nodes&lt;/p>
</summary></property><property name="current" scope="prototype" type="DomNode" from="dojo/dnd/Container"><summary>&lt;p>The DOM node the mouse is currently hovered over&lt;/p>
</summary></property><property name="map" scope="prototype" type="object" from="dojo/dnd/Container"><summary>&lt;p>Map from an item&amp;#39;s id (which is also the DOMNode&amp;#39;s id) to
the dojo/dnd/Container.Item itself.&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/Target"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="params" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>a constructor of the Target --- see the &lt;code>dojo/dnd/Source&lt;/code> constructor for details&lt;/p>
</summary></method><method name="checkAcceptance" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if the target can accept nodes from this source&lt;/p>
</summary></method><method name="copyState" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="keyPressed" type="Boolean" usage="required"><summary>&lt;p>the &amp;quot;copy&amp;quot; key was pressed&lt;/p>
</summary></parameter><parameter name="self" type="Boolean" usage="optional"><summary>&lt;p>optional flag that means that we are about to drop on itself&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns true if we need to copy items, false to move.
It is separated to be overwritten dynamically, if needed.&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>prepares the object to be garbage-collected&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup&lt;/p>
</summary></method><method name="onDndSourceOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which has the mouse over it&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/source/over, called when detected a current source&lt;/p>
</summary></method><method name="onDndStart" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/start, called to initiate the DnD operation&lt;/p>
</summary></method><method name="onDndDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter><parameter name="target" type="Object" usage="required"><summary>&lt;p>the target which accepts items&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>topic event processor for /dnd/drop, called to finish the DnD operation&lt;/p>
</summary></method><method name="onDndCancel" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>topic event processor for /dnd/cancel, called to cancel the DnD operation&lt;/p>
</summary></method><method name="onDrop" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed&lt;/p>
</summary></method><method name="onDropExternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="source" type="Object" usage="required"><summary>&lt;p>the source which provides items&lt;/p>
</summary></parameter><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from an external source&lt;/p>
</summary></method><method name="onDropInternal" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="nodes" type="Array" usage="required"><summary>&lt;p>the list of transferred items&lt;/p>
</summary></parameter><parameter name="copy" type="Boolean" usage="required"><summary>&lt;p>copy items, if true, move items otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>called only on the current target, when drop is performed
from the same target/source&lt;/p>
</summary></method><method name="onDraggingOver" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged over this target, and it is not disabled&lt;/p>
</summary></method><method name="onDraggingOut" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>called during the active DnD operation, when items
are dragged away from this target, and it is not disabled&lt;/p>
</summary></method><method name="onOverEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is over our container&lt;/p>
</summary></method><method name="onOutEvent" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>this function is called once, when mouse is out of our container&lt;/p>
</summary></method><method name="_markTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before, if true, after otherwise&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_unmarkTargetAnchor" scope="prototype" type="function" from="dojo/dnd/Source"><parameters/><return-types/><summary>&lt;p>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status&lt;/p>
</summary></method><method name="_markDndStatus" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="copy" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>changes source&amp;#39;s state based on &amp;quot;copy&amp;quot; status&lt;/p>
</summary></method><method name="_legalMouseDown" scope="prototype" type="function" from="dojo/dnd/Source"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>checks if user clicked on &amp;quot;approved&amp;quot; items&lt;/p>
</summary></method><method name="getSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="instance"/></return-types><summary>&lt;p>returns a list (an array) of selected nodes&lt;/p>
</summary></method><method name="selectNone" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="selectAll" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>selects all items&lt;/p>
</summary></method><method name="deleteSelectedNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>deletes all selected items&lt;/p>
</return-description><summary>&lt;p>deletes all selected items&lt;/p>
</summary></method><method name="forInSelectedItems" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>iterates over selected items;
see &lt;code>dojo/dnd/Container.forInItems()&lt;/code> for details&lt;/p>
</summary></method><method name="sync" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>sync up the node list with the data map&lt;/p>
</return-description><summary>&lt;p>sync up the node list with the data map&lt;/p>
</summary></method><method name="insertNodes" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters><parameter name="addSelected" type="Boolean" usage="required"><summary>&lt;p>all new nodes will be added to selected items, if true, no selection change otherwise&lt;/p>
</summary></parameter><parameter name="data" type="Array" usage="required"><summary>&lt;p>a list of data items, which should be processed by the creator function&lt;/p>
</summary></parameter><parameter name="before" type="Boolean" usage="required"><summary>&lt;p>insert before the anchor, if true, and after the anchor otherwise&lt;/p>
</summary></parameter><parameter name="anchor" type="Node" usage="required"><summary>&lt;p>the anchor node to be used as a point of insertion&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><return-description>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</return-description><summary>&lt;p>inserts new data items (see &lt;code>dojo/dnd/Container.insertNodes()&lt;/code> method for details)&lt;/p>
</summary></method><method name="_removeSelection" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types><return-description>&lt;p>unselects all items&lt;/p>
</return-description><summary>&lt;p>unselects all items&lt;/p>
</summary></method><method name="_removeAnchor" scope="prototype" type="function" from="dojo/dnd/Selector"><parameters/><return-types><return-type type="function"/></return-types></method><method name="creator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>creator function, dummy at the moment&lt;/p>
</summary></method><method name="getItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a data item by its key (id)&lt;/p>
</summary></method><method name="setItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/><parameter name="data" type="Container.Item" usage="required"/></parameters><return-types/><summary>&lt;p>associates a data item with its key (id)&lt;/p>
</summary></method><method name="delItem" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="key" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>removes a data item from the map by its key (id)&lt;/p>
</summary></method><method name="forInItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="f" type="Function" usage="required"/><parameter name="o" type="Object" usage="optional"/></parameters><return-types><return-type type="string"/></return-types><summary>&lt;p>iterates over a data map skipping members that
are present in the empty object (IE and/or 3rd-party libraries).&lt;/p>
</summary></method><method name="clearItems" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>removes all data items from the map&lt;/p>
</summary></method><method name="getAllNodes" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>returns a list (an array) of all valid child nodes&lt;/p>
</summary></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="startup" scope="prototype" type="function" from="dojo/dnd/Container"><parameters/><return-types/><summary>&lt;p>collects valid child items and populate the map&lt;/p>
</summary></method><method name="onMouseOver" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseover or touch, to mark that element as the current element&lt;/p>
</summary></method><method name="onMouseOut" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseout&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="_changeState" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>a name of the state to change&lt;/p>
</summary></parameter><parameter name="newState" type="String" usage="required"><summary>&lt;p>new state&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>changes a named state to new state value&lt;/p>
</summary></method><method name="_addItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="required"><summary>&lt;p>a variable suffix for a class name&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_removeItemClass" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="node" type="Node" usage="required"><summary>&lt;p>a node&lt;/p>
</summary></parameter><parameter name="type" type="String[]" usage="required"><summary>&lt;p>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;&lt;/p>
</summary></method><method name="_getChildByEvent" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>a mouse event&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types><summary>&lt;p>gets a child, which is under the mouse at the moment, or null&lt;/p>
</summary></method><method name="_normalizedCreator" scope="prototype" type="function" from="dojo/dnd/Container"><parameters><parameter name="item" type="Container.Item" usage="required"/><parameter name="hint" type="String" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>adds all necessary data to the output of the user-supplied creator function&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/dnd/Source"/></mixins><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="params" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>a Target object, which can be used as a DnD target&lt;/p>
</summary></object><object location="dojo/dnd/TimedMoveable" type="constructor" classlike="true" superclass="dojo/dnd/Moveable"><properties><property name="timeout" scope="prototype" type="number" from="dojo/dnd/TimedMoveable"/><property name="handle" scope="prototype" type="string" from="dojo/dnd/Moveable"/><property name="delay" scope="prototype" type="number" from="dojo/dnd/Moveable"/><property name="skip" scope="prototype" type="boolean" from="dojo/dnd/Moveable"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/dnd/TimedMoveable"><parameters><parameter name="node" type="Node||String" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="required"><summary>&lt;p>object with additional parameters.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>timeout (Number): &lt;p>delay move by this number of ms,
accumulating position changes during the timeout&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle (Node||String): &lt;p>A node (or node&amp;#39;s id), which is used as a mouse handle.
If omitted, the node itself is used as a handle.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>delay (Number): &lt;p>delay move by this number of pixels&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>skip (Boolean): &lt;p>skip move of form elements&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>mover (Object): &lt;p>a constructor of custom Mover&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>an object that makes a node moveable with a timer&lt;/p>
</summary></method><method name="onMoveStop" scope="prototype" type="function" from="dojo/dnd/TimedMoveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/></parameters><return-types/></method><method name="onMove" scope="prototype" type="function" from="dojo/dnd/TimedMoveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/></parameters><return-types/></method><method name="markupFactory" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="params" type="undefined" usage="required"/><parameter name="node" type="undefined" usage="required"/><parameter name="Ctor" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="destroy" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters/><return-types/><summary>&lt;p>stops watching for possible move, deletes all references, so the object can be garbage-collected&lt;/p>
</summary></method><method name="onMouseDown" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse/touch event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousedown/ontouchstart, creates a Mover for the node&lt;/p>
</summary></method><method name="onMouseMove" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse/touch event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmousemove/ontouchmove, used only for delayed drags&lt;/p>
</summary></method><method name="onMouseUp" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onmouseup, used only for delayed drags&lt;/p>
</summary></method><method name="onSelectStart" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>mouse event&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>event processor for onselectevent and ondragevent&lt;/p>
</summary></method><method name="onDragDetected" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>called when the drag is detected;
responsible for creation of the mover&lt;/p>
</summary></method><method name="onMoveStart" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/></parameters><return-types/><summary>&lt;p>called before every move operation&lt;/p>
</summary></method><method name="onFirstMove" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="e" type="Event" usage="required"/></parameters><return-types/><summary>&lt;p>called during the very first move notification;
can be used to initialize coordinates, can be overwritten.&lt;/p>
</summary></method><method name="onMoving" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>called before every incremental move; can be overwritten.&lt;/p>
</summary></method><method name="onMoved" scope="prototype" type="function" from="dojo/dnd/Moveable"><parameters><parameter name="mover" type="dojo/dnd/Mover" usage="required"/><parameter name="leftTop" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>called after every incremental move; can be overwritten.&lt;/p>
</summary></method><method name="on" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="emit" scope="prototype" type="function" from="dojo/Evented"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods><mixins><mixin location="dojo/dnd/Moveable"/></mixins><parameters><parameter name="node" type="Node||String" usage="required"><summary>&lt;p>a node (or node&amp;#39;s id) to be moved&lt;/p>
</summary></parameter><parameter name="params" type="Object" usage="required"><summary>&lt;p>object with additional parameters.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>timeout (Number): &lt;p>delay move by this number of ms,
accumulating position changes during the timeout&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle (Node||String): &lt;p>A node (or node&amp;#39;s id), which is used as a mouse handle.
If omitted, the node itself is used as a handle.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>delay (Number): &lt;p>delay move by this number of pixels&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>skip (Boolean): &lt;p>skip move of form elements&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>mover (Object): &lt;p>a constructor of custom Mover&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>A specialized version of Moveable to support an FPS throttling.
This class puts an upper restriction on FPS, which may reduce
the CPU load. The additional parameter &amp;quot;timeout&amp;quot; regulates
the delay before actually moving the moveable object.&lt;/p>
</summary></object><object location="dojo/dnd/move" type="object"><properties/><methods><method name="constrainedMoveable" scope="normal" type="constructor" from="dojo/dnd/move"><parameters/><return-types/></method><method name="boxConstrainedMoveable" scope="normal" type="constructor" from="dojo/dnd/move"><parameters/><return-types/></method><method name="parentConstrainedMoveable" scope="normal" type="constructor" from="dojo/dnd/move"><parameters/><return-types/></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/domReady" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/domReady"><parameters><parameter name="callback" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Plugin to delay require()/define() callback from firing until the DOM has finished loading.&lt;/p>
</summary></method><method name="load" scope="normal" type="function" from="dojo/domReady"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="req" type="undefined" usage="required"/><parameter name="load" type="undefined" usage="required"/></parameters><return-types/></method></methods><parameters><parameter name="callback" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Plugin to delay require()/define() callback from firing until the DOM has finished loading.&lt;/p>
</summary></object><object location="dojo/fx/Toggler" type="constructor" classlike="true"><properties><property name="node" scope="prototype" type="DomNode" from="dojo/fx/Toggler"><summary>&lt;p>the node to target for the showing and hiding animations&lt;/p>
</summary></property><property name="showDuration" scope="prototype" type="number" from="dojo/fx/Toggler"><summary>&lt;p>Time in milliseconds to run the show Animation&lt;/p>
</summary></property><property name="hideDuration" scope="prototype" type="number" from="dojo/fx/Toggler"><summary>&lt;p>Time in milliseconds to run the hide Animation&lt;/p>
</summary></property><property name="_showArgs" scope="prototype" type="null" from="dojo/fx/Toggler"/><property name="_showAnim" scope="prototype" type="null" from="dojo/fx/Toggler"/><property name="_hideArgs" scope="prototype" type="null" from="dojo/fx/Toggler"/><property name="_hideAnim" scope="prototype" type="null" from="dojo/fx/Toggler"/><property name="_isShowing" scope="prototype" type="boolean" from="dojo/fx/Toggler"/><property name="_isHiding" scope="prototype" type="boolean" from="dojo/fx/Toggler"/></properties><methods><method name="showFunc" scope="prototype" type="Function" from="dojo/fx/Toggler"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to show the node&lt;/p>
</summary></method><method name="hideFunc" scope="prototype" type="Function" from="dojo/fx/Toggler"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to hide the node&lt;/p>
</summary></method><method name="constructor" scope="prototype" type="function" from="dojo/fx/Toggler"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/></method><method name="show" scope="prototype" type="function" from="dojo/fx/Toggler"><parameters><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Amount of time to stall playing the show animation&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Toggle the node to showing&lt;/p>
</summary></method><method name="hide" scope="prototype" type="function" from="dojo/fx/Toggler"><parameters><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Amount of time to stall playing the hide animation&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Toggle the node to hidden&lt;/p>
</summary></method></methods><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>A simple &lt;code>dojo.Animation&lt;/code> toggler API.&lt;/p>
</summary><description>&lt;p>class constructor for an animation toggler. It accepts a packed
set of arguments about what type of animation to use in each
direction, duration, etc. All available members are mixed into
these animations from the constructor (for example, &lt;code>node&lt;/code>,
&lt;code>showDuration&lt;/code>, &lt;code>hideDuration&lt;/code>).&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var t = new dojo/fx/Toggler({
    node: &amp;quot;nodeId&amp;quot;,
    showDuration: 500,
    // hideDuration will default to &amp;quot;200&amp;quot;
    showFunc: dojo/fx/wipeIn,
    // hideFunc will default to &amp;quot;fadeOut&amp;quot;
  });
  t.show(100); // delay showing for 100ms
  // ...time passes...
  t.hide();&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/fx/easing" type="object"><properties/><methods><method name="linear" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="Decimal"/></return-types><summary>&lt;p>A linear easing function&lt;/p>
</summary></method><method name="quadIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="quadOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="quadInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="cubicIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="cubicOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="cubicInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="quartIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="quartOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="quartInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="quintIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="quintOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="quintInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="sineIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="sineOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="sineInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="expoIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="expoOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="expoInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="circIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="circOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="circInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types></method><method name="backIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that starts away from the target,
and quickly accelerates towards the end value.

&lt;/p>
&lt;p>Use caution when the easing will cause values to become
negative as some properties cannot be set to negative values.&lt;/p>
</summary></method><method name="backOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that pops past the range briefly, and slowly comes back.&lt;/p>
</summary><description>&lt;p>An easing function that pops past the range briefly, and slowly comes back.

&lt;/p>
&lt;p>Use caution when the easing will cause values to become negative as some
properties cannot be set to negative values.&lt;/p>
</description></method><method name="backInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function combining the effects of &lt;code>backIn&lt;/code> and &lt;code>backOut&lt;/code>&lt;/p>
</summary><description>&lt;p>An easing function combining the effects of &lt;code>backIn&lt;/code> and &lt;code>backOut&lt;/code>.
Use caution when the easing will cause values to become negative
as some properties cannot be set to negative values.&lt;/p>
</description></method><method name="elasticIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="Decimal"/><return-type type="number"/></return-types><summary>&lt;p>An easing function the elastically snaps from the start value&lt;/p>
</summary><description>&lt;p>An easing function the elastically snaps from the start value

&lt;/p>
&lt;p>Use caution when the elasticity will cause values to become negative
as some properties cannot be set to negative values.&lt;/p>
</description></method><method name="elasticOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="Decimal"/><return-type type="number"/></return-types><summary>&lt;p>An easing function that elasticly snaps around the target value,
near the end of the Animation&lt;/p>
</summary><description>&lt;p>An easing function that elasticly snaps around the target value,
near the end of the Animation

&lt;/p>
&lt;p>Use caution when the elasticity will cause values to become
negative as some properties cannot be set to negative values.&lt;/p>
</description></method><method name="elasticInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that elasticly snaps around the value, near
the beginning and end of the Animation.&lt;/p>
</summary><description>&lt;p>An easing function that elasticly snaps around the value, near
the beginning and end of the Animation.

&lt;/p>
&lt;p>Use caution when the elasticity will cause values to become
negative as some properties cannot be set to negative values.&lt;/p>
</description></method><method name="bounceIn" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that &amp;#39;bounces&amp;#39; near the beginning of an Animation&lt;/p>
</summary></method><method name="bounceOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that &amp;#39;bounces&amp;#39; near the end of an Animation&lt;/p>
</summary></method><method name="bounceInOut" scope="normal" type="function" from="dojo/fx/easing"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types><return-type type="number"/></return-types><summary>&lt;p>An easing function that &amp;#39;bounces&amp;#39; at the beginning and end of the Animation&lt;/p>
</summary></method></methods><summary>&lt;p>Collection of easing functions to use beyond the default
&lt;code>dojo._defaultEasing&lt;/code> function.&lt;/p>
</summary><description>&lt;p>Easing functions are used to manipulate the iteration through
an &lt;code>dojo.Animation&lt;/code>s _Line. _Line being the properties of an Animation,
and the easing function progresses through that Line determining
how quickly (or slowly) it should go. Or more accurately: modify
the value of the _Line based on the percentage of animation completed.

&lt;/p>
&lt;p>All functions follow a simple naming convention of &amp;quot;ease type&amp;quot; + &amp;quot;when&amp;quot;.
If the name of the function ends in Out, the easing described appears
towards the end of the animation. &amp;quot;In&amp;quot; means during the beginning,
and InOut means both ranges of the Animation will applied, both
beginning and end.

&lt;/p>
&lt;p>One does not call the easing function directly, it must be passed to
the &lt;code>easing&lt;/code> property of an animation.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.require(&amp;quot;dojo.fx.easing&amp;quot;);
  var anim = dojo.fadeOut({
    node: &amp;#39;node&amp;#39;,
    duration: 2000,
    //  note there is no ()
    easing: dojo.fx.easing.quadIn
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></object><object location="dojo/gears" type="object"><properties><property name="available" scope="normal" type="object" from="dojo/gears"><summary>&lt;p>True if client is using Google Gears&lt;/p>
</summary></property></properties><methods><method name="_gearsObject" scope="normal" type="function" from="dojo/gears"><parameters/><return-types><return-type type="undefined"/><return-type type="null"/><return-type type="object"/></return-types><summary>&lt;p>factory method to get a Google Gears plugin instance to
expose in the browser runtime environment, if present&lt;/p>
</summary></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/hash" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/hash"><parameters><parameter name="hash" type="String" usage="optional"><summary>&lt;p>the hash is set - #string.&lt;/p>
</summary></parameter><parameter name="replace" type="Boolean" usage="optional"><summary>&lt;p>If true, updates the hash value in the current history
state instead of creating a new history state.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>when used as a getter, returns the current hash string.
when used as a setter, returns the new hash string.</return-description><summary>&lt;p>Gets or sets the hash string in the browser URL.&lt;/p>
</summary><description>&lt;p>Handles getting and setting of location.hash.

&lt;/p>
&lt;ul>
&lt;li>If no arguments are passed, acts as a getter.&lt;/li>
&lt;li>If a string is passed, acts as a setter.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  topic.subscribe(&amp;quot;/dojo/hashchange&amp;quot;, context, callback);

  function callback (hashValue){
    // do something based on the hash value.
  }&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="hash" type="String" usage="optional"><summary>&lt;p>the hash is set - #string.&lt;/p>
</summary></parameter><parameter name="replace" type="Boolean" usage="optional"><summary>&lt;p>If true, updates the hash value in the current history
state instead of creating a new history state.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>when used as a getter, returns the current hash string.
when used as a setter, returns the new hash string.</return-description><summary>&lt;p>Gets or sets the hash string in the browser URL.&lt;/p>
</summary><description>&lt;p>Handles getting and setting of location.hash.

&lt;/p>
&lt;ul>
&lt;li>If no arguments are passed, acts as a getter.&lt;/li>
&lt;li>If a string is passed, acts as a setter.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  topic.subscribe(&amp;quot;/dojo/hashchange&amp;quot;, context, callback);

  function callback (hashValue){
    // do something based on the hash value.
  }&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/io/iframe" type="object"><properties/><methods><method name="create" scope="normal" type="function" from="dojo/io/iframe"><parameters><parameter name="fname" type="String" usage="required"><summary>&lt;p>The name of the iframe. Used for the name attribute on the
iframe.&lt;/p>
</summary></parameter><parameter name="onloadstr" type="String" usage="required"><summary>&lt;p>A string of JavaScript that will be executed when the content
in the iframe loads.&lt;/p>
</summary></parameter><parameter name="uri" type="String" usage="required"><summary>&lt;p>The value of the src attribute on the iframe element. If a
value is not given, then dojo/resources/blank.html will be
used.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Creates a hidden iframe in the page. Used mostly for IO
transports.  You do not need to call this to start a
dojo/io/iframe request. Just call send().&lt;/p>
</summary></method><method name="setSrc" scope="normal" type="function" from="dojo/io/iframe"><parameters><parameter name="iframe" type="undefined" usage="required"/><parameter name="src" type="undefined" usage="required"/><parameter name="replace" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Sets the URL that is loaded in an IFrame. The replace parameter
indicates whether location.replace() should be used when
changing the location of the iframe.&lt;/p>
</summary></method><method name="doc" scope="normal" type="function" from="dojo/io/iframe"><parameters><parameter name="iframeNode" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Returns the document object associated with the iframe DOM Node argument.&lt;/p>
</summary></method></methods><summary>&lt;p>Deprecated, use dojo/request/iframe instead.
Sends an Ajax I/O call using and Iframe (for instance, to upload files)&lt;/p>
</summary></object><object location="dojo/request/iframe" type="function"><properties><property name="_iframeName" scope="normal" type="string" from="dojo/request/iframe"/><property name="_dfdQueue" scope="normal" type="Array" from="dojo/request/iframe"/><property name="_currentDfd" scope="normal" type="null" from="dojo/request/iframe"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/iframe"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/iframe.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using an iframe element with the given URL and options.&lt;/p>
</summary></method><method name="__BaseOptions" scope="normal" type="constructor" from="dojo/request/iframe"><parameters/><return-types/></method><method name="__MethodOptions" scope="normal" type="constructor" from="dojo/request/iframe"><parameters/><return-types/></method><method name="__Options" scope="normal" type="constructor" from="dojo/request/iframe"><parameters/><return-types/></method><method name="get" scope="normal" type="function" from="dojo/request/iframe"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/iframe.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP GET request using an iframe element with the given URL and options.&lt;/p>
</summary></method><method name="post" scope="normal" type="function" from="dojo/request/iframe"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/iframe.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP POST request using an iframe element with the given URL and options.&lt;/p>
</summary></method><method name="create" scope="normal" type="function" from="dojo/request/iframe"><parameters><parameter name="name" type="undefined" usage="required"/><parameter name="onloadstr" type="undefined" usage="required"/><parameter name="uri" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="doc" scope="normal" type="function" from="dojo/request/iframe"><parameters><parameter name="iframeNode" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="null"/></return-types></method><method name="setSrc" scope="normal" type="function" from="dojo/request/iframe"><parameters><parameter name="_iframe" type="undefined" usage="required"/><parameter name="src" type="undefined" usage="required"/><parameter name="replace" type="undefined" usage="required"/></parameters><return-types/></method><method name="_notifyStart" scope="normal" type="function" from="dojo/request/iframe"><parameters/><return-types/></method><method name="_fireNextRequest" scope="normal" type="function" from="dojo/request/iframe"><parameters/><return-types/><summary>&lt;p>Internal method used to fire the next request in the queue.&lt;/p>
</summary></method></methods><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/iframe.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using an iframe element with the given URL and options.&lt;/p>
</summary></object><object location="dojo/io/script" type="object"><properties><property name="_deadScripts" scope="normal" type="Array" from="dojo/io/script"/><property name="_counter" scope="normal" type="number" from="dojo/io/script"/></properties><methods><method name="get" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>callbackParamName (String): &lt;p>Deprecated as of Dojo 1.4 in favor of &amp;quot;jsonp&amp;quot;, but still supported for
legacy code. See notes for jsonp property.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>jsonp (String): &lt;p>The URL parameter name that indicates the JSONP callback string.
For instance, when using Yahoo JSONP calls it is normally,
jsonp: &amp;quot;callback&amp;quot;. For AOL JSONP calls it is normally
jsonp: &amp;quot;c&amp;quot;.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>checkString (String): &lt;p>A string of JavaScript that when evaluated like so:
&amp;quot;typeof(&amp;quot; + checkString + &amp;quot;) != &amp;#39;undefined&amp;#39;&amp;quot;
being true means that the script fetched has been loaded.
Do not use this if doing a JSONP type of call (use callbackParamName instead).&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>frameDoc (Document): &lt;p>The Document object for a child iframe. If this is passed in, the script
will be attached to that document. This can be helpful in some comet long-polling
scenarios with Firefox and Opera.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values depend on the type of IO
transport (see specific IO calls for more information).&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>sends a get request using a dynamically created script tag.&lt;/p>
</summary></method><method name="attach" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="url" type="undefined" usage="required"/><parameter name="frameDocument" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>creates a new &lt;code>&amp;lt;script&amp;gt;&lt;/code> tag pointing to the specified URL and
adds it to the document.&lt;/p>
</summary><description>&lt;p>Attaches the script element to the DOM. Use this method if you
just want to attach a script to the DOM and do not care when or
if it loads.&lt;/p>
</description></method><method name="remove" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="frameDocument" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>removes the script element with the given id, from the given frameDocument.
If no frameDocument is passed, the current document is used.&lt;/p>
</summary></method><method name="_makeScriptDeferred" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="args" type="Object" usage="required"/><parameter name="cancel" type="Function" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>sets up a Deferred object for an IO request.&lt;/p>
</summary></method><method name="_deferredCancel" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>canceller function for xhr._ioSetArgs call.&lt;/p>
</summary></method><method name="_deferredOk" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>okHandler function for xhr._ioSetArgs call.&lt;/p>
</summary></method><method name="_deferredError" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="error" type="Error" usage="required"/><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types><return-type type="Error"/></return-types><summary>&lt;p>errHandler function for xhr._ioSetArgs call.&lt;/p>
</summary></method><method name="_addDeadScript" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="ioArgs" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>sets up an entry in the deadScripts array.&lt;/p>
</summary></method><method name="_validCheck" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>inflight check function to see if dfd is still valid.&lt;/p>
</summary></method><method name="_ioCheck" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types><return-type type="boolean"/><return-type type="undefined"/></return-types><summary>&lt;p>inflight check function to see if IO finished.&lt;/p>
</summary></method><method name="_resHandle" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="dfd" type="Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>inflight function to handle a completed response.&lt;/p>
</summary></method><method name="_canAttach" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="ioArgs" type="Object" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>A method that can be overridden by other modules
to control when the script attachment occurs.&lt;/p>
</summary></method><method name="_jsonpCallback" scope="normal" type="function" from="dojo/io/script"><parameters><parameter name="json" type="JSON Object" usage="required"/></parameters><return-types/><summary>&lt;p>generic handler for jsonp callback. A pointer to this function
is used for all jsonp callbacks.  NOTE: the &amp;quot;this&amp;quot; in this
function will be the Deferred object that represents the script
request.&lt;/p>
</summary></method></methods><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/request/script" type="function"><properties><property name="_callbacksProperty" scope="normal" type="string" from="dojo/request/script"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/script"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/script.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using a script element with the given URL and options.&lt;/p>
</summary></method><method name="__BaseOptions" scope="normal" type="constructor" from="dojo/request/script"><parameters/><return-types/></method><method name="__MethodOptions" scope="normal" type="constructor" from="dojo/request/script"><parameters/><return-types/></method><method name="__Options" scope="normal" type="constructor" from="dojo/request/script"><parameters/><return-types/></method><method name="get" scope="normal" type="function" from="dojo/request/script"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/script.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP GET request using a script element with the given URL and options.&lt;/p>
</summary></method><method name="_attach" scope="normal" type="function" from="dojo/request/script"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="url" type="undefined" usage="required"/><parameter name="frameDoc" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_remove" scope="normal" type="function" from="dojo/request/script"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="frameDoc" type="undefined" usage="required"/><parameter name="cleanup" type="undefined" usage="required"/></parameters><return-types/></method></methods><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/script.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using a script element with the given URL and options.&lt;/p>
</summary></object><object location="dojo/jaxer" type="object"><properties><property name="config" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>This module defines the user configuration during bootstrap.&lt;/p>
</summary><description>&lt;p>By defining user configuration as a module value, an entire configuration can be specified in a build,
thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
Also, when multiple instances of dojo exist in a single application, each will necessarily be located
at an unique absolute module identifier as given by the package configuration. Implementing configuration
as a module allows for specifying unique, per-instance configurations.&lt;/p>
</description><examples><example>&lt;p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
dojo.js are already loaded).&lt;/p>
&lt;pre>&lt;code>  // specify a configuration that creates a new instance of dojo at the absolute module identifier &amp;quot;myDojo&amp;quot;
  require({
    packages:[{
      name:&amp;quot;myDojo&amp;quot;,
      location:&amp;quot;.&amp;quot;, //assume baseUrl points to dojo.js
    }]
  });

  // specify a configuration for the myDojo instance
  define(&amp;quot;myDojo/config&amp;quot;, {
    // normal configuration variables go here, e.g.,
    locale:&amp;quot;fr-ca&amp;quot;
  });

  // load and use the new instance of dojo
  require([&amp;quot;myDojo&amp;quot;], function(dojo){
    // dojo is the new instance of dojo
    // use as required
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="global" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current window. &amp;#39;global&amp;#39; can be modified
for temporary context shifting. See also withGlobal().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description></property><property name="dijit" scope="normal" type="object" from="dojo/_base/kernel"/><property name="dojox" scope="normal" type="object" from="dojo/_base/kernel"/><property name="scopeMap" scope="normal" type="object" from="dojo/_base/kernel"/><property name="baseUrl" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isAsync" scope="normal" type="boolean" from="dojo/_base/kernel"/><property name="locale" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="version" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>Version number of the Dojo Toolkit&lt;/p>
</summary><description>&lt;p>Hash about the version, including

&lt;/p>
&lt;ul>
&lt;li>major: Integer: Major version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 1&lt;/li>
&lt;li>minor: Integer: Minor version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 2&lt;/li>
&lt;li>patch: Integer: Patch version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 0&lt;/li>
&lt;li>flag: String: Descriptor flag. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be &amp;quot;beta1&amp;quot;&lt;/li>
&lt;li>revision: Number: The SVN rev from which dojo was pulled&lt;/li>
&lt;/ul>
</description></property><property name="_hasResource" scope="normal" type="object" from="dojo/_base/kernel"/><property name="doc" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current document. &amp;#39;doc&amp;#39; can be modified
for temporary context shifting. See also withDoc().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window.document&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  n.appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></property><property name="isQuirks" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isIE" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
major detected IE version (6, 7, 8, etc.)&lt;/p>
</summary></property><property name="query" scope="normal" type="undefined" from="dojo/query"/><property name="mouseButtons" scope="normal" type="object" from="dojo/mouse"/><property name="_name" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isBrowser" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isFF" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isKhtml" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
detected version.&lt;/p>
</summary></property><property name="isWebKit" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a WebKit-derived browser (Konqueror,
Safari, Chrome, etc.). undefined otherwise.&lt;/p>
</summary></property><property name="isMozilla" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isMoz" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isOpera" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Opera. undefined otherwise. Corresponds to
major detected version.&lt;/p>
</summary></property><property name="isSafari" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Safari or iPhone. undefined otherwise.&lt;/p>
</summary></property><property name="isChrome" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Chrome browser. undefined otherwise.&lt;/p>
</summary></property><property name="isMac" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if the client runs on Mac&lt;/p>
</summary></property><property name="isIos" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is iPhone, iPod, or iPad&lt;/p>
</summary></property><property name="isAndroid" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is android browser. undefined otherwise.&lt;/p>
</summary></property><property name="isWii" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Wii&lt;/p>
</summary></property><property name="isAir" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Adobe Air&lt;/p>
</summary></property><property name="keys" scope="normal" type="object" from="dojo/keys"><summary>&lt;p>Definitions for common key values.  Client code should test keyCode against these named constants,
as the actual codes can vary by browser.&lt;/p>
</summary></property><property name="subscribe" scope="normal" type="undefined" from="dojo/robotx"/><property name="publish" scope="normal" type="undefined" from="dojo/robotx"/><property name="connectPublisher" scope="normal" type="undefined" from="dojo/robotx"/><property name="_nodeDataCache" scope="normal" type="object" from="dojo/NodeList-data"/><property name="_postLoad" scope="normal" type="boolean" from="dojo/ready"/><property name="fx" scope="normal" type="object" from="dojo/fx"><summary>&lt;p>Effects library on top of Base animations&lt;/p>
</summary></property><property name="toJsonIndentStr" scope="normal" type="string" from="dojo/_base/json"/><property name="date" scope="normal" type="object" from="dojo/date/stamp"/><property name="parser" scope="normal" type="object" from="dojo/parser"><summary>&lt;p>The Dom/Widget parsing package&lt;/p>
</summary></property><property name="html" scope="normal" type="object" from="dojo/html"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="_blockAsync" scope="normal" type="boolean" from="dojo/_base/xhr"/><property name="contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_windowUnloaders" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_defaultContext" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_initFired" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isSpidermonkey" scope="normal" type="boolean" from="dojo/_base/configSpidermonkey"/><property name="back" scope="normal" type="object" from="dojo/back"><summary>&lt;p>Browser history management resources&lt;/p>
</summary></property><property name="behavior" scope="normal" type="instance" from="dojo/behavior"/><property name="cldr" scope="normal" type="object" from="dojo/cldr/monetary"/><property name="i18n" scope="normal" type="object" from="dojo/i18n"><summary>&lt;p>This module implements the dojo/i18n! plugin and the v1.6- i18n API&lt;/p>
</summary><description>&lt;p>We choose to include our own plugin to leverage functionality already contained in dojo
and thereby reduce the size of the plugin compared to various loader implementations. Also, this
allows foreign AMD loaders to be used without their plugins.&lt;/p>
</description></property><property name="colors" scope="normal" type="object" from="dojo/colors"/><property name="regexp" scope="normal" type="object" from="dojo/regexp"><summary>&lt;p>Regular expressions and Builder resources&lt;/p>
</summary></property><property name="string" scope="normal" type="object" from="dojo/string"><summary>&lt;p>String utilities for Dojo&lt;/p>
</summary></property><property name="number" scope="normal" type="object" from="dojo/number"><summary>&lt;p>localized formatting and parsing routines for Number&lt;/p>
</summary></property><property name="currency" scope="normal" type="object" from="dojo/currency"><summary>&lt;p>localized formatting and parsing routines for currencies&lt;/p>
</summary><description>&lt;p>extends dojo.number to provide culturally-appropriate formatting of values
in various world currencies, including use of a currency symbol.  The currencies are specified
by a three-letter international symbol in all uppercase, and support for the currencies is
provided by the data in &lt;code>dojo.cldr&lt;/code>.  The scripts generating dojo.cldr specify which
currency support is included.  A fixed number of decimal places is determined based
on the currency type and is not determined by the &amp;#39;pattern&amp;#39; argument.  The fractional
portion is optional, by default, and variable length decimals are not supported.&lt;/p>
</description></property><property name="data" scope="normal" type="object" from="dojo/data/util/filter"/><property name="dnd" scope="normal" type="object" from="dojo/dnd/common"/><property name="touch" scope="normal" type="object" from="dojo/touch"><summary>&lt;p>This module provides unified touch event handlers by exporting
press, move, release and cancel which can also run well on desktop.
Based on &lt;a href=&quot;http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&quot;>http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&lt;/a>
&lt;/p>
</summary><examples><example>&lt;p>Used with dojo.on&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/touch&amp;quot;], function(on, touch){
    on(node, touch.press, function(e){});
    on(node, touch.move, function(e){});
    on(node, touch.release, function(e){});
    on(node, touch.cancel, function(e){});&lt;/code>&lt;/pre>
</example><example>&lt;p>Used with touch.* directly&lt;/p>
&lt;pre>&lt;code>  touch.press(node, function(e){});
  touch.move(node, function(e){});
  touch.release(node, function(e){});
  touch.cancel(node, function(e){});&lt;/code>&lt;/pre>
</example></examples></property><property name="window" scope="normal" type="object" from="dojo/window"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="gears" scope="normal" type="object" from="dojo/gears"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="io" scope="normal" type="object" from="dojo/io/iframe"/><property name="rpc" scope="normal" type="object" from="dojo/rpc/RpcService"/><property name="store" scope="normal" type="object" from="dojo/store/Cache"/><property name="tests" scope="normal" type="object" from="dojo/tests"><summary>&lt;p>D.O.H. Test files for Dojo unit testing.&lt;/p>
</summary></property></properties><methods><method name="eval" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="scriptText" type="undefined" usage="required"><summary>&lt;p>The text to evaluation.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The result of the evaluation. Often `undefined`</return-description><summary>&lt;p>A legacy method created for use exclusively by internal Dojo methods. Do not use this method
directly unless you understand its possibly-different implications on the platforms your are targeting.&lt;/p>
</summary><description>&lt;p>Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
that support indirect eval.

&lt;/p>
&lt;p>As usual, IE does not. On IE, the only way to implement global eval is to
use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
This implementation uses the technique of executing eval in the scope of a function that is a single scope
frame below the global scope; thereby coming close to the global scope. Note carefully that

&lt;/p>
&lt;p>dojo.eval(&amp;quot;var pi = 3.14;&amp;quot;);

&lt;/p>
&lt;p>will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
to define a global variable using dojo.eval, write something like

&lt;/p>
&lt;p>dojo.eval(&amp;quot;window.pi = 3.14;&amp;quot;)&lt;/p>
</description></method><method name="exit" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="exitcode" type="undefined" usage="required"/></parameters><return-types/></method><method name="experimental" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>The name of a module, or the name of a module file or a specific
function&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>some additional message for the user&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Marks code as experimental.&lt;/p>
</summary><description>&lt;p>This can be used to mark a function, file, or module as
experimental.   Experimental code is not ready to be used, and the
APIs are subject to change without notice.  Experimental code may be
completed deleted without going through the normal deprecation
process.&lt;/p>
</description><examples><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.data.Result&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.weather.toKelvin()&amp;quot;, &amp;quot;PENDING approval from NOAA&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="deprecated" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="behaviour" type="String" usage="required"><summary>&lt;p>The API or behavior being deprecated. Usually in the form
of &amp;quot;myApp.someFunction()&amp;quot;.&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>Text to append to the message. Often provides advice on a
new function or facility to achieve the same goal during
the deprecation period.&lt;/p>
</summary></parameter><parameter name="removal" type="String" usage="optional"><summary>&lt;p>Text to indicate when in the future the behavior will be
removed. Usually a version number.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Log a debug message to indicate that a behavior has been
deprecated.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> dojo.deprecated(&amp;quot;myApp.getTemp()&amp;quot;, &amp;quot;use myApp.getLocaleTemp() instead&amp;quot;, &amp;quot;1.0&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="moduleUrl" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="module" type="String" usage="required"><summary>&lt;p>dojo/dom-class&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Returns a URL relative to a module.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var pngPath = dojo.moduleUrl(&amp;quot;acme&amp;quot;,&amp;quot;images/small.png&amp;quot;);
  console.dir(pngPath); // list the object properties
  // create an image and set it&amp;#39;s source to pngPath&amp;#39;s value:
  var img = document.createElement(&amp;quot;img&amp;quot;);
  img.src = pngPath;
  // add our image to the document
  dojo.body().appendChild(img);&lt;/code>&lt;/pre>
</example><example>&lt;p>you may de-reference as far as you like down the package
hierarchy.  This is sometimes handy to avoid lenghty relative
urls or for building portable sub-packages. In this example,
the &lt;code>acme.widget&lt;/code> and &lt;code>acme.util&lt;/code> directories may be located
under different roots (see &lt;code>dojo.registerModulePath&lt;/code>) but the
the modules which reference them can be unaware of their
relative locations on the filesystem:&lt;/p>
&lt;pre>&lt;code>  // somewhere in a configuration block
  dojo.registerModulePath(&amp;quot;acme.widget&amp;quot;, &amp;quot;../../acme/widget&amp;quot;);
  dojo.registerModulePath(&amp;quot;acme.util&amp;quot;, &amp;quot;../../util&amp;quot;);

  // ...

  // code in a module using acme resources
  var tmpltPath = dojo.moduleUrl(&amp;quot;acme.widget&amp;quot;,&amp;quot;templates/template.html&amp;quot;);
  var dataPath = dojo.moduleUrl(&amp;quot;acme.util&amp;quot;,&amp;quot;resources/data.json&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="AdapterRegistry" scope="normal" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="returnWrappers" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>A registry to make contextual calling/searching easier.&lt;/p>
</summary><description>&lt;p>Objects of this class keep list of arrays in the form [name, check,
wrap, directReturn] that are used to determine what the contextual
result of a set of checked arguments is. All check/wrap functions
in this registry should be of the same arity.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // create a new registry
  var reg = new dojo.AdapterRegistry();
  reg.register(&amp;quot;handleString&amp;quot;,
    dojo.isString,
    function(str){
      // do something with the string here
    }
  );
  reg.register(&amp;quot;handleArr&amp;quot;,
    dojo.isArray,
    function(arr){
      // do something with the array here
    }
  );

  // now we can pass reg.match() *either* an array or a string and
  // the value we pass will get handled by the right function
  reg.match(&amp;quot;someValue&amp;quot;); // will call the first function
  reg.match([&amp;quot;someValue&amp;quot;]); // will call the second&lt;/code>&lt;/pre>
</example></examples></method><method name="Deferred" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="canceller" type="Function" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.
New code should use dojo/Deferred instead.&lt;/p>
</summary><description>&lt;p>The Deferred API is based on the concept of promises that provide a
generic interface into the eventual completion of an asynchronous action.
The motivation for promises fundamentally is about creating a
separation of concerns that allows one to achieve the same type of
call patterns and logical data flow in asynchronous code as can be
achieved in synchronous code. Promises allows one
to be able to call a function purely with arguments needed for
execution, without conflating the call with concerns of whether it is
sync or async. One shouldn&amp;#39;t need to alter a call&amp;#39;s arguments if the
implementation switches from sync to async (or vice versa). By having
async functions return promises, the concerns of making the call are
separated from the concerns of asynchronous interaction (which are
handled by the promise).

&lt;/p>
&lt;p>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&amp;#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

&lt;/p>
&lt;pre>&lt;code>  var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
  },
  function(error){
    ... handle error ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

&lt;/p>
&lt;p>The Deferred instances also provide the following functions for backwards compatibility:

&lt;/p>
&lt;ul>
&lt;li>addCallback(handler)&lt;/li>
&lt;li>addErrback(handler)&lt;/li>
&lt;li>callback(result)&lt;/li>
&lt;li>errback(result)&lt;/li>
&lt;/ul>
&lt;p>Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

&lt;/p>
&lt;p>The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var deferred = new Deferred();
  setTimeout(function(){ deferred.callback({success: true}); }, 1000);
  return deferred;&lt;/code>&lt;/pre>
</example><example>&lt;p>Deferred objects are often used when making code asynchronous. It
may be easiest to write functions in a synchronous manner and then
split code using a deferred to trigger a response to a long-lived
operation. For example, instead of register a callback function to
denote when a rendering operation completes, the function can
simply return a deferred:

&lt;/p>
&lt;pre>&lt;code>  // callback style:
  function renderLotsOfData(data, callback){
    var success = false
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      success = true;
    }catch(e){ }
    if(callback){
      callback(success);
    }
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using callback style
  renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
      promptUserToRecover();
    }
  });
  // NOTE: no way to add another callback here!!&lt;/code>&lt;/pre>
</example><example>&lt;p>Using a Deferred doesn&amp;#39;t simplify the sending code any, but it
provides a standard interface for callers and senders alike,
providing both with a simple way to service multiple callbacks for
an operation and freeing both sides from worrying about details
such as &amp;quot;did this get called already?&amp;quot;. With Deferreds, new
callbacks can be added at any time.

&lt;/p>
&lt;pre>&lt;code>  // Deferred style:
  function renderLotsOfData(data){
    var d = new Deferred();
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      d.callback(true);
    }catch(e){
      d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
    }
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });
  // NOTE: addErrback and addCallback both return the Deferred
  // again, so we could chain adding callbacks or save the
  // deferred for later should we need to be notified again.&lt;/code>&lt;/pre>
</example><example>&lt;p>In this example, renderLotsOfData is synchronous and so both
versions are pretty artificial. Putting the data display on a
timeout helps show why Deferreds rock:

&lt;/p>
&lt;pre>&lt;code>  // Deferred style and async func
  function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
      try{
        for(var x in data){
          renderDataitem(data[x]);
        }
        d.callback(true);
      }catch(e){
        d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
      }
    }, 100);
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that the caller doesn&amp;#39;t have to change his code at all to
handle the asynchronous case.&lt;/p>
</example></examples></method><method name="when" scope="normal" type="function" from="dojo/when"><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></method><method name="every" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not every item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s every skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // returns false
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // returns true
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;0; });&lt;/code>&lt;/pre>
</example></examples></method><method name="some" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate over. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not any item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s some skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // is true
 array.some([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // is false
 array.some([1, 2, 3, 4], function(item){ return item&amp;lt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="indexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"/><parameter name="value" type="Object" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/><parameter name="findLast" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the first index of the provided value in the
passed array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s indexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&lt;/a>&lt;/p>
</description></method><method name="lastIndexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="undefined" usage="required"/><parameter name="value" type="undefined" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the last index of the provided value in the passed
array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s lastIndexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&lt;/a>&lt;/p>
</description></method><method name="forEach" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"/><parameter name="callback" type="Function|String" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>for every item in arr, callback is invoked. Return values are ignored.
If you want to break out of the loop, consider using array.every() or array.some().
forEach does not allow breaking out of the loop over the items in arr.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s forEach skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // log out all members of the array:
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item){
      console.log(item);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // log out the members and their indexes
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item, idx, arr){
      console.log(item, &amp;quot;at index:&amp;quot;, idx);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // use a scoped object member as the callback

 var obj = {
    prefix: &amp;quot;logged via obj.callback:&amp;quot;,
    callback: function(item){
      console.log(this.prefix, item);
    }
 };

 // specifying the scope function executes the callback in that scope
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    obj.callback,
    obj
 );

 // alternately, we can accomplish the same thing with lang.hitch()
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    lang.hitch(obj, &amp;quot;callback&amp;quot;)
 );&lt;/code>&lt;/pre>
</example></examples></method><method name="map" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on
individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments, (item, index,
array),   and returns a value&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter><parameter name="Ctr" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="instance"/></return-types><summary>&lt;p>applies callback to each element of arr and returns
an Array with the results&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s map skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4, 5]
 array.map([1, 2, 3, 4], function(item){ return item+1 });&lt;/code>&lt;/pre>
</example></examples></method><method name="filter" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"><summary>&lt;p>the array to iterate over.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function that is invoked with three arguments (item,
index, array). The return of this function is expected to
be a boolean which determines whether the passed-in item
will be included in the returned array.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns a new Array with those items from arr that match the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s filter skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4]
 array.filter([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="clearCache" scope="normal" type="function" from="dojo/_base/array"><parameters/><return-types/></method><method name="DeferredList" scope="normal" type="function" from="dojo/DeferredList"><parameters><parameter name="list" type="Array" usage="required"><summary>&lt;p>The list of deferreds to be synchronizied with this DeferredList&lt;/p>
</summary></parameter><parameter name="fireOnOneCallback" type="Boolean" usage="optional"><summary>&lt;p>Will cause the DeferredLists callback to be fired as soon as any
of the deferreds in its list have been fired instead of waiting until
the entire list has finished&lt;/p>
</summary></parameter><parameter name="fireOnOneErrback" type="Boolean" usage="optional"/><parameter name="consumeErrors" type="Boolean" usage="optional"/><parameter name="canceller" type="Function" usage="optional"><summary>&lt;p>A deferred canceller function, see dojo.Deferred&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deprecated, use dojo/promise/all instead.
Provides event handling for a group of Deferred objects.&lt;/p>
</summary><description>&lt;p>DeferredList takes an array of existing deferreds and returns a new deferred of its own
this new deferred will typically have its callback fired when all of the deferreds in
the given list have fired their own deferreds.  The parameters &lt;code>fireOnOneCallback&lt;/code> and
fireOnOneErrback, will fire before all the deferreds as appropriate&lt;/p>
</description></method><method name="body" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the body element of the specified document or of dojo/_base/window::doc.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  win.body().appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></method><method name="setContext" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="globalDocument" type="DocumentElement" usage="required"/></parameters><return-types/><summary>&lt;p>changes the behavior of many core Dojo functions that deal with
namespace and DOM lookup, changing them to work in a new global
context (e.g., an iframe). The varibles dojo.global and dojo.doc
are modified as a result of calling this function and the result of
&lt;code>dojo.body()&lt;/code> likewise differs.&lt;/p>
</summary></method><method name="withGlobal" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc. If provided, globalObject
will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo.global
and dojo.doc will be restored to its previous state.&lt;/p>
</description></method><method name="withDoc" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="documentObject" type="DocumentElement" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,
callback will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo/_base/window::doc will
be restored to its previous state.&lt;/p>
</description></method><method name="_filterQueryResult" scope="normal" type="function" from="dojo/query"><parameters><parameter name="nodes" type="undefined" usage="required"/><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/><return-type type="undefined"/></return-types></method><method name="NodeList" scope="normal" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method><method name="fixEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>native event object&lt;/p>
</summary></parameter><parameter name="sender" type="DOMNode" usage="required"><summary>&lt;p>node to treat as &amp;quot;currentTarget&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Event"/></return-types><return-description>&lt;p>native event object&lt;/p>
</return-description><summary>&lt;p>normalizes properties on the event object including event
bubbling methods, keystroke normalization, and x/y positions&lt;/p>
</summary></method><method name="stopEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>The event object. If omitted, window.event is used on IE.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>prevents propagation and clobbers the default action of the
passed event&lt;/p>
</summary></method><method name="_keypress" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="object" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="connect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>The source object for the event function.
Defaults to &lt;code>kernel.global&lt;/code> if null.
If obj is a DOM node, the connection is delegated
to the DOM event manager (unless dontFix is true).
&lt;/p>
</summary></parameter><parameter name="event" type="String" usage="required"><summary>&lt;p>String name of the event function in obj.
I.e. identifies a property &lt;code>obj[event]&lt;/code>.
&lt;/p>
</summary></parameter><parameter name="context" type="Object|null" usage="required"><summary>&lt;p>The object that method will receive as &amp;quot;this&amp;quot;.

&lt;/p>
&lt;p>If context is null and method is a function, then method
inherits the context of event.

&lt;/p>
&lt;p>If method is a string then context must be the source
object object for method (context[method]). If context is null,
kernel.global is used.
&lt;/p>
</summary></parameter><parameter name="method" type="String|Function" usage="required"><summary>&lt;p>A function reference, or name of a function in context.
The function identified by method fires after event does.
method receives the same arguments as the event.
See context argument comments for information on method&amp;#39;s scope.
&lt;/p>
</summary></parameter><parameter name="dontFix" type="Boolean" usage="optional"><summary>&lt;p>If obj is a DOM node, set dontFix to true to prevent delegation
of this connection to the DOM event manager.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>&lt;code>dojo.connect&lt;/code> is a deprecated event handling and delegation method in
Dojo. It allows one function to &amp;quot;listen in&amp;quot; on the execution of
any other, triggering the second whenever the first is called. Many
listeners may be attached to a function, and source functions may
be either regular function calls or DOM events.
&lt;/p>
</summary><description>&lt;p>Connects listeners to actions, so that after event fires, a
listener is called with the same arguments passed to the original
function.

&lt;/p>
&lt;p>Since &lt;code>dojo.connect&lt;/code> allows the source of events to be either a
&amp;quot;regular&amp;quot; JavaScript function or a DOM event, it provides a uniform
interface for listening to all the types of events that an
application is likely to deal with though a single, unified
interface. DOM programmers may want to think of it as
&amp;quot;addEventListener for everything and anything&amp;quot;.

&lt;/p>
&lt;p>When setting up a connection, the &lt;code>event&lt;/code> parameter must be a
string that is the name of the method/event to be listened for. If
&lt;code>obj&lt;/code> is null, &lt;code>kernel.global&lt;/code> is assumed, meaning that connections
to global methods are supported but also that you may inadvertently
connect to a global by passing an incorrect object name or invalid
reference.

&lt;/p>
&lt;p>&lt;code>dojo.connect&lt;/code> generally is forgiving. If you pass the name of a
function or method that does not yet exist on &lt;code>obj&lt;/code>, connect will
not fail, but will instead set up a stub method. Similarly, null
arguments may simply be omitted such that fewer than 4 arguments
may be required to set up a connection See the examples for details.

&lt;/p>
&lt;p>The return value is a handle that is needed to
remove this connection with &lt;code>dojo.disconnect&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>When obj.onchange(), do ui.update():&lt;/p>
&lt;pre>&lt;code>  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, ui.update); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using return value for disconnect:&lt;/p>
&lt;pre>&lt;code>  var link = dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  ...
  dojo.disconnect(link);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When onglobalevent executes, watcher.handler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;onglobalevent&amp;quot;, watcher, &amp;quot;handler&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, &amp;quot;customEventHandler&amp;quot;);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, &amp;quot;customEventHandler&amp;quot;); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, customEventHandler);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, customEventHandler); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When globalEvent executes, globalHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;globalEvent&amp;quot;, null, globalHandler);
  dojo.connect(&amp;quot;globalEvent&amp;quot;, globalHandler); // same&lt;/code>&lt;/pre>
</example></examples></method><method name="disconnect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>the return value of the dojo.connect call that created the connection.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a link created by dojo.connect.&lt;/p>
</summary><description>&lt;p>Removes the connection between event and the method referenced by handle.&lt;/p>
</description></method><method name="isCopyKey" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>Event object to examine&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)&lt;/p>
</summary></method><method name="unsubscribe" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>The handle returned from a call to subscribe.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a topic listener.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var alerter = dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); };
  ...
  dojo.unsubscribe(alerter);&lt;/code>&lt;/pre>
</example></examples></method><method name="_nodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="Object|String" usage="optional"><summary>&lt;p>If an object, act as a setter and iterate over said object setting data items as defined.
If a string, and &lt;code>value&lt;/code> present, set the data for defined &lt;code>key&lt;/code> to &lt;code>value&lt;/code>
If a string, and &lt;code>value&lt;/code> absent, act as a getter, returning the data associated with said &lt;code>key&lt;/code>
&lt;/p>
</summary></parameter><parameter name="value" type="Anything" usage="optional"><summary>&lt;p>The value to set for said &lt;code>key&lt;/code>, provided &lt;code>key&lt;/code> is a string (and not an object)
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Private helper for dojo/NodeList.data for single node data access. Refer to NodeList.data
documentation for more information.
&lt;/p>
</summary></method><method name="_removeNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="String" usage="optional"><summary>&lt;p>If omitted, remove all data in this dataset.
If passed, remove only the passed &lt;code>key&lt;/code> in the associated dataset&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove some data from this node&lt;/p>
</summary></method><method name="_gcNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters/><return-types/><summary>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.&lt;/p>
</summary><description>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.
MUCH safer to do this yourself, manually, on a per-node basis (via &lt;code>NodeList.removeData()&lt;/code>)
provided as a stop-gap for exceptionally large/complex applications with constantly changing
content regions (eg: a dijit/layout/ContentPane with replacing data)
There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
prior to destruction.&lt;/p>
</description></method><method name="safeMixin" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>Target object to accept new properties.&lt;/p>
</summary></parameter><parameter name="source" type="Object" usage="required"><summary>&lt;p>Source object for new properties.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Target object to accept new properties.&lt;/p>
</return-description><summary>&lt;p>Mix in properties skipping a constructor and decorating functions
like it is done by declare().&lt;/p>
</summary><description>&lt;p>This function is used to mix in properties like lang.mixin does,
but it skips a constructor property and decorates functions like
declare() does.

&lt;/p>
&lt;p>It is meant to be used with classes and objects produced with
declare. Functions mixed in with dojo.safeMixin can use
this.inherited() like normal methods.

&lt;/p>
&lt;p>This function is used to implement extend() method of a constructor
produced with declare().
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var A = declare(null, {
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m1&amp;quot;);
    }
  });
  B.extend({
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  dojo.safeMixin(x, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m1&amp;quot;);
    },
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m2&amp;quot;);
    }
  });
  x.m2();
  // prints:
  // A.m1
  // B.m1
  // X.m1&lt;/code>&lt;/pre>
</example></examples></method><method name="declare" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="className" type="String" usage="optional"><summary>&lt;p>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
It will be used as a global name for a created constructor.&lt;/p>
</summary></parameter><parameter name="superclass" type="Function|Function[]" usage="required"><summary>&lt;p>May be null, a Function, or an Array of Functions. This argument
specifies a list of bases (the left-most one is the most deepest
base).&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>An object whose properties are copied to the created prototype.
Add an instance-initialization function by making it a property
named &amp;quot;constructor&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/declare.__DeclareCreatedObject"/><return-type type="undefined"/></return-types><return-description>New constructor function.</return-description><summary>&lt;p>Create a feature-rich constructor from compact notation.&lt;/p>
</summary><description>&lt;p>Create a constructor using a compact notation for inheritance and
prototype extension.

&lt;/p>
&lt;p>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

&lt;/p>
&lt;p>Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see &lt;a href=&quot;http://www.python.org/download/releases/2.3/mro/&quot;>http://www.python.org/download/releases/2.3/mro/&lt;/a> for more
details).

&lt;/p>
&lt;p>&amp;quot;className&amp;quot; is cached in &amp;quot;declaredClass&amp;quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&amp;quot;superclass&amp;quot; property of the new class.

&lt;/p>
&lt;p>Methods in &amp;quot;props&amp;quot; will be copied and modified: &amp;quot;nom&amp;quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

&lt;/p>
&lt;p>It is possible to use constructors created &amp;quot;manually&amp;quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &amp;quot;this.inherited()&amp;quot;.

&lt;/p>
&lt;p>Special property &amp;quot;-chains-&amp;quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &amp;quot;after&amp;quot;, this method will be
called after methods of its base classes. If a hint string is
&amp;quot;before&amp;quot;, this method will be called before methods of its base
classes.

&lt;/p>
&lt;p>If &amp;quot;constructor&amp;quot; is not mentioned in &amp;quot;-chains-&amp;quot; property, it will
be chained using the legacy mode: using &amp;quot;after&amp;quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &amp;quot;after&amp;quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&amp;quot;constructor&amp;quot; cannot be chained &amp;quot;before&amp;quot;, but it allows
a special hint string: &amp;quot;manual&amp;quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

&lt;/p>
&lt;p>All chaining hints are &amp;quot;inherited&amp;quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

&lt;/p>
&lt;p>Once a method was chained, it is impossible to unchain it. The
only exception is &amp;quot;constructor&amp;quot;. You don&amp;#39;t need to define a
method in order to supply a chaining hint.

&lt;/p>
&lt;p>If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

&lt;/p>
&lt;p>Usually constructors and initializers of any kind are chained
using &amp;quot;after&amp;quot; and destructors of any kind are chained as
&amp;quot;before&amp;quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  declare(&amp;quot;my.classes.bar&amp;quot;, my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
      this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
      doStuff();
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var F = function(){ console.log(&amp;quot;raw constructor&amp;quot;); };
  F.prototype.method = function(){
    console.log(&amp;quot;raw method&amp;quot;);
  };
  var A = declare(F, {
    constructor: function(){
      console.log(&amp;quot;A.constructor&amp;quot;);
    },
    method: function(){
      console.log(&amp;quot;before calling F.method...&amp;quot;);
      this.inherited(arguments);
      console.log(&amp;quot;...back in A&amp;quot;);
    }
  });
  new A().method();
  // will print:
  // raw constructor
  // A.constructor
  // before calling F.method...
  // raw method
  // ...back in A&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      destroy: &amp;quot;before&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      console.log(&amp;quot;B.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;B.destroy&amp;quot;);
    }
  });
  var C = declare(B, {
    constructor: function(){
      console.log(&amp;quot;C.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;C.destroy&amp;quot;);
    }
  });
  new C().destroy();
  // prints:
  // B.constructor
  // C.constructor
  // C.destroy
  // B.destroy&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      constructor: &amp;quot;manual&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      // ...
      // call the base constructor with new parameters
      this.inherited(arguments, [1, 2, 3]);
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      m1: &amp;quot;before&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    &amp;quot;-chains-&amp;quot;: {
      m2: &amp;quot;after&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;B.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  x.m1();
  // prints:
  // B.m1
  // A.m1
  x.m2();
  // prints:
  // A.m2
  // B.m2&lt;/code>&lt;/pre>
</example></examples></method><method name="Color" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types/><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and creates a new Color instance to work from.
&lt;/p>
</summary><examples><example>&lt;p>Work with a Color instance:&lt;/p>
&lt;pre>&lt;code> var c = new Color();
 c.setColor([0,0,0]); // black
 var hex = c.toHex(); // #000000&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Work with a node&amp;#39;s color:&lt;/p>
&lt;pre>&lt;code> var color = dojo.style(&amp;quot;someNode&amp;quot;, &amp;quot;backgroundColor&amp;quot;);
 var n = new Color(color);
 // adjust the color some
 n.r *= .5;
 console.log(n.toString()); // rgb(128, 255, 255);&lt;/code>&lt;/pre>
</example></examples></method><method name="blendColors" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="start" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="end" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="weight" type="Number" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>
</summary></method><method name="colorFromRgb" scope="normal" type="function" from="dojo/colors"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="dojo/_base/Color" usage="optional"/></parameters><return-types/><summary>&lt;p>get rgb(a) array from css-style color declarations&lt;/p>
</summary><description>&lt;p>this function can handle all 4 CSS3 Color Module formats: rgb,
rgba, hsl, hsla, including rgb(a) with percentage values.&lt;/p>
</description></method><method name="colorFromHex" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.
</return-description><summary>&lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#ededed&amp;quot;); // grey, longhand&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#000&amp;quot;); // black, shorthand&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromArray" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="a" type="Array" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromString" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="str" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromArray: &lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Parses &lt;code>str&lt;/code> for a color value. Accepts hex, rgb, and rgba
style color values.&lt;/p>
</summary><description>&lt;p>Acceptable input values for str may include arrays of any form
accepted by dojo.colorFromArray, hex strings such as &amp;quot;#aaaaaa&amp;quot;, or
rgb or rgba strings such as &amp;quot;rgb(133, 200, 16)&amp;quot; or &amp;quot;rgba(10, 10,
10, 50)&amp;quot;&lt;/p>
</description></method><method name="_Line" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="start" type="int" usage="required"><summary>&lt;p>Beginning value for range&lt;/p>
</summary></parameter><parameter name="end" type="int" usage="required"><summary>&lt;p>Ending value for range&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Object used to generate values from a start value to an end value&lt;/p>
</summary></method><method name="Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="_fade" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns an animation that will fade the node defined by
args.node from the start to end values passed (args.start
args.end) (end is mandatory, start is optional)&lt;/p>
</summary></method><method name="fadeIn" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to show the node&lt;/p>
</summary></method><method name="fadeOut" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to hide the node&lt;/p>
</summary></method><method name="_defaultEasing" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types/><summary>&lt;p>The default easing function for Animation(s)&lt;/p>
</summary></method><method name="animateProperty" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>properties (Object, optional): &lt;p>A hash map of style properties to Objects describing the transition,
such as the properties of _Line with an additional &amp;#39;units&amp;#39; property&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns an animation that will transition the properties of
node defined in &lt;code>args&lt;/code> depending how they are defined in
&lt;code>args.properties&lt;/code>
&lt;/p>
</summary><description>&lt;p>Foundation of most &lt;code>dojo/_base/fx&lt;/code>
animations. It takes an object of &amp;quot;properties&amp;quot; corresponding to
style properties, and animates them in parallel over a set
duration.
&lt;/p>
</description><examples><example>&lt;p>A simple animation that changes the width of the specified node.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    properties: { width: 400 },
  }).play();&lt;/code>&lt;/pre>
&lt;p>Dojo figures out the start value for the width and converts the
integer specified for the width to the more expressive but
verbose form &lt;code>{ width: { end: &amp;#39;400&amp;#39;, units: &amp;#39;px&amp;#39; } }&lt;/code> which you
can also specify directly. Defaults to &amp;#39;px&amp;#39; if omitted.
&lt;/p>
</example><example>&lt;p>Animate width, height, and padding over 2 seconds... the
pedantic way:&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({ node: node, duration:2000,
    properties: {
      width: { start: &amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      height: { start:&amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      paddingTop: { start:&amp;#39;5&amp;#39;, end:&amp;#39;50&amp;#39;, units:&amp;quot;px&amp;quot; }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>Note &amp;#39;paddingTop&amp;#39; is used over &amp;#39;padding-top&amp;#39;. Multi-name CSS properties
are written using &amp;quot;mixed case&amp;quot;, as the hyphen is illegal as an object key.
&lt;/p>
</example><example>&lt;p>Plug in a different easing function and register a callback for
when the animation ends. Easing functions accept values between
zero and one and return a value on that basis. In this case, an
exponential-in curve.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    // dojo figures out the start value
    properties: { width: { end: 400 } },
    easing: function(n){
      return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
    },
    onEnd: function(node){
      // called when the animation finishes. The animation
      // target is passed to this function
    }
  }).play(500); // delay playing half a second&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Like all &lt;code>Animation&lt;/code>s, animateProperty returns a handle to the
Animation instance, which fires the events common to Dojo FX. Use &lt;code>aspect.after&lt;/code>
to access these events outside of the Animation definition:&lt;/p>
&lt;pre>&lt;code>  var anim = basefx.animateProperty({
    node:&amp;quot;someId&amp;quot;,
    properties:{
      width:400, height:500
    }
  });
  aspect.after(anim, &amp;quot;onEnd&amp;quot;, function(){
    console.log(&amp;quot;animation ended&amp;quot;);
  }, true);
  // play the animation now:
  anim.play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Each property can be a function whose return value is substituted along.
Additionally, each measurement (eg: start, end) can be a function. The node
reference is passed directly to callbacks.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node:&amp;quot;mine&amp;quot;,
    properties:{
      height:function(node){
        // shrink this node by 50%
        return domGeom.position(node).h / 2
      },
      width:{
        start:function(node){ return 100; },
        end:function(node){ return 200; }
      }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="anim" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>a DOM node or the id of a node to animate CSS properties on&lt;/p>
</summary></parameter><parameter name="properties" type="Object" usage="required"/><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds over which the animation
should run. Defaults to the global animation default duration
(350ms).&lt;/p>
</summary></parameter><parameter name="easing" type="Function" usage="optional"><summary>&lt;p>An easing function over which to calculate acceleration
and deceleration of the animation through its duration.
A default easing algorithm is provided, but you may
plug in any you wish. A large selection of easing algorithms
are available in &lt;code>dojo/fx/easing&lt;/code>.&lt;/p>
</summary></parameter><parameter name="onEnd" type="Function" usage="optional"><summary>&lt;p>A function to be called when the animation finishes
running.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds to delay beginning the
animation by. The default is 0.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A simpler interface to &lt;code>animateProperty()&lt;/code>, also returns
an instance of &lt;code>Animation&lt;/code> but begins the animation
immediately, unlike nearly every other Dojo animation API.&lt;/p>
</summary><description>&lt;p>Simpler (but somewhat less powerful) version
of &lt;code>animateProperty&lt;/code>.  It uses defaults for many basic properties
and allows for positional parameters to be used in place of the
packed &amp;quot;property bag&amp;quot; which is used for other Dojo animation
methods.

&lt;/p>
&lt;p>The &lt;code>Animation&lt;/code> object returned will be already playing, so
calling play() on it again is (usually) a no-op.&lt;/p>
</description><examples><example>&lt;p>Fade out a node&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 });&lt;/code>&lt;/pre>
</example><example>&lt;p>Fade out a node over a full second&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 }, 1000);&lt;/code>&lt;/pre>
</example></examples></method><method name="_Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="addOnLoad" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="ready" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="byId" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="id" type="String|DOMNode" usage="required"><summary>&lt;p>A string to match an HTML id attribute or a reference to a DOM Node
&lt;/p>
</summary></parameter><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Document to work in. Defaults to the current value of
dojo.doc.  Can be used to retrieve
node references from other documents.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns DOM node with matching &lt;code>id&lt;/code> attribute or falsy value (ex: null or undefined)
if not found.  If &lt;code>id&lt;/code> is a DomNode, this function is a no-op.
&lt;/p>
</summary><examples><example>&lt;p>Look up a node by ID:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Check if a node exists, and use it.&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;bar&amp;quot;);
  if(n){ doStuff() ... }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Allow string or DomNode references to be passed to a custom function:&lt;/p>
&lt;pre>&lt;code>  var foo = function(nodeOrId){
    nodeOrId = dojo.byId(nodeOrId);
    // ... more stuff
  }&lt;/code>&lt;/pre>
</example></examples></method><method name="isDescendant" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference to test&lt;/p>
</summary></parameter><parameter name="ancestor" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference of potential parent to test against
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if node is a descendant of ancestor&lt;/p>
</summary><examples><example>&lt;p>Test is node id=&amp;quot;bar&amp;quot; is a descendant of node id=&amp;quot;foo&amp;quot;&lt;/p>
&lt;pre>&lt;code>  if(dojo.isDescendant(&amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="setSelectable" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="selectable" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/><return-type type="null"/></return-types><return-description>the value of the requested attribute or null if that attribute does not have a specified or
default value;
</return-description><summary>&lt;p>Gets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of attributes on DOM Nodes.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.getAttr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to set, or a hash of key-value pairs to set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>the value to set for the attribute, if the name is a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of attributes on DOM Nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.setAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setAttr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.setStyle(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to check&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>true if the requested attribute is specified on the
given element, and false otherwise</return-description><summary>&lt;p>Returns true if the requested attribute is specified on the
given element, and false otherwise.&lt;/p>
</summary></method><method name="removeAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to remove&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes an attribute from an HTML element.&lt;/p>
</summary></method><method name="getNodeProp" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the attribute</return-description><summary>&lt;p>Returns an effective value of a property or an attribute.&lt;/p>
</summary></method><method name="attr" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested attribute
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of attributes on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.attr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.attr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to check the class for.&lt;/p>
</summary></parameter><parameter name="classStr" type="String" usage="required"><summary>&lt;p>A string class name to look for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Returns whether or not the specified classes are a portion of the
class list currently applied to the node.&lt;/p>
</summary><examples><example>&lt;p>Do something if a node with id=&amp;quot;someNode&amp;quot; has class=&amp;quot;aSillyClassName&amp;quot; present&lt;/p>
&lt;pre>&lt;code>  if(dojo.hasClass(&amp;quot;someNode&amp;quot;,&amp;quot;aSillyClassName&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="addClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to add a class string too
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds the specified classes to the end of the class list on the
passed node. Will not re-apply duplicate classes.
&lt;/p>
</summary><examples><example>&lt;p>Add a class to some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;anewClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple additions&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).addClass(&amp;quot;firstLevel&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="removeClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="optional"><summary>&lt;p>An optional String class name to remove, or several space-separated
class names, or an array of class names. If omitted, all class names
will be deleted.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes the specified classes from node. No &lt;code>contains()&lt;/code>
check is required.
&lt;/p>
</summary><examples><example>&lt;p>Remove a class from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove all classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple removal&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).removeClass(&amp;quot;foo&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toggleClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to toggle a class string
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to toggle, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="condition" type="Boolean" usage="optional"><summary>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</return-description><summary>&lt;p>Adds a class to node if not present, or removes if present.
Pass a boolean condition if you want to explicitly add or remove.
Returns the condition that was specified directly or indirectly.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Forcefully add a class&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;, true);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.toggleMe&amp;quot;).toggleClass(&amp;quot;toggleMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="replaceClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="addClassStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="removeClassStr" type="String|Array" usage="optional"><summary>&lt;p>A String class name to remove, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Replaces one or more classes on a node if not present.
Operates more quickly than calling dojo.removeClass and dojo.addClass
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;add1 add2&amp;quot;, &amp;quot;remove1 remove2&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Replace all classes with addMe&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;addMe&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.findMe&amp;quot;).replaceClass(&amp;quot;addMe&amp;quot;, &amp;quot;removeMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="_toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="place" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference to use as basis for placement&lt;/p>
</summary></parameter><parameter name="position" type="String|Number" usage="optional"><summary>&lt;p>string noting the position of node relative to refNode or a
number indicating the location in the childNodes collection of refNode.
Accepted string values are:

&lt;/p>
&lt;ul>
&lt;li>before&lt;/li>
&lt;li>after&lt;/li>
&lt;li>replace&lt;/li>
&lt;li>only&lt;/li>
&lt;li>first&lt;/li>
&lt;li>last&lt;/li>
&lt;/ul>
&lt;p>&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified&lt;/p>
</summary></parameter></parameters><return-types><return-type type="DOMNode"/><return-type type="undefined"/></return-types><return-description>Returned values is the first argument resolved to a DOM node.

.place() is also a method of `dojo/NodeList`, allowing `dojo.query` node lookups.</return-description><summary>&lt;p>Attempt to insert node into the DOM, choosing from various positioning options.
Returns the first argument resolved to a DOM node.&lt;/p>
</summary><examples><example>&lt;p>Place a node by string id as the last child of another node by string id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Place a node by string id before another node by string id&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;, &amp;quot;before&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Create a Node, and place it in the body element (last child):&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;, dojo.body());&lt;/code>&lt;/pre>
</example><example>&lt;p>Put a new LI as the first child of a list by id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;, &amp;quot;someUl&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="create" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="tag" type="DOMNode|String" usage="required"><summary>&lt;p>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
or an existing DOM node to process.&lt;/p>
</summary></parameter><parameter name="attrs" type="Object" usage="required"><summary>&lt;p>An object-hash of attributes to set on the newly created node.
Can be null, if you don&amp;#39;t want to set any attributes/styles.
See: &lt;code>dojo.setAttr&lt;/code> for a description of available attributes.&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="optional"><summary>&lt;p>Optional reference node. Used by &lt;code>dojo.place&lt;/code> to place the newly created
node somewhere in the dom relative to refNode. Can be a DomNode reference
or String ID of a node.&lt;/p>
</summary></parameter><parameter name="pos" type="String" usage="optional"><summary>&lt;p>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code>dojo.place&lt;/code>,
though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
to further control the placement of the new node relative to the refNode.
&amp;#39;refNode&amp;#39; is required if a &amp;#39;pos&amp;#39; is specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create an element, allowing for optional attribute decoration
and placement.&lt;/p>
</summary><description>&lt;p>A DOM Element creation function. A shorthand method for creating a node or
a fragment, and allowing for a convenient optional attribute setting step,
as well as an optional DOM placement reference.

&lt;/p>
&lt;p>Attributes are set by passing the optional object through &lt;code>dojo.setAttr&lt;/code>.
See &lt;code>dojo.setAttr&lt;/code> for noted caveats and nuances, and API if applicable.

&lt;/p>
&lt;p>Placement is done via &lt;code>dojo.place&lt;/code>, assuming the new node to be the action
node, passing along the optional reference node and position.&lt;/p>
</description><examples><example>&lt;p>Create a DIV:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a DIV with content:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, { innerHTML:&amp;quot;&amp;lt;p&amp;gt;hi&amp;lt;/p&amp;gt;&amp;quot; });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Place a new DIV in the BODY, with no attributes set&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, null, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an UL, and populate it with LI&amp;#39;s. Place the list as the first-child of a
node with id=&amp;quot;someId&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  var ul = dojo.create(&amp;quot;ul&amp;quot;, null, &amp;quot;someId&amp;quot;, &amp;quot;first&amp;quot;);
  var items = [&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;];
  dojo.forEach(items, function(data){
    dojo.create(&amp;quot;li&amp;quot;, { innerHTML: data }, ul);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an anchor, with an href. Place in BODY:&lt;/p>
&lt;pre>&lt;code>  dojo.create(&amp;quot;a&amp;quot;, { href:&amp;quot;foo.html&amp;quot;, title:&amp;quot;Goto FOO!&amp;quot; }, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a &lt;code>dojo/NodeList()&lt;/code> from a new element (for syntactic sugar):&lt;/p>
&lt;pre>&lt;code>  dojo.query(dojo.create(&amp;#39;div&amp;#39;))
    .addClass(&amp;quot;newDiv&amp;quot;)
    .onclick(function(e){ console.log(&amp;#39;clicked&amp;#39;, e.target) })
    .place(&amp;quot;#someNode&amp;quot;); // redundant, but cleaner.&lt;/code>&lt;/pre>
</example></examples></method><method name="empty" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="destroy" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="_destroyElement" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="_getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="_getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="_getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="setMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;l&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>sets the size of the node&amp;#39;s margin box and placement
(left/top), irrespective of box model. Think of it as a
passthrough to setBox that handles box-model vagaries for
you.&lt;/p>
</summary></method><method name="getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="_getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="setContentSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the size of the node&amp;#39;s contents, irrespective of margins,
padding, or borders.&lt;/p>
</summary></method><method name="isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="_isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="_docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="_getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="_fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="position" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Object"/><return-type type="object"/></return-types><summary>&lt;p>Gets the position and size of the passed element relative to
the viewport (if includeScroll==false), or relative to the
document root (if includeScroll==true).
&lt;/p>
</summary><description>&lt;p>Returns an object of the form:
&lt;code>{ x: 100, y: 300, w: 20, h: 15 }&lt;/code>.
If includeScroll==true, the x and y values will include any
document offsets that may affect the position relative to the
viewport.
Uses the border-box model (inclusive of border and padding but
not margin).  Does not act as a setter.&lt;/p>
</description></method><method name="marginBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.marginBox() should
update/set the margin box for node. Box is an object in the
above format. All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the margin-box of node.&lt;/p>
</summary><description>&lt;p>Getter/setter for the margin-box of node.
Returns an object in the expected format of box (regardless
if box is passed). The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a margin width of 300px and a margin-height of
150px.&lt;/p>
</description><examples><example>&lt;p>Retrieve the margin box of a passed node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  console.dir(box);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set a node&amp;#39;s margin box to the size of another node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  dojo.marginBox(&amp;quot;someOtherNode&amp;quot;, box);&lt;/code>&lt;/pre>
</example></examples></method><method name="contentBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.contentBox() should
update/set the content box for node. Box is an object in the
above format, but only w (width) and h (height) are supported.
All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the content-box of node.&lt;/p>
</summary><description>&lt;p>Returns an object in the expected format of box (regardless if box is passed).
The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a content width of 300px and a content-height of
150px. Note that the content box may have a much larger border
or margin box, depending on the box model currently in use and
CSS values set/inherited for node.
While the getter will return top and left values, the
setter only accepts setting the width and height.&lt;/p>
</description></method><method name="coords" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated: Use position() for border-box x/y/w/h
or marginBox() for margin-box w/h/l/t.

&lt;/p>
&lt;p>Returns an object that measures margin-box (w)idth/(h)eight
and absolute position x/y of the border-box. Also returned
is computed (l)eft and (t)op values in pixels from the
node&amp;#39;s offsetParent as returned from marginBox().
Return value will be in the form:&lt;/p>
&lt;pre>&lt;code>      { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }&lt;/code>&lt;/pre>
&lt;p>Does not act as a setter. If includeScroll is passed, the x and
y params are affected as one would expect in dojo.position().&lt;/p>
</summary></method><method name="getProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the property on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the property to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the requested property or its default value
</return-description><summary>&lt;p>Gets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of properties on DOM nodes.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.getProp(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getProp(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to set, or a hash object to set
multiple properties at once.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of properties on DOM nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.setProp(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setProp(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="prop" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested property
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of properties on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.prop(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.prop(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="getStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get style for&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="optional"><summary>&lt;p>the style property to get&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Accesses styles on a node.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
</example></examples></method><method name="setStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><return-description>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</return-description><summary>&lt;p>Sets styles on a node.&lt;/p>
</summary><examples><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo.query()&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="getComputedStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>A reference to a DOM node. Does NOT support taking an
ID string for speed reasons.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &amp;quot;computed style&amp;quot; object.
&lt;/p>
</summary><description>&lt;p>Gets a &amp;quot;computed style&amp;quot; object which can be used to gather
information about the current state of the rendered node.

&lt;/p>
&lt;p>Note that this may behave differently on different browsers.
Values may have different formats and value encodings across
browsers.

&lt;/p>
&lt;p>Note also that this method is expensive.  Wherever possible,
reuse the returned object.

&lt;/p>
&lt;p>Use the dojo.style() method for more consistent (pixelized)
return values.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.getComputedStyle(dojo.byId(&amp;#39;foo&amp;#39;)).borderWidth;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Reusing the returned object, avoiding multiple lookups:&lt;/p>
&lt;pre>&lt;code>  var cs = dojo.getComputedStyle(dojo.byId(&amp;quot;someNode&amp;quot;));
  var w = cs.width, h = cs.height;&lt;/code>&lt;/pre>
</example></examples></method><method name="toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="__toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="style" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get/set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="optional"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, return the computed style of the node if passing in an ID or node,
or return the normalized, computed value for the property when passing in a node and a style property</return-description><summary>&lt;p>Accesses styles on a node. If 2 arguments are
passed, acts as a getter. If 3 arguments are passed, acts
as a setter.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo/query&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_Url" scope="normal" type="function" from="dojo/_base/url"><parameters/><return-types/></method><method name="fromJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="js" type="String" usage="required"><summary>&lt;p>a string literal of a JavaScript expression, for instance:
&lt;code>&amp;#39;{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }&amp;#39;&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Parses a JavaScript expression and returns a JavaScript value.&lt;/p>
</summary><description>&lt;p>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
always delegates to eval(). The content passed to this method must therefore come
from a trusted source.
It is recommend that you use dojo/json&amp;#39;s parse function for an
implementation uses the (faster) native JSON parse when available.&lt;/p>
</description></method><method name="_escapeString" scope="normal" type="function" from="dojo/json"><parameters><parameter name="value" type="undefined" usage="required"><summary>&lt;p>A value to be serialized.&lt;/p>
</summary></parameter><parameter name="replacer" type="undefined" usage="required"><summary>&lt;p>A replacer function that is called for each value and can return a replacement&lt;/p>
</summary></parameter><parameter name="spacer" type="undefined" usage="required"><summary>&lt;p>A spacer string to be used for pretty printing of JSON&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
This function follows &lt;a href=&quot;https://developer.mozilla.org/en/JSON&quot;>native JSON API&lt;/a>
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/json&amp;quot;], function(JSON){
    var jsonStr = JSON.stringify({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
    doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example></examples></method><method name="toJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="it" type="Object" usage="required"><summary>&lt;p>an object to be serialized. Objects may define their own
serialization via a special &amp;quot;&lt;strong>json&lt;/strong>&amp;quot; or &amp;quot;json&amp;quot; function
property. If a specialized serializer has been defined, it will
be used as a fallback.
Note that in 1.6, toJson would serialize undefined, but this no longer supported
since it is not supported by native JSON serializer.&lt;/p>
</summary></parameter><parameter name="prettyPrint" type="Boolean" usage="optional"><summary>&lt;p>if true, we indent objects and arrays to make the output prettier.
The variable &lt;code>dojo.toJsonIndentStr&lt;/code> is used as the indent string --
to use something other than the default (tab), change that variable
before calling dojo.toJson().
Note that if native JSON support is available, it will be used for serialization,
and native implementations vary on the exact spacing used in pretty printing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A JSON string serialization of the passed-in object.</return-description><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!
It is recommend that you use dojo/json&amp;#39;s stringify function for an lighter
and faster implementation that matches the native JSON API and uses the
native JSON serializer when available.&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  var jsonStr = dojo.toJson({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
  doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example><example>&lt;p>a custom serializer for an objects of a particular class:&lt;/p>
&lt;pre>&lt;code>  dojo.declare(&amp;quot;Furby&amp;quot;, null, {
    furbies: &amp;quot;are strange&amp;quot;,
    furbyCount: 10,
    __json__: function(){
    },
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="Stateful" scope="normal" type="constructor" from="dojo/Stateful"><parameters/><return-types/></method><method name="windowUnloaded" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>signal fired by impending window destruction. You may use
dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
page/application cleanup methods. See dojo.addOnWindowUnload for more info.&lt;/p>
</summary></method><method name="addOnWindowUnload" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="obj" type="Object" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when window.onunload fires.
Be careful trying to modify the DOM or access JavaScript properties
during this phase of page unloading: they may not always be available.
Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
JavaScript work.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.addOnWindowUnload(functionPointer)
  dojo.addOnWindowUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnWindowUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="addOnUnload" scope="normal" type="function" from="dojo/_base/unload"><parameters><parameter name="obj" type="Object?|Function" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when the page unloads.&lt;/p>
</summary><description>&lt;p>The first time that addOnUnload is called Dojo will
register a page listener to trigger your unload handler
with.

&lt;/p>
&lt;p>In a browser environment, the functions will be triggered
during the window.onbeforeunload event. Be careful of doing
too much work in an unload handler. onbeforeunload can be
triggered if a link to download a file is clicked, or if
the link is a javascript: link. In these cases, the
onbeforeunload event fires, but the document is not
actually destroyed. So be careful about doing destructive
operations in a dojo.addOnUnload callback.

&lt;/p>
&lt;p>Further note that calling dojo.addOnUnload will prevent
browsers from using a &amp;quot;fast back&amp;quot; cache to make page
loading via back button instantaneous.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.addOnUnload(functionPointer)
  dojo.addOnUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="_xhrObj" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/></method><method name="objectToQuery" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="map" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>takes a name/value mapping object and returns a string representing
a URL-encoded version of that object.&lt;/p>
</summary><examples><example>&lt;p>this object:

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields the following query string:

&lt;/p>
&lt;pre>&lt;code>  &amp;quot;blah=blah&amp;amp;multi=thud&amp;amp;multi=thonk&amp;quot;&lt;/code>&lt;/pre>
</example></examples></method><method name="queryToObject" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="str" type="String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Create an object representing a de-serialized query section of a
URL. Query keys with multiple values are returned in an array.
&lt;/p>
</summary><examples><example>&lt;p>This string:

&lt;/p>
&lt;pre>&lt;code>    &amp;quot;foo=bar&amp;amp;foo=baz&amp;amp;thinger=%20spaces%20=blah&amp;amp;zonk=blarg&amp;amp;&amp;quot;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>results in this object structure:

&lt;/p>
&lt;pre>&lt;code>    {
      foo: [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ],
      thinger: &amp;quot; spaces =blah&amp;quot;,
      zonk: &amp;quot;blarg&amp;quot;
    }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that spaces and other urlencoded entities are correctly
handled.&lt;/p>
</example></examples></method><method name="fieldToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="inputNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Serialize a form field to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the value encoded in a form field as
as a string or an array of strings. Disabled form elements
and unchecked radio and checkboxes are skipped.  Multi-select
elements are returned as an array of string values.&lt;/p>
</description></method><method name="formToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Serialize a form node to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the values encoded in an HTML form as
string properties in an object which it then returns. Disabled form
elements, buttons, and other non-value form elements are skipped.
Multi-select elements are returned as an array of string values.&lt;/p>
</description><examples><example>&lt;p>This form:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;form id=&amp;quot;test_form&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blah&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;no_value&amp;quot; value=&amp;quot;blah&amp;quot; disabled&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;no_value2&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;select type=&amp;quot;select&amp;quot; multiple name=&amp;quot;multi&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;
      &amp;lt;option value=&amp;quot;blah&amp;quot;&amp;gt;blah&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thud&amp;quot; selected&amp;gt;thud&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thonk&amp;quot; selected&amp;gt;thonk&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields this object structure as the result of a call to
formToObject():

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="formToQuery" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns a URL-encoded string representing the form passed as either a
node or string ID identifying the form to serialize&lt;/p>
</summary></method><method name="formToJson" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/><parameter name="prettyPrint" type="Boolean" usage="optional"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Create a serialized JSON string from a form node or string
ID identifying the form to serialize&lt;/p>
</summary></method><method name="__IoArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoCallbackArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoPublish" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="_ioSetArgs" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="dojo/main.__IoArgs" usage="required"><summary>&lt;p>The args object passed into the public io call. Recognized properties on
the args object are:&lt;/p>
</summary></parameter><parameter name="canceller" type="Function" usage="required"><summary>&lt;p>The canceller function used for the Deferred object. The function
will receive one argument, the Deferred object that is related to the
canceller.&lt;/p>
</summary></parameter><parameter name="okHandler" type="Function" usage="required"><summary>&lt;p>The first OK callback to be registered with Deferred. It has the opportunity
to transform the OK response. It will receive one argument -- the Deferred
object returned from this function.&lt;/p>
</summary></parameter><parameter name="errHandler" type="Function" usage="required"><summary>&lt;p>The first error callback to be registered with Deferred. It has the opportunity
to do cleanup on an error. It will receive two arguments: error (the
Error object) and dfd, the Deferred object returned from this function.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>sets up the Deferred and ioArgs property on the Deferred so it
can be used in an io call.&lt;/p>
</summary></method><method name="_ioCancelAll" scope="normal" type="function" from="dojo/_base/xhr"><parameters/><return-types/><summary>&lt;p>Cancels all pending IO requests, regardless of IO type
(xhr, script, iframe).&lt;/p>
</summary></method><method name="_ioNotifyStart" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>If dojo.publish is available, publish topics
about the start of a request queue and/or the
the beginning of request.

&lt;/p>
&lt;p>Used by IO transports. An IO transport should
call this method before making the network connection.&lt;/p>
</summary></method><method name="_ioWatch" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter><parameter name="validCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if the IO request is still valid. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="ioCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if basic IO call worked. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="resHandle" type="Function" usage="required"><summary>&lt;p>Function used to process response. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></method><method name="_ioAddQueryToUrl" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="ioArgs" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>args (Object): &lt;p>the original object argument to the IO call.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>xhr (XMLHttpRequest): &lt;p>For XMLHttpRequest calls only, the
XMLHttpRequest object that was used for the
request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>The final URL used for the call. Many times it
will be different than the original args.url
value.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>query (String): &lt;p>For non-GET requests, the
name1=value1&amp;amp;name2=value2 parameters sent up in
the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handleAs (String): &lt;p>The final indicator on how the response will be
handled.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String): &lt;p>For dojo/io/script calls only, the internal
script ID used for the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>canDelete (Boolean): &lt;p>For dojo/io/script calls only, indicates
whether the script tag that represents the
request can be deleted after callbacks have
been called. Used internally to know when
cleanup can happen on JSONP-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>json (Object): &lt;p>For dojo/io/script calls only: holds the JSON
response for JSONP-type requests. Used
internally to hold on to the JSON responses.
You should not need to access it directly --
the same object should be passed to the success
callbacks directly.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Adds query params discovered by the io deferred construction to the URL.
Only use this for operations which are fundamentally GET-type operations.&lt;/p>
</summary></method><method name="__XhrArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="xhr" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="method" type="String" usage="required"><summary>&lt;p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="hasBody" type="Boolean" usage="optional"><summary>&lt;p>If the request has an HTTP body, then pass true for hasBody.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deprecated.   Use dojo/request instead.&lt;/p>
</summary><description>&lt;p>Sends an HTTP request with the given method.
See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
for those HTTP methods. There are also methods for &amp;quot;raw&amp;quot; PUT and POST methods
via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.&lt;/p>
</description></method><method name="xhrGet" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP GET request to the server.&lt;/p>
</summary></method><method name="xhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrDelete" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP DELETE request to the server.&lt;/p>
</summary></method><method name="_isDocumentOk" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="http" type="undefined" usage="required"/></parameters><return-types/></method><method name="_getText" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="uri" type="URI" usage="required"><summary>&lt;p>A relative or absolute uri. If absolute, it still must be in
the same &amp;quot;domain&amp;quot; as we are.&lt;/p>
</summary></parameter><parameter name="fail_ok" type="Boolean" usage="required"><summary>&lt;p>Default false. If fail_ok and loading fails, return null
instead of throwing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The response text. null is returned when there is a
failure and failure is okay (an exception otherwise)</return-description><summary>&lt;p>Read the contents of the specified uri and return those contents.&lt;/p>
</summary></method><method name="_loadUri" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="uri" type="undefined" usage="required"/></parameters><return-types/></method><method name="pushContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="Object|String" usage="optional"><summary>&lt;p>The global context. If a string, the id of the frame to
search for a context and document.&lt;/p>
</summary></parameter><parameter name="d" type="MDocumentElement" usage="optional"><summary>&lt;p>The document element to execute subsequent code with.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>causes subsequent calls to Dojo methods to assume the
passed object and, optionally, document as the default
scopes to use. A 2-element array of the previous global and
document are returned.&lt;/p>
</summary><description>&lt;p>dojo.pushContext treats contexts as a stack. The
auto-detected contexts which are initially provided using
dojo.setContext() require authors to keep state in order to
&amp;quot;return&amp;quot; to a previous context, whereas the
dojo.pushContext and dojo.popContext methods provide a more
natural way to augment blocks of code to ensure that they
execute in a different window or frame without issue. If
called without any arguments, the default context (the
context when Dojo is first loaded) is instead pushed into
the stack. If only a single string is passed, a node in the
intitial context&amp;#39;s document is looked up and its
contextWindow and contextDocument properties are used as
the context to push. This means that iframes can be given
an ID and code can be executed in the scope of the iframe&amp;#39;s
document in subsequent calls easily.&lt;/p>
</description></method><method name="popContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>If the context stack contains elements, ensure that
subsequent code executes in the &lt;em>previous&lt;/em> context to the
current context. The current context set ([global,
document]) is returned.&lt;/p>
</summary></method><method name="_inContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="d" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="_loadInit" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_spidermonkeyCurrentFile" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="depth" type="undefined" usage="required"/></parameters><return-types/></method><method name="provide" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="mid" type="undefined" usage="required"/></parameters><return-types/></method><method name="require" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>module name to load, using periods for separators,
e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo&amp;#39;s
internal mapping of locations to names and are disambiguated by
longest prefix. See &lt;code>dojo.registerModulePath()&lt;/code> for details on
registering new modules.
&lt;/p>
</summary></parameter><parameter name="omitModuleCheck" type="Boolean" usage="optional"><summary>&lt;p>if &lt;code>true&lt;/code>, omitModuleCheck skips the step of ensuring that the
loaded file actually defines the symbol it is referenced by.
For example if it called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;)&lt;/code> and the
file located at &lt;code>a/b/c.js&lt;/code> does not define an object &lt;code>a.b.c&lt;/code>,
and exception will be throws whereas no exception is raised
when called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;, true)&lt;/code>
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the required namespace object</return-description><summary>&lt;p>loads a Javascript module from the appropriate URI
&lt;/p>
</summary><description>&lt;p>Modules are loaded via dojo.require by using one of two loaders: the normal loader
and the xdomain loader. The xdomain loader is used when dojo was built with a
custom build that specified loader=xdomain and the module lives on a modulePath
that is a whole URL, with protocol and a domain. The versions of Dojo that are on
the Google and AOL CDNs use the xdomain loader.

&lt;/p>
&lt;p>If the module is loaded via the xdomain loader, it is an asynchronous load, since
the module is added via a dynamically created script tag. This
means that dojo.require() can return before the module has loaded. However, this
should only happen in the case where you do dojo.require calls in the top-level
HTML page, or if you purposely avoid the loader checking for dojo.require
dependencies in your module by using a syntax like dojo[&amp;quot;require&amp;quot;] to load the module.

&lt;/p>
&lt;p>Sometimes it is useful to not have the loader detect the dojo.require calls in the
module so that you can dynamically load the modules as a result of an action on the
page, instead of right at module load time.

&lt;/p>
&lt;p>Also, for script blocks in an HTML page, the loader does not pre-process them, so
it does not know to download the modules before the dojo.require calls occur.

&lt;/p>
&lt;p>So, in those two cases, when you want on-the-fly module loading or for script blocks
in the HTML page, special care must be taken if the dojo.required code is loaded
asynchronously. To make sure you can execute code that depends on the dojo.required
modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
executing.

&lt;/p>
&lt;p>This type of syntax works with both xdomain and normal loaders, so it is good
practice to always use this idiom for on-the-fly code loading and in HTML script
blocks. If at some point you change loaders and where the code is loaded from,
it will all still work.

&lt;/p>
&lt;p>More on how dojo.require
&lt;code>dojo.require(&amp;quot;A.B&amp;quot;)&lt;/code> first checks to see if symbol A.B is
defined. If it is, it is simply returned (nothing to do).

&lt;/p>
&lt;p>If it is not defined, it will look for &lt;code>A/B.js&lt;/code> in the script root
directory.

&lt;/p>
&lt;p>&lt;code>dojo.require&lt;/code> throws an exception if it cannot find a file
to load, or if the symbol &lt;code>A.B&lt;/code> is not defined after loading.

&lt;/p>
&lt;p>It returns the object &lt;code>A.B&lt;/code>, but note the caveats above about on-the-fly loading and
HTML script blocks when the xdomain loader is loading a module.

&lt;/p>
&lt;p>&lt;code>dojo.require()&lt;/code> does nothing about importing symbols into
the current namespace.  It is presumed that the caller will
take care of that.
&lt;/p>
</description><examples><example>&lt;p>To use dojo.require in conjunction with dojo.ready:

&lt;/p>
&lt;pre>&lt;code>  dojo.require(&amp;quot;foo&amp;quot;);
  dojo.require(&amp;quot;bar&amp;quot;);
  dojo.addOnLoad(function(){
    //you can now safely do something with foo and bar
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>For example, to import all symbols into a local block, you might write:

&lt;/p>
&lt;pre>&lt;code>  with (dojo.require(&amp;quot;A.B&amp;quot;)) {
    ...
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>And to import just the leaf symbol to a local variable:

&lt;/p>
&lt;pre>&lt;code>  var B = dojo.require(&amp;quot;A.B&amp;quot;);
  ...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="loadInit" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerModulePath" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="prefix" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Maps a module name to a path&lt;/p>
</summary><description>&lt;p>An unregistered module is given the default path of ../[module],
relative to Dojo root. For example, module acme is mapped to
../acme.  If you want to use a different module name, use
dojo.registerModulePath.&lt;/p>
</description><examples><example>&lt;p>If your dojo.js is located at this location in the web root:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/dojo/dojo/dojo.js&lt;/code>&lt;/pre>
&lt;p>and your modules are located at:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/foo/bar.js
  /myapp/js/foo/baz.js
  /myapp/js/foo/thud/xyzzy.js&lt;/code>&lt;/pre>
&lt;p>Your application can tell Dojo to locate the &amp;quot;foo&amp;quot; namespace by calling:&lt;/p>
&lt;pre>&lt;code>  dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>At which point you can then use dojo.require() to load the
modules (assuming they provide() the same things which are
required). The full code might be:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;
    src=&amp;quot;/myapp/js/dojo/dojo/dojo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);
    dojo.require(&amp;quot;foo.bar&amp;quot;);
    dojo.require(&amp;quot;foo.baz&amp;quot;);
    dojo.require(&amp;quot;foo.thud.xyzzy&amp;quot;);
  &amp;lt;/script&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="platformRequire" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="modMap" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>require one or more modules based on which host environment
Dojo is currently operating in&lt;/p>
</summary><description>&lt;p>This method takes a &amp;quot;map&amp;quot; of arrays which one can use to
optionally load dojo modules. The map is indexed by the
possible dojo.name&lt;em> values, with two additional values:
&amp;quot;default&amp;quot; and &amp;quot;common&amp;quot;. The items in the &amp;quot;default&amp;quot; array will
be loaded if none of the other items have been choosen based on
dojo.name&lt;/em>, set by your host environment. The items in the
&amp;quot;common&amp;quot; array will &lt;em>always&lt;/em> be loaded, regardless of which
list is chosen.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.platformRequire({
    browser: [
      &amp;quot;foo.sample&amp;quot;, // simple module
      &amp;quot;foo.test&amp;quot;,
      [&amp;quot;foo.bar.baz&amp;quot;, true] // skip object check in _loadModule (dojo.require)
    ],
    default: [ &amp;quot;foo.sample._base&amp;quot; ],
    common: [ &amp;quot;important.module.common&amp;quot; ]
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="requireAfterIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireLocalization" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="bundleName" type="String" usage="required"/><parameter name="locale" type="String" usage="optional"/></parameters><return-types/></method><method name="cache" scope="normal" type="function" from="dojo/text"><parameters><parameter name="module" type="String||Object" usage="required"><summary>&lt;p>dojo/cldr/supplemental&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="required"><summary>&lt;p>The rest of the path to append to the path derived from the module argument. If
module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.&lt;/p>
</summary></parameter><parameter name="value" type="String||Object" usage="optional"><summary>&lt;p>If a String, the value to use in the cache for the module/url combination.
If an Object, it can have two properties: value and sanitize. The value property
should be the value to use in the cache, and sanitize can be set to true or false,
to indicate if XML declarations should be removed from the value and if the HTML
inside a body tag in the value should be extracted as the real value. The value argument
or the value property on the value argument are usually only used by the build system
as it inlines cache content.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A getter and setter for storing the string content associated with the
module and url arguments.&lt;/p>
</summary><description>&lt;p>If module is a string that contains slashes, then it is interpretted as a fully
resolved path (typically a result returned by require.toUrl), and url should not be
provided. This is the preferred signature. If module is a string that does not
contain slashes, then url must also be provided and module and url are used to
call &lt;code>dojo.moduleUrl()&lt;/code> to generate a module URL. This signature is deprecated.
If value is specified, the cache value for the moduleUrl will be set to
that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
in its internal cache and return that cached value for the URL. To clear
a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
the URL contents, only modules on the same domain of the page can use this capability.
The build system can inline the cache values though, to allow for xdomain hosting.&lt;/p>
</description><examples><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&amp;quot;cache&amp;quot;] style
of call is used to avoid an issue with the build system erroneously trying to intern
this example. To get the build system to intern your dojo.cache calls, use the
&amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot; that will be
 //the value for the text variable.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
(the dojo[&amp;quot;cache&amp;quot;] style of call is used to avoid an issue with the build system
erroneously trying to intern this example. To get the build system to intern your
dojo.cache calls, use the &amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;, {sanitize: true});&lt;/code>&lt;/pre>
</example><example>&lt;p>Same example as previous, but demonstrates how an object can be passed in as
the first argument, then the value argument can then be the second argument.&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](new dojo._Url(&amp;quot;my/module/template.html&amp;quot;), {sanitize: true});&lt;/code>&lt;/pre>
</example></examples></method><method name="getL10nName" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="moduleName" type="undefined" usage="required"/><parameter name="bundleName" type="undefined" usage="required"/><parameter name="locale" type="undefined" usage="required"/></parameters><return-types><return-type type="string"/></return-types></method><method name="cookie" scope="normal" type="function" from="dojo/cookie"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of the cookie&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>Value for the cookie&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="optional"><summary>&lt;p>Properties for the cookie&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>expires (Date|String|Number, optional): &lt;p>If a number, the number of days from today at which the cookie
will expire. If a date, the date past which the cookie will expire.
If expires is in the past, the cookie will be deleted.
If expires is omitted or is 0, the cookie will expire when the browser closes.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>path (String, optional): &lt;p>The path to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>domain (String, optional): &lt;p>The domain to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>secure (Boolean, optional): &lt;p>Whether to only send the cookie on secure connections&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Get or set a cookie.&lt;/p>
</summary><description>&lt;p>If one argument is passed, returns the value of the cookie
For two or more arguments, acts as a setter.&lt;/p>
</description><examples><example>&lt;p>set a cookie with the JSON-serialized contents of an object which
will expire 5 days from now:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    cookie(&amp;quot;configObj&amp;quot;, json.stringify(config, {expires: 5 }));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>de-serialize a cookie back into a JavaScript object:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    config = json.parse(cookie(&amp;quot;configObj&amp;quot;));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>delete a cookie:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;], function(cookie){
    cookie(&amp;quot;configObj&amp;quot;, null, {expires: -1});
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="hash" scope="normal" type="function" from="dojo/hash"><parameters><parameter name="hash" type="String" usage="optional"><summary>&lt;p>the hash is set - #string.&lt;/p>
</summary></parameter><parameter name="replace" type="Boolean" usage="optional"><summary>&lt;p>If true, updates the hash value in the current history
state instead of creating a new history state.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>when used as a getter, returns the current hash string.
when used as a setter, returns the new hash string.</return-description><summary>&lt;p>Gets or sets the hash string in the browser URL.&lt;/p>
</summary><description>&lt;p>Handles getting and setting of location.hash.

&lt;/p>
&lt;ul>
&lt;li>If no arguments are passed, acts as a getter.&lt;/li>
&lt;li>If a string is passed, acts as a setter.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  topic.subscribe(&amp;quot;/dojo/hashchange&amp;quot;, context, callback);

  function callback (hashValue){
    // do something based on the hash value.
  }&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module is the foundational module of the dojo boot sequence; it defines the dojo object.&lt;/p>
</summary></object><object location="dojo/loadInit" type="object"><properties><property name="dynamic" scope="normal" type="number" from="dojo/loadInit"/><property name="load" scope="normal" type="undefined" from="dojo/loadInit"/></properties><methods><method name="normalize" scope="normal" type="function" from="dojo/loadInit"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods></object><object location="dojo/main" type="object"><properties><property name="config" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>This module defines the user configuration during bootstrap.&lt;/p>
</summary><description>&lt;p>By defining user configuration as a module value, an entire configuration can be specified in a build,
thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
Also, when multiple instances of dojo exist in a single application, each will necessarily be located
at an unique absolute module identifier as given by the package configuration. Implementing configuration
as a module allows for specifying unique, per-instance configurations.&lt;/p>
</description><examples><example>&lt;p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
dojo.js are already loaded).&lt;/p>
&lt;pre>&lt;code>  // specify a configuration that creates a new instance of dojo at the absolute module identifier &amp;quot;myDojo&amp;quot;
  require({
    packages:[{
      name:&amp;quot;myDojo&amp;quot;,
      location:&amp;quot;.&amp;quot;, //assume baseUrl points to dojo.js
    }]
  });

  // specify a configuration for the myDojo instance
  define(&amp;quot;myDojo/config&amp;quot;, {
    // normal configuration variables go here, e.g.,
    locale:&amp;quot;fr-ca&amp;quot;
  });

  // load and use the new instance of dojo
  require([&amp;quot;myDojo&amp;quot;], function(dojo){
    // dojo is the new instance of dojo
    // use as required
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="global" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current window. &amp;#39;global&amp;#39; can be modified
for temporary context shifting. See also withGlobal().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description></property><property name="dijit" scope="normal" type="object" from="dojo/_base/kernel"/><property name="dojox" scope="normal" type="object" from="dojo/_base/kernel"/><property name="scopeMap" scope="normal" type="object" from="dojo/_base/kernel"/><property name="baseUrl" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isAsync" scope="normal" type="boolean" from="dojo/_base/kernel"/><property name="locale" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="version" scope="normal" type="object" from="dojo/_base/kernel"><summary>&lt;p>Version number of the Dojo Toolkit&lt;/p>
</summary><description>&lt;p>Hash about the version, including

&lt;/p>
&lt;ul>
&lt;li>major: Integer: Major version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 1&lt;/li>
&lt;li>minor: Integer: Minor version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 2&lt;/li>
&lt;li>patch: Integer: Patch version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 0&lt;/li>
&lt;li>flag: String: Descriptor flag. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be &amp;quot;beta1&amp;quot;&lt;/li>
&lt;li>revision: Number: The SVN rev from which dojo was pulled&lt;/li>
&lt;/ul>
</description></property><property name="_hasResource" scope="normal" type="object" from="dojo/_base/kernel"/><property name="doc" scope="normal" type="object" from="dojo/_base/window"><summary>&lt;p>Alias for the current document. &amp;#39;doc&amp;#39; can be modified
for temporary context shifting. See also withDoc().&lt;/p>
</summary><description>&lt;p>Use this rather than referring to &amp;#39;window.document&amp;#39; to ensure your code runs
correctly in managed contexts.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  n.appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></property><property name="isQuirks" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isIE" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
major detected IE version (6, 7, 8, etc.)&lt;/p>
</summary></property><property name="query" scope="normal" type="undefined" from="dojo/query"/><property name="mouseButtons" scope="normal" type="object" from="dojo/mouse"/><property name="_name" scope="normal" type="string" from="dojo/_base/configSpidermonkey"/><property name="isBrowser" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isFF" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isKhtml" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
detected version.&lt;/p>
</summary></property><property name="isWebKit" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is a WebKit-derived browser (Konqueror,
Safari, Chrome, etc.). undefined otherwise.&lt;/p>
</summary></property><property name="isMozilla" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isMoz" scope="normal" type="undefined" from="dojo/_base/configFirefoxExtension"/><property name="isOpera" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Opera. undefined otherwise. Corresponds to
major detected version.&lt;/p>
</summary></property><property name="isSafari" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Safari or iPhone. undefined otherwise.&lt;/p>
</summary></property><property name="isChrome" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is Chrome browser. undefined otherwise.&lt;/p>
</summary></property><property name="isMac" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if the client runs on Mac&lt;/p>
</summary></property><property name="isIos" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is iPhone, iPod, or iPad&lt;/p>
</summary></property><property name="isAndroid" scope="normal" type="Number|undefined" from="dojo/_base/sniff"><summary>&lt;p>Version as a Number if client is android browser. undefined otherwise.&lt;/p>
</summary></property><property name="isWii" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Wii&lt;/p>
</summary></property><property name="isAir" scope="normal" type="Boolean" from="dojo/_base/sniff"><summary>&lt;p>True if client is Adobe Air&lt;/p>
</summary></property><property name="keys" scope="normal" type="object" from="dojo/keys"><summary>&lt;p>Definitions for common key values.  Client code should test keyCode against these named constants,
as the actual codes can vary by browser.&lt;/p>
</summary></property><property name="subscribe" scope="normal" type="undefined" from="dojo/robotx"/><property name="publish" scope="normal" type="undefined" from="dojo/robotx"/><property name="connectPublisher" scope="normal" type="undefined" from="dojo/robotx"/><property name="_nodeDataCache" scope="normal" type="object" from="dojo/NodeList-data"/><property name="_postLoad" scope="normal" type="boolean" from="dojo/ready"/><property name="fx" scope="normal" type="object" from="dojo/fx"><summary>&lt;p>Effects library on top of Base animations&lt;/p>
</summary></property><property name="toJsonIndentStr" scope="normal" type="string" from="dojo/_base/json"/><property name="date" scope="normal" type="object" from="dojo/date/stamp"/><property name="parser" scope="normal" type="object" from="dojo/parser"><summary>&lt;p>The Dom/Widget parsing package&lt;/p>
</summary></property><property name="html" scope="normal" type="object" from="dojo/html"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="_blockAsync" scope="normal" type="boolean" from="dojo/_base/xhr"/><property name="contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_contentHandlers" scope="normal" type="object" from="dojo/_base/xhr"><summary>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls.&lt;/p>
</summary><description>&lt;p>A map of available XHR transport handle types. Name matches the
&lt;code>handleAs&lt;/code> attribute passed to XHR calls. Each contentHandler is
called, passing the xhr object for manipulation. The return value
from the contentHandler will be passed to the &lt;code>load&lt;/code> or &lt;code>handle&lt;/code>
functions defined in the original xhr call.&lt;/p>
</description><examples><example>&lt;p>Creating a custom content-handler:&lt;/p>
&lt;pre>&lt;code>  xhr.contentHandlers.makeCaps = function(xhr){
    return xhr.responseText.toUpperCase();
  }
  // and later:
  dojo.xhrGet({
    url:&amp;quot;foo.txt&amp;quot;,
    handleAs:&amp;quot;makeCaps&amp;quot;,
    load: function(data){ /* data is a toUpper version of foo.txt */ }
  });&lt;/code>&lt;/pre>
</example></examples></property><property name="_windowUnloaders" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_defaultContext" scope="normal" type="Array" from="dojo/_base/configFirefoxExtension"/><property name="_initFired" scope="normal" type="boolean" from="dojo/_base/configFirefoxExtension"/><property name="isSpidermonkey" scope="normal" type="boolean" from="dojo/_base/configSpidermonkey"/><property name="back" scope="normal" type="object" from="dojo/back"><summary>&lt;p>Browser history management resources&lt;/p>
</summary></property><property name="behavior" scope="normal" type="instance" from="dojo/behavior"/><property name="cldr" scope="normal" type="object" from="dojo/cldr/monetary"/><property name="i18n" scope="normal" type="object" from="dojo/i18n"><summary>&lt;p>This module implements the dojo/i18n! plugin and the v1.6- i18n API&lt;/p>
</summary><description>&lt;p>We choose to include our own plugin to leverage functionality already contained in dojo
and thereby reduce the size of the plugin compared to various loader implementations. Also, this
allows foreign AMD loaders to be used without their plugins.&lt;/p>
</description></property><property name="colors" scope="normal" type="object" from="dojo/colors"/><property name="regexp" scope="normal" type="object" from="dojo/regexp"><summary>&lt;p>Regular expressions and Builder resources&lt;/p>
</summary></property><property name="string" scope="normal" type="object" from="dojo/string"><summary>&lt;p>String utilities for Dojo&lt;/p>
</summary></property><property name="number" scope="normal" type="object" from="dojo/number"><summary>&lt;p>localized formatting and parsing routines for Number&lt;/p>
</summary></property><property name="currency" scope="normal" type="object" from="dojo/currency"><summary>&lt;p>localized formatting and parsing routines for currencies&lt;/p>
</summary><description>&lt;p>extends dojo.number to provide culturally-appropriate formatting of values
in various world currencies, including use of a currency symbol.  The currencies are specified
by a three-letter international symbol in all uppercase, and support for the currencies is
provided by the data in &lt;code>dojo.cldr&lt;/code>.  The scripts generating dojo.cldr specify which
currency support is included.  A fixed number of decimal places is determined based
on the currency type and is not determined by the &amp;#39;pattern&amp;#39; argument.  The fractional
portion is optional, by default, and variable length decimals are not supported.&lt;/p>
</description></property><property name="data" scope="normal" type="object" from="dojo/data/util/filter"/><property name="dnd" scope="normal" type="object" from="dojo/dnd/common"/><property name="touch" scope="normal" type="object" from="dojo/touch"><summary>&lt;p>This module provides unified touch event handlers by exporting
press, move, release and cancel which can also run well on desktop.
Based on &lt;a href=&quot;http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&quot;>http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html&lt;/a>
&lt;/p>
</summary><examples><example>&lt;p>Used with dojo.on&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/on&amp;quot;, &amp;quot;dojo/touch&amp;quot;], function(on, touch){
    on(node, touch.press, function(e){});
    on(node, touch.move, function(e){});
    on(node, touch.release, function(e){});
    on(node, touch.cancel, function(e){});&lt;/code>&lt;/pre>
</example><example>&lt;p>Used with touch.* directly&lt;/p>
&lt;pre>&lt;code>  touch.press(node, function(e){});
  touch.move(node, function(e){});
  touch.release(node, function(e){});
  touch.cancel(node, function(e){});&lt;/code>&lt;/pre>
</example></examples></property><property name="window" scope="normal" type="object" from="dojo/window"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="gears" scope="normal" type="object" from="dojo/gears"><summary>&lt;p>TODOC&lt;/p>
</summary></property><property name="io" scope="normal" type="object" from="dojo/io/iframe"/><property name="rpc" scope="normal" type="object" from="dojo/rpc/RpcService"/><property name="store" scope="normal" type="object" from="dojo/store/Cache"/><property name="tests" scope="normal" type="object" from="dojo/tests"><summary>&lt;p>D.O.H. Test files for Dojo unit testing.&lt;/p>
</summary></property></properties><methods><method name="eval" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="scriptText" type="undefined" usage="required"><summary>&lt;p>The text to evaluation.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The result of the evaluation. Often `undefined`</return-description><summary>&lt;p>A legacy method created for use exclusively by internal Dojo methods. Do not use this method
directly unless you understand its possibly-different implications on the platforms your are targeting.&lt;/p>
</summary><description>&lt;p>Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
that support indirect eval.

&lt;/p>
&lt;p>As usual, IE does not. On IE, the only way to implement global eval is to
use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
This implementation uses the technique of executing eval in the scope of a function that is a single scope
frame below the global scope; thereby coming close to the global scope. Note carefully that

&lt;/p>
&lt;p>dojo.eval(&amp;quot;var pi = 3.14;&amp;quot;);

&lt;/p>
&lt;p>will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
to define a global variable using dojo.eval, write something like

&lt;/p>
&lt;p>dojo.eval(&amp;quot;window.pi = 3.14;&amp;quot;)&lt;/p>
</description></method><method name="exit" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="exitcode" type="undefined" usage="required"/></parameters><return-types/></method><method name="experimental" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>The name of a module, or the name of a module file or a specific
function&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>some additional message for the user&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Marks code as experimental.&lt;/p>
</summary><description>&lt;p>This can be used to mark a function, file, or module as
experimental.   Experimental code is not ready to be used, and the
APIs are subject to change without notice.  Experimental code may be
completed deleted without going through the normal deprecation
process.&lt;/p>
</description><examples><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.data.Result&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> dojo.experimental(&amp;quot;dojo.weather.toKelvin()&amp;quot;, &amp;quot;PENDING approval from NOAA&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="deprecated" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="behaviour" type="String" usage="required"><summary>&lt;p>The API or behavior being deprecated. Usually in the form
of &amp;quot;myApp.someFunction()&amp;quot;.&lt;/p>
</summary></parameter><parameter name="extra" type="String" usage="optional"><summary>&lt;p>Text to append to the message. Often provides advice on a
new function or facility to achieve the same goal during
the deprecation period.&lt;/p>
</summary></parameter><parameter name="removal" type="String" usage="optional"><summary>&lt;p>Text to indicate when in the future the behavior will be
removed. Usually a version number.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Log a debug message to indicate that a behavior has been
deprecated.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> dojo.deprecated(&amp;quot;myApp.getTemp()&amp;quot;, &amp;quot;use myApp.getLocaleTemp() instead&amp;quot;, &amp;quot;1.0&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="moduleUrl" scope="normal" type="function" from="dojo/_base/kernel"><parameters><parameter name="module" type="String" usage="required"><summary>&lt;p>dojo/dom-class&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Returns a URL relative to a module.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var pngPath = dojo.moduleUrl(&amp;quot;acme&amp;quot;,&amp;quot;images/small.png&amp;quot;);
  console.dir(pngPath); // list the object properties
  // create an image and set it&amp;#39;s source to pngPath&amp;#39;s value:
  var img = document.createElement(&amp;quot;img&amp;quot;);
  img.src = pngPath;
  // add our image to the document
  dojo.body().appendChild(img);&lt;/code>&lt;/pre>
</example><example>&lt;p>you may de-reference as far as you like down the package
hierarchy.  This is sometimes handy to avoid lenghty relative
urls or for building portable sub-packages. In this example,
the &lt;code>acme.widget&lt;/code> and &lt;code>acme.util&lt;/code> directories may be located
under different roots (see &lt;code>dojo.registerModulePath&lt;/code>) but the
the modules which reference them can be unaware of their
relative locations on the filesystem:&lt;/p>
&lt;pre>&lt;code>  // somewhere in a configuration block
  dojo.registerModulePath(&amp;quot;acme.widget&amp;quot;, &amp;quot;../../acme/widget&amp;quot;);
  dojo.registerModulePath(&amp;quot;acme.util&amp;quot;, &amp;quot;../../util&amp;quot;);

  // ...

  // code in a module using acme resources
  var tmpltPath = dojo.moduleUrl(&amp;quot;acme.widget&amp;quot;,&amp;quot;templates/template.html&amp;quot;);
  var dataPath = dojo.moduleUrl(&amp;quot;acme.util&amp;quot;,&amp;quot;resources/data.json&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="AdapterRegistry" scope="normal" type="function" from="dojo/AdapterRegistry"><parameters><parameter name="returnWrappers" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>A registry to make contextual calling/searching easier.&lt;/p>
</summary><description>&lt;p>Objects of this class keep list of arrays in the form [name, check,
wrap, directReturn] that are used to determine what the contextual
result of a set of checked arguments is. All check/wrap functions
in this registry should be of the same arity.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // create a new registry
  var reg = new dojo.AdapterRegistry();
  reg.register(&amp;quot;handleString&amp;quot;,
    dojo.isString,
    function(str){
      // do something with the string here
    }
  );
  reg.register(&amp;quot;handleArr&amp;quot;,
    dojo.isArray,
    function(arr){
      // do something with the array here
    }
  );

  // now we can pass reg.match() *either* an array or a string and
  // the value we pass will get handled by the right function
  reg.match(&amp;quot;someValue&amp;quot;); // will call the first function
  reg.match([&amp;quot;someValue&amp;quot;]); // will call the second&lt;/code>&lt;/pre>
</example></examples></method><method name="Deferred" scope="normal" type="function" from="dojo/_base/Deferred"><parameters><parameter name="canceller" type="Function" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.
New code should use dojo/Deferred instead.&lt;/p>
</summary><description>&lt;p>The Deferred API is based on the concept of promises that provide a
generic interface into the eventual completion of an asynchronous action.
The motivation for promises fundamentally is about creating a
separation of concerns that allows one to achieve the same type of
call patterns and logical data flow in asynchronous code as can be
achieved in synchronous code. Promises allows one
to be able to call a function purely with arguments needed for
execution, without conflating the call with concerns of whether it is
sync or async. One shouldn&amp;#39;t need to alter a call&amp;#39;s arguments if the
implementation switches from sync to async (or vice versa). By having
async functions return promises, the concerns of making the call are
separated from the concerns of asynchronous interaction (which are
handled by the promise).

&lt;/p>
&lt;p>The Deferred is a type of promise that provides methods for fulfilling the
promise with a successful result or an error. The most important method for
working with Dojo&amp;#39;s promises is the then() method, which follows the
CommonJS proposed promise API. An example of using a Dojo promise:

&lt;/p>
&lt;pre>&lt;code>  var resultingPromise = someAsyncOperation.then(function(result){
    ... handle result ...
  },
  function(error){
    ... handle error ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>The .then() call returns a new promise that represents the result of the
execution of the callback. The callbacks will never affect the original promises value.

&lt;/p>
&lt;p>The Deferred instances also provide the following functions for backwards compatibility:

&lt;/p>
&lt;ul>
&lt;li>addCallback(handler)&lt;/li>
&lt;li>addErrback(handler)&lt;/li>
&lt;li>callback(result)&lt;/li>
&lt;li>errback(result)&lt;/li>
&lt;/ul>
&lt;p>Callbacks are allowed to return promises themselves, so
you can build complicated sequences of events with ease.

&lt;/p>
&lt;p>The creator of the Deferred may specify a canceller.  The canceller
is a function that will be called if Deferred.cancel is called
before the Deferred fires. You can use this to implement clean
aborting of an XMLHttpRequest, etc. Note that cancel will fire the
deferred with a CancelledError (unless your canceller returns
another kind of error), so the errbacks should be prepared to
handle that error for cancellable Deferreds.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var deferred = new Deferred();
  setTimeout(function(){ deferred.callback({success: true}); }, 1000);
  return deferred;&lt;/code>&lt;/pre>
</example><example>&lt;p>Deferred objects are often used when making code asynchronous. It
may be easiest to write functions in a synchronous manner and then
split code using a deferred to trigger a response to a long-lived
operation. For example, instead of register a callback function to
denote when a rendering operation completes, the function can
simply return a deferred:

&lt;/p>
&lt;pre>&lt;code>  // callback style:
  function renderLotsOfData(data, callback){
    var success = false
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      success = true;
    }catch(e){ }
    if(callback){
      callback(success);
    }
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using callback style
  renderLotsOfData(someDataObj, function(success){
    // handles success or failure
    if(!success){
      promptUserToRecover();
    }
  });
  // NOTE: no way to add another callback here!!&lt;/code>&lt;/pre>
</example><example>&lt;p>Using a Deferred doesn&amp;#39;t simplify the sending code any, but it
provides a standard interface for callers and senders alike,
providing both with a simple way to service multiple callbacks for
an operation and freeing both sides from worrying about details
such as &amp;quot;did this get called already?&amp;quot;. With Deferreds, new
callbacks can be added at any time.

&lt;/p>
&lt;pre>&lt;code>  // Deferred style:
  function renderLotsOfData(data){
    var d = new Deferred();
    try{
      for(var x in data){
        renderDataitem(data[x]);
      }
      d.callback(true);
    }catch(e){
      d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
    }
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });
  // NOTE: addErrback and addCallback both return the Deferred
  // again, so we could chain adding callbacks or save the
  // deferred for later should we need to be notified again.&lt;/code>&lt;/pre>
</example><example>&lt;p>In this example, renderLotsOfData is synchronous and so both
versions are pretty artificial. Putting the data display on a
timeout helps show why Deferreds rock:

&lt;/p>
&lt;pre>&lt;code>  // Deferred style and async func
  function renderLotsOfData(data){
    var d = new Deferred();
    setTimeout(function(){
      try{
        for(var x in data){
          renderDataitem(data[x]);
        }
        d.callback(true);
      }catch(e){
        d.errback(new Error(&amp;quot;rendering failed&amp;quot;));
      }
    }, 100);
    return d;
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;pre>&lt;code>  // using Deferred style
  renderLotsOfData(someDataObj).then(null, function(){
    promptUserToRecover();
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that the caller doesn&amp;#39;t have to change his code at all to
handle the asynchronous case.&lt;/p>
</example></examples></method><method name="when" scope="normal" type="function" from="dojo/when"><parameters><parameter name="valueOrPromise" type="undefined" usage="required"><summary>&lt;p>Either a regular value or an object with a &lt;code>then()&lt;/code> method that
follows the Promises/A specification.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is resolved, or a non-promise
is received.&lt;/p>
</summary></parameter><parameter name="errback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise is rejected.&lt;/p>
</summary></parameter><parameter name="progback" type="Function" usage="optional"><summary>&lt;p>Callback to be invoked when the promise emits a progress update.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/><return-type type="undefined"/><return-type type="name:"/></return-types><return-description>Promise, or if a callback is provided, the result of the callback.</return-description><summary>&lt;p>Transparently applies callbacks to values and/or promises.&lt;/p>
</summary><description>&lt;p>Accepts promises but also transparently handles non-promises. If no
callbacks are provided returns a promise, regardless of the initial
value. Foreign promises are converted.

&lt;/p>
&lt;p>If callbacks are provided and the initial value is not a promise,
the callback is executed immediately with no error handling. Returns
a promise if the initial value is a promise, or the result of the
callback otherwise.&lt;/p>
</description></method><method name="every" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not every item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s every skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // returns false
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code>  // returns true
  array.every([1, 2, 3, 4], function(item){ return item&amp;gt;0; });&lt;/code>&lt;/pre>
</example></examples></method><method name="some" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate over. If a string, operates on individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments: item, index,
and array and returns true if the condition is met.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><summary>&lt;p>Determines whether or not any item in arr satisfies the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s some skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // is true
 array.some([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // is false
 array.some([1, 2, 3, 4], function(item){ return item&amp;lt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="indexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"/><parameter name="value" type="Object" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/><parameter name="findLast" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the first index of the provided value in the
passed array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s indexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&lt;/a>&lt;/p>
</description></method><method name="lastIndexOf" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="undefined" usage="required"/><parameter name="value" type="undefined" usage="required"/><parameter name="fromIndex" type="Integer" usage="optional"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>locates the last index of the provided value in the passed
array. If the value is not found, -1 is returned.&lt;/p>
</summary><description>&lt;p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
1.6&amp;#39;s lastIndexOf skips the holes in the sparse array.
For details on this method, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf&lt;/a>&lt;/p>
</description></method><method name="forEach" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"/><parameter name="callback" type="Function|String" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/></parameters><return-types/><summary>&lt;p>for every item in arr, callback is invoked. Return values are ignored.
If you want to break out of the loop, consider using array.every() or array.some().
forEach does not allow breaking out of the loop over the items in arr.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s forEach skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // log out all members of the array:
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item){
      console.log(item);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // log out the members and their indexes
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    function(item, idx, arr){
      console.log(item, &amp;quot;at index:&amp;quot;, idx);
    }
 );&lt;/code>&lt;/pre>
</example><example>&lt;pre>&lt;code> // use a scoped object member as the callback

 var obj = {
    prefix: &amp;quot;logged via obj.callback:&amp;quot;,
    callback: function(item){
      console.log(this.prefix, item);
    }
 };

 // specifying the scope function executes the callback in that scope
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    obj.callback,
    obj
 );

 // alternately, we can accomplish the same thing with lang.hitch()
 array.forEach(
    [ &amp;quot;thinger&amp;quot;, &amp;quot;blah&amp;quot;, &amp;quot;howdy&amp;quot;, 10 ],
    lang.hitch(obj, &amp;quot;callback&amp;quot;)
 );&lt;/code>&lt;/pre>
</example></examples></method><method name="map" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array|String" usage="required"><summary>&lt;p>the array to iterate on. If a string, operates on
individual characters.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function is invoked with three arguments, (item, index,
array),   and returns a value&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter><parameter name="Ctr" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/><return-type type="instance"/></return-types><summary>&lt;p>applies callback to each element of arr and returns
an Array with the results&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s map skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4, 5]
 array.map([1, 2, 3, 4], function(item){ return item+1 });&lt;/code>&lt;/pre>
</example></examples></method><method name="filter" scope="normal" type="function" from="dojo/_base/array"><parameters><parameter name="arr" type="Array" usage="required"><summary>&lt;p>the array to iterate over.&lt;/p>
</summary></parameter><parameter name="callback" type="Function|String" usage="required"><summary>&lt;p>a function that is invoked with three arguments (item,
index, array). The return of this function is expected to
be a boolean which determines whether the passed-in item
will be included in the returned array.&lt;/p>
</summary></parameter><parameter name="thisObject" type="Object" usage="optional"><summary>&lt;p>may be used to scope the call to callback&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Returns a new Array with those items from arr that match the
condition implemented by callback.&lt;/p>
</summary><description>&lt;p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
run over sparse arrays, this implementation passes the &amp;quot;holes&amp;quot; in the sparse array to
the callback function with a value of undefined. JavaScript 1.6&amp;#39;s filter skips the holes in the sparse array.
For more details, see:
&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&quot;>https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter&lt;/a>&lt;/p>
</description><examples><example>&lt;pre>&lt;code> // returns [2, 3, 4]
 array.filter([1, 2, 3, 4], function(item){ return item&amp;gt;1; });&lt;/code>&lt;/pre>
</example></examples></method><method name="clearCache" scope="normal" type="function" from="dojo/_base/array"><parameters/><return-types/></method><method name="DeferredList" scope="normal" type="function" from="dojo/DeferredList"><parameters><parameter name="list" type="Array" usage="required"><summary>&lt;p>The list of deferreds to be synchronizied with this DeferredList&lt;/p>
</summary></parameter><parameter name="fireOnOneCallback" type="Boolean" usage="optional"><summary>&lt;p>Will cause the DeferredLists callback to be fired as soon as any
of the deferreds in its list have been fired instead of waiting until
the entire list has finished&lt;/p>
</summary></parameter><parameter name="fireOnOneErrback" type="Boolean" usage="optional"/><parameter name="consumeErrors" type="Boolean" usage="optional"/><parameter name="canceller" type="Function" usage="optional"><summary>&lt;p>A deferred canceller function, see dojo.Deferred&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deprecated, use dojo/promise/all instead.
Provides event handling for a group of Deferred objects.&lt;/p>
</summary><description>&lt;p>DeferredList takes an array of existing deferreds and returns a new deferred of its own
this new deferred will typically have its callback fired when all of the deferreds in
the given list have fired their own deferreds.  The parameters &lt;code>fireOnOneCallback&lt;/code> and
fireOnOneErrback, will fire before all the deferreds as appropriate&lt;/p>
</description></method><method name="body" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="doc" type="Document" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the body element of the specified document or of dojo/_base/window::doc.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  win.body().appendChild(dojo.doc.createElement(&amp;#39;div&amp;#39;));&lt;/code>&lt;/pre>
</example></examples></method><method name="setContext" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="globalDocument" type="DocumentElement" usage="required"/></parameters><return-types/><summary>&lt;p>changes the behavior of many core Dojo functions that deal with
namespace and DOM lookup, changing them to work in a new global
context (e.g., an iframe). The varibles dojo.global and dojo.doc
are modified as a result of calling this function and the result of
&lt;code>dojo.body()&lt;/code> likewise differs.&lt;/p>
</summary></method><method name="withGlobal" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="globalObject" type="Object" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with globalObject as dojo.global and
globalObject.document as dojo.doc. If provided, globalObject
will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo.global
and dojo.doc will be restored to its previous state.&lt;/p>
</description></method><method name="withDoc" scope="normal" type="function" from="dojo/_base/window"><parameters><parameter name="documentObject" type="DocumentElement" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="thisObject" type="Object" usage="optional"/><parameter name="cbArguments" type="Array" usage="optional"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc.&lt;/p>
</summary><description>&lt;p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,
callback will be executed in the context of object thisObject
When callback() returns or throws an error, the dojo/_base/window::doc will
be restored to its previous state.&lt;/p>
</description></method><method name="_filterQueryResult" scope="normal" type="function" from="dojo/query"><parameters><parameter name="nodes" type="undefined" usage="required"/><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/><return-type type="undefined"/></return-types></method><method name="NodeList" scope="normal" type="function" from="dojo/query"><parameters><parameter name="array" type="undefined" usage="required"/></parameters><return-types><return-type type="Array"/></return-types><summary>&lt;p>Array-like object which adds syntactic
sugar for chaining, common iteration operations, animation, and
node manipulation. NodeLists are most often returned as the
result of dojo.query() calls.&lt;/p>
</summary><description>&lt;p>NodeList instances provide many utilities that reflect
core Dojo APIs for Array iteration and manipulation, DOM
manipulation, and event handling. Instead of needing to dig up
functions in the dojo.* namespace, NodeLists generally make the
full power of Dojo available for DOM manipulation tasks in a
simple, chainable way.&lt;/p>
</description><examples><example>&lt;p>create a node list from a node&lt;/p>
&lt;pre>&lt;code>  new query.NodeList(dojo.byId(&amp;quot;foo&amp;quot;));&lt;/code>&lt;/pre>
</example><example>&lt;p>get a NodeList from a CSS query and iterate on it&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  l.forEach(function(node, index, nodeList){
    console.log(index, node.innerHTML);
  });&lt;/code>&lt;/pre>
</example><example>&lt;p>use native and Dojo-provided array methods to manipulate a
NodeList without needing to use dojo.* functions explicitly:&lt;/p>
&lt;pre>&lt;code>  var l = dojo.query(&amp;quot;.thinger&amp;quot;);
  // since NodeLists are real arrays, they have a length
  // property that is both readable and writable and
  // push/pop/shift/unshift methods
  console.log(l.length);
  l.push(dojo.create(&amp;quot;span&amp;quot;));

  // dojo&amp;#39;s normalized array methods work too:
  console.log( l.indexOf(dojo.byId(&amp;quot;foo&amp;quot;)) );
  // ...including the special &amp;quot;function as string&amp;quot; shorthand
  console.log( l.every(&amp;quot;item.nodeType == 1&amp;quot;) );

  // NodeLists can be [..] indexed, or you can use the at()
  // function to get specific items wrapped in a new NodeList:
  var node = l[3]; // the 4th element
  var newList = l.at(1, 3); // the 2nd and 4th elements&lt;/code>&lt;/pre>
</example><example>&lt;p>the style functions you expect are all there too:&lt;/p>
&lt;pre>&lt;code>  // style() as a getter...
  var borders = dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;);
  // ...and as a setter:
  dojo.query(&amp;quot;.thinger&amp;quot;).style(&amp;quot;border&amp;quot;, &amp;quot;1px solid black&amp;quot;);
  // class manipulation
  dojo.query(&amp;quot;li:nth-child(even)&amp;quot;).addClass(&amp;quot;even&amp;quot;);
  // even getting the coordinates of all the items
  var coords = dojo.query(&amp;quot;.thinger&amp;quot;).coords();&lt;/code>&lt;/pre>
</example><example>&lt;p>DOM manipulation functions from the dojo.* namespace area also available:&lt;/p>
&lt;pre>&lt;code>  // remove all of the elements in the list from their
  // parents (akin to &amp;quot;deleting&amp;quot; them from the document)
  dojo.query(&amp;quot;.thinger&amp;quot;).orphan();
  // place all elements in the list at the front of #foo
  dojo.query(&amp;quot;.thinger&amp;quot;).place(&amp;quot;foo&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Event handling couldn&amp;#39;t be easier. &lt;code>dojo.connect&lt;/code> is mapped in,
and shortcut handlers are provided for most DOM events:&lt;/p>
&lt;pre>&lt;code>  // like dojo.connect(), but with implicit scope
  dojo.query(&amp;quot;li&amp;quot;).connect(&amp;quot;onclick&amp;quot;, console, &amp;quot;log&amp;quot;);

  // many common event handlers are already available directly:
  dojo.query(&amp;quot;li&amp;quot;).onclick(console, &amp;quot;log&amp;quot;);
  var toggleHovered = dojo.hitch(dojo, &amp;quot;toggleClass&amp;quot;, &amp;quot;hovered&amp;quot;);
  dojo.query(&amp;quot;p&amp;quot;)
    .onmouseenter(toggleHovered)
    .onmouseleave(toggleHovered);&lt;/code>&lt;/pre>
</example><example>&lt;p>chainability is a key advantage of NodeLists:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.thinger&amp;quot;)
    .onclick(function(e){ /* ... */ })
    .at(1, 3, 8) // get a subset
      .style(&amp;quot;padding&amp;quot;, &amp;quot;5px&amp;quot;)
      .forEach(console.log);&lt;/code>&lt;/pre>
</example></examples></method><method name="fixEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>native event object&lt;/p>
</summary></parameter><parameter name="sender" type="DOMNode" usage="required"><summary>&lt;p>node to treat as &amp;quot;currentTarget&amp;quot;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Event"/></return-types><return-description>&lt;p>native event object&lt;/p>
</return-description><summary>&lt;p>normalizes properties on the event object including event
bubbling methods, keystroke normalization, and x/y positions&lt;/p>
</summary></method><method name="stopEvent" scope="normal" type="function" from="dojo/_base/event"><parameters><parameter name="evt" type="Event" usage="required"><summary>&lt;p>The event object. If omitted, window.event is used on IE.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>prevents propagation and clobbers the default action of the
passed event&lt;/p>
</summary></method><method name="_keypress" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="object" type="undefined" usage="required"/><parameter name="listener" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="connect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="obj" type="Object" usage="optional"><summary>&lt;p>The source object for the event function.
Defaults to &lt;code>kernel.global&lt;/code> if null.
If obj is a DOM node, the connection is delegated
to the DOM event manager (unless dontFix is true).
&lt;/p>
</summary></parameter><parameter name="event" type="String" usage="required"><summary>&lt;p>String name of the event function in obj.
I.e. identifies a property &lt;code>obj[event]&lt;/code>.
&lt;/p>
</summary></parameter><parameter name="context" type="Object|null" usage="required"><summary>&lt;p>The object that method will receive as &amp;quot;this&amp;quot;.

&lt;/p>
&lt;p>If context is null and method is a function, then method
inherits the context of event.

&lt;/p>
&lt;p>If method is a string then context must be the source
object object for method (context[method]). If context is null,
kernel.global is used.
&lt;/p>
</summary></parameter><parameter name="method" type="String|Function" usage="required"><summary>&lt;p>A function reference, or name of a function in context.
The function identified by method fires after event does.
method receives the same arguments as the event.
See context argument comments for information on method&amp;#39;s scope.
&lt;/p>
</summary></parameter><parameter name="dontFix" type="Boolean" usage="optional"><summary>&lt;p>If obj is a DOM node, set dontFix to true to prevent delegation
of this connection to the DOM event manager.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>&lt;code>dojo.connect&lt;/code> is a deprecated event handling and delegation method in
Dojo. It allows one function to &amp;quot;listen in&amp;quot; on the execution of
any other, triggering the second whenever the first is called. Many
listeners may be attached to a function, and source functions may
be either regular function calls or DOM events.
&lt;/p>
</summary><description>&lt;p>Connects listeners to actions, so that after event fires, a
listener is called with the same arguments passed to the original
function.

&lt;/p>
&lt;p>Since &lt;code>dojo.connect&lt;/code> allows the source of events to be either a
&amp;quot;regular&amp;quot; JavaScript function or a DOM event, it provides a uniform
interface for listening to all the types of events that an
application is likely to deal with though a single, unified
interface. DOM programmers may want to think of it as
&amp;quot;addEventListener for everything and anything&amp;quot;.

&lt;/p>
&lt;p>When setting up a connection, the &lt;code>event&lt;/code> parameter must be a
string that is the name of the method/event to be listened for. If
&lt;code>obj&lt;/code> is null, &lt;code>kernel.global&lt;/code> is assumed, meaning that connections
to global methods are supported but also that you may inadvertently
connect to a global by passing an incorrect object name or invalid
reference.

&lt;/p>
&lt;p>&lt;code>dojo.connect&lt;/code> generally is forgiving. If you pass the name of a
function or method that does not yet exist on &lt;code>obj&lt;/code>, connect will
not fail, but will instead set up a stub method. Similarly, null
arguments may simply be omitted such that fewer than 4 arguments
may be required to set up a connection See the examples for details.

&lt;/p>
&lt;p>The return value is a handle that is needed to
remove this connection with &lt;code>dojo.disconnect&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>When obj.onchange(), do ui.update():&lt;/p>
&lt;pre>&lt;code>  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, ui.update); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using return value for disconnect:&lt;/p>
&lt;pre>&lt;code>  var link = dojo.connect(obj, &amp;quot;onchange&amp;quot;, ui, &amp;quot;update&amp;quot;);
  ...
  dojo.disconnect(link);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When onglobalevent executes, watcher.handler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;onglobalevent&amp;quot;, watcher, &amp;quot;handler&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked:&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, &amp;quot;customEventHandler&amp;quot;);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, &amp;quot;customEventHandler&amp;quot;); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When ob.onCustomEvent executes, customEventHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, null, customEventHandler);
  dojo.connect(ob, &amp;quot;onCustomEvent&amp;quot;, customEventHandler); // same&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When globalEvent executes, globalHandler is invoked
with the same scope (this):&lt;/p>
&lt;pre>&lt;code>  dojo.connect(null, &amp;quot;globalEvent&amp;quot;, null, globalHandler);
  dojo.connect(&amp;quot;globalEvent&amp;quot;, globalHandler); // same&lt;/code>&lt;/pre>
</example></examples></method><method name="disconnect" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>the return value of the dojo.connect call that created the connection.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a link created by dojo.connect.&lt;/p>
</summary><description>&lt;p>Removes the connection between event and the method referenced by handle.&lt;/p>
</description></method><method name="isCopyKey" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="e" type="Event" usage="required"><summary>&lt;p>Event object to examine&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)&lt;/p>
</summary></method><method name="unsubscribe" scope="normal" type="function" from="dojo/_base/connect"><parameters><parameter name="handle" type="Handle" usage="required"><summary>&lt;p>The handle returned from a call to subscribe.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a topic listener.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var alerter = dojo.subscribe(&amp;quot;alerts&amp;quot;, null, function(caption, message){ alert(caption + &amp;quot;\n&amp;quot; + message); };
  ...
  dojo.unsubscribe(alerter);&lt;/code>&lt;/pre>
</example></examples></method><method name="_nodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="Object|String" usage="optional"><summary>&lt;p>If an object, act as a setter and iterate over said object setting data items as defined.
If a string, and &lt;code>value&lt;/code> present, set the data for defined &lt;code>key&lt;/code> to &lt;code>value&lt;/code>
If a string, and &lt;code>value&lt;/code> absent, act as a getter, returning the data associated with said &lt;code>key&lt;/code>
&lt;/p>
</summary></parameter><parameter name="value" type="Anything" usage="optional"><summary>&lt;p>The value to set for said &lt;code>key&lt;/code>, provided &lt;code>key&lt;/code> is a string (and not an object)
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Private helper for dojo/NodeList.data for single node data access. Refer to NodeList.data
documentation for more information.
&lt;/p>
</summary></method><method name="_removeNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters><parameter name="node" type="String|DomNode" usage="required"><summary>&lt;p>The node to associate data with
&lt;/p>
</summary></parameter><parameter name="key" type="String" usage="optional"><summary>&lt;p>If omitted, remove all data in this dataset.
If passed, remove only the passed &lt;code>key&lt;/code> in the associated dataset&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove some data from this node&lt;/p>
</summary></method><method name="_gcNodeData" scope="normal" type="function" from="dojo/NodeList-data"><parameters/><return-types/><summary>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.&lt;/p>
</summary><description>&lt;p>super expensive: GC all data in the data for nodes that no longer exist in the dom.
MUCH safer to do this yourself, manually, on a per-node basis (via &lt;code>NodeList.removeData()&lt;/code>)
provided as a stop-gap for exceptionally large/complex applications with constantly changing
content regions (eg: a dijit/layout/ContentPane with replacing data)
There is NO automatic GC going on. If you dojo.destroy() a node, you should _removeNodeData
prior to destruction.&lt;/p>
</description></method><method name="safeMixin" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="target" type="Object" usage="required"><summary>&lt;p>Target object to accept new properties.&lt;/p>
</summary></parameter><parameter name="source" type="Object" usage="required"><summary>&lt;p>Source object for new properties.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Target object to accept new properties.&lt;/p>
</return-description><summary>&lt;p>Mix in properties skipping a constructor and decorating functions
like it is done by declare().&lt;/p>
</summary><description>&lt;p>This function is used to mix in properties like lang.mixin does,
but it skips a constructor property and decorates functions like
declare() does.

&lt;/p>
&lt;p>It is meant to be used with classes and objects produced with
declare. Functions mixed in with dojo.safeMixin can use
this.inherited() like normal methods.

&lt;/p>
&lt;p>This function is used to implement extend() method of a constructor
produced with declare().
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  var A = declare(null, {
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m1&amp;quot;);
    }
  });
  B.extend({
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  dojo.safeMixin(x, {
    m1: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m1&amp;quot;);
    },
    m2: function(){
      this.inherited(arguments);
      console.log(&amp;quot;X.m2&amp;quot;);
    }
  });
  x.m2();
  // prints:
  // A.m1
  // B.m1
  // X.m1&lt;/code>&lt;/pre>
</example></examples></method><method name="declare" scope="normal" type="function" from="dojo/_base/declare"><parameters><parameter name="className" type="String" usage="optional"><summary>&lt;p>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
It will be used as a global name for a created constructor.&lt;/p>
</summary></parameter><parameter name="superclass" type="Function|Function[]" usage="required"><summary>&lt;p>May be null, a Function, or an Array of Functions. This argument
specifies a list of bases (the left-most one is the most deepest
base).&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="required"><summary>&lt;p>An object whose properties are copied to the created prototype.
Add an instance-initialization function by making it a property
named &amp;quot;constructor&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/_base/declare.__DeclareCreatedObject"/><return-type type="undefined"/></return-types><return-description>New constructor function.</return-description><summary>&lt;p>Create a feature-rich constructor from compact notation.&lt;/p>
</summary><description>&lt;p>Create a constructor using a compact notation for inheritance and
prototype extension.

&lt;/p>
&lt;p>Mixin ancestors provide a type of multiple inheritance.
Prototypes of mixin ancestors are copied to the new class:
changes to mixin prototypes will not affect classes to which
they have been mixed in.

&lt;/p>
&lt;p>Ancestors can be compound classes created by this version of
declare(). In complex cases all base classes are going to be
linearized according to C3 MRO algorithm
(see &lt;a href=&quot;http://www.python.org/download/releases/2.3/mro/&quot;>http://www.python.org/download/releases/2.3/mro/&lt;/a> for more
details).

&lt;/p>
&lt;p>&amp;quot;className&amp;quot; is cached in &amp;quot;declaredClass&amp;quot; property of the new class,
if it was supplied. The immediate super class will be cached in
&amp;quot;superclass&amp;quot; property of the new class.

&lt;/p>
&lt;p>Methods in &amp;quot;props&amp;quot; will be copied and modified: &amp;quot;nom&amp;quot; property
(the declared name of the method) will be added to all copied
functions to help identify them for the internal machinery. Be
very careful, while reusing methods: if you use the same
function under different names, it can produce errors in some
cases.

&lt;/p>
&lt;p>It is possible to use constructors created &amp;quot;manually&amp;quot; (without
declare()) as bases. They will be called as usual during the
creation of an instance, their methods will be chained, and even
called by &amp;quot;this.inherited()&amp;quot;.

&lt;/p>
&lt;p>Special property &amp;quot;-chains-&amp;quot; governs how to chain methods. It is
a dictionary, which uses method names as keys, and hint strings
as values. If a hint string is &amp;quot;after&amp;quot;, this method will be
called after methods of its base classes. If a hint string is
&amp;quot;before&amp;quot;, this method will be called before methods of its base
classes.

&lt;/p>
&lt;p>If &amp;quot;constructor&amp;quot; is not mentioned in &amp;quot;-chains-&amp;quot; property, it will
be chained using the legacy mode: using &amp;quot;after&amp;quot; chaining,
calling preamble() method before each constructor, if available,
and calling postscript() after all constructors were executed.
If the hint is &amp;quot;after&amp;quot;, it is chained as a regular method, but
postscript() will be called after the chain of constructors.
&amp;quot;constructor&amp;quot; cannot be chained &amp;quot;before&amp;quot;, but it allows
a special hint string: &amp;quot;manual&amp;quot;, which means that constructors
are not going to be chained in any way, and programmer will call
them manually using this.inherited(). In the latter case
postscript() will be called after the construction.

&lt;/p>
&lt;p>All chaining hints are &amp;quot;inherited&amp;quot; from base classes and
potentially can be overridden. Be very careful when overriding
hints! Make sure that all chained methods can work in a proposed
manner of chaining.

&lt;/p>
&lt;p>Once a method was chained, it is impossible to unchain it. The
only exception is &amp;quot;constructor&amp;quot;. You don&amp;#39;t need to define a
method in order to supply a chaining hint.

&lt;/p>
&lt;p>If a method is chained, it cannot use this.inherited() because
all other methods in the hierarchy will be called automatically.

&lt;/p>
&lt;p>Usually constructors and initializers of any kind are chained
using &amp;quot;after&amp;quot; and destructors of any kind are chained as
&amp;quot;before&amp;quot;. Note that chaining assumes that chained methods do not
return any value: any returned value will be discarded.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  declare(&amp;quot;my.classes.bar&amp;quot;, my.classes.foo, {
    // properties to be added to the class prototype
    someValue: 2,
    // initialization function
    constructor: function(){
      this.myComplicatedObject = new ReallyComplicatedObject();
    },
    // other functions
    someMethod: function(){
      doStuff();
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var MyBase = declare(null, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass1 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyClass2 = declare(MyBase, {
    // constructor, properties, and methods go here
    // ...
  });
  var MyDiamond = declare([MyClass1, MyClass2], {
    // constructor, properties, and methods go here
    // ...
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var F = function(){ console.log(&amp;quot;raw constructor&amp;quot;); };
  F.prototype.method = function(){
    console.log(&amp;quot;raw method&amp;quot;);
  };
  var A = declare(F, {
    constructor: function(){
      console.log(&amp;quot;A.constructor&amp;quot;);
    },
    method: function(){
      console.log(&amp;quot;before calling F.method...&amp;quot;);
      this.inherited(arguments);
      console.log(&amp;quot;...back in A&amp;quot;);
    }
  });
  new A().method();
  // will print:
  // raw constructor
  // A.constructor
  // before calling F.method...
  // raw method
  // ...back in A&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      destroy: &amp;quot;before&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      console.log(&amp;quot;B.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;B.destroy&amp;quot;);
    }
  });
  var C = declare(B, {
    constructor: function(){
      console.log(&amp;quot;C.constructor&amp;quot;);
    },
    destroy: function(){
      console.log(&amp;quot;C.destroy&amp;quot;);
    }
  });
  new C().destroy();
  // prints:
  // B.constructor
  // C.constructor
  // C.destroy
  // B.destroy&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      constructor: &amp;quot;manual&amp;quot;
    }
  });
  var B = declare(A, {
    constructor: function(){
      // ...
      // call the base constructor with new parameters
      this.inherited(arguments, [1, 2, 3]);
      // ...
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  var A = declare(null, {
    &amp;quot;-chains-&amp;quot;: {
      m1: &amp;quot;before&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;A.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;A.m2&amp;quot;);
    }
  });
  var B = declare(A, {
    &amp;quot;-chains-&amp;quot;: {
      m2: &amp;quot;after&amp;quot;
    },
    m1: function(){
      console.log(&amp;quot;B.m1&amp;quot;);
    },
    m2: function(){
      console.log(&amp;quot;B.m2&amp;quot;);
    }
  });
  var x = new B();
  x.m1();
  // prints:
  // B.m1
  // A.m1
  x.m2();
  // prints:
  // A.m2
  // B.m2&lt;/code>&lt;/pre>
</example></examples></method><method name="Color" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="Array|String|Object" usage="required"/></parameters><return-types/><summary>&lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and creates a new Color instance to work from.
&lt;/p>
</summary><examples><example>&lt;p>Work with a Color instance:&lt;/p>
&lt;pre>&lt;code> var c = new Color();
 c.setColor([0,0,0]); // black
 var hex = c.toHex(); // #000000&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Work with a node&amp;#39;s color:&lt;/p>
&lt;pre>&lt;code> var color = dojo.style(&amp;quot;someNode&amp;quot;, &amp;quot;backgroundColor&amp;quot;);
 var n = new Color(color);
 // adjust the color some
 n.r *= .5;
 console.log(n.toString()); // rgb(128, 255, 255);&lt;/code>&lt;/pre>
</example></examples></method><method name="blendColors" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="start" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="end" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="weight" type="Number" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>
</summary></method><method name="colorFromRgb" scope="normal" type="function" from="dojo/colors"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="dojo/_base/Color" usage="optional"/></parameters><return-types/><summary>&lt;p>get rgb(a) array from css-style color declarations&lt;/p>
</summary><description>&lt;p>this function can handle all 4 CSS3 Color Module formats: rgb,
rgba, hsl, hsla, including rgb(a) with percentage values.&lt;/p>
</description></method><method name="colorFromHex" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="color" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.
</return-description><summary>&lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#ededed&amp;quot;); // grey, longhand&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code> var thing = dojo.colorFromHex(&amp;quot;#000&amp;quot;); // black, shorthand&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromArray" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="a" type="Array" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha&lt;/code>&lt;/pre>
</example></examples></method><method name="colorFromString" scope="normal" type="function" from="dojo/_base/Color"><parameters><parameter name="str" type="String" usage="required"/><parameter name="obj" type="Object" usage="optional"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>r&lt;/li>
&lt;li>g&lt;/li>
&lt;li>b&lt;/li>
&lt;li>a&lt;/li>
&lt;li>_set&lt;/li>
&lt;li>&lt;p>setColor: &lt;p>Takes a named string, hex string, array of rgb or rgba values,
an object with r, g, b, and a properties, or another &lt;code>Color&lt;/code> object
and sets this color instance to that value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sanitize: &lt;p>Ensures the object has correct attributes&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgb: &lt;p>Returns 3 component array of rgb values&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toRgba: &lt;p>Returns a 4 component array of rgba values from the color
represented by this object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toHex: &lt;p>Returns a CSS color string in hexadecimal representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toCss: &lt;p>Returns a css color string in rgb(a) representation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>toString: &lt;p>Returns a visual representation of the color&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>named: &lt;p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>blendColors: &lt;p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
can reuse a previously allocated Color object for the result&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromRgb: &lt;p>Returns a &lt;code>Color&lt;/code> instance from a string of the form
&amp;quot;rgb(...)&amp;quot; or &amp;quot;rgba(...)&amp;quot;. Optionally accepts a &lt;code>Color&lt;/code>
object to update with the parsed value and return instead of
creating a new object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromHex: &lt;p>Converts a hex string with a &amp;#39;#&amp;#39; prefix to a color object.
Supports 12-bit #rgb shorthand. Optionally accepts a
&lt;code>Color&lt;/code> object to update with the parsed value.
&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromArray: &lt;p>Builds a &lt;code>Color&lt;/code> from a 3 or 4 element array, mapping each
element in sequence to the rgb(a) values of the color.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>A Color object. If obj is passed, it will be the return value.</return-description><summary>&lt;p>Parses &lt;code>str&lt;/code> for a color value. Accepts hex, rgb, and rgba
style color values.&lt;/p>
</summary><description>&lt;p>Acceptable input values for str may include arrays of any form
accepted by dojo.colorFromArray, hex strings such as &amp;quot;#aaaaaa&amp;quot;, or
rgb or rgba strings such as &amp;quot;rgb(133, 200, 16)&amp;quot; or &amp;quot;rgba(10, 10,
10, 50)&amp;quot;&lt;/p>
</description></method><method name="_Line" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="start" type="int" usage="required"><summary>&lt;p>Beginning value for range&lt;/p>
</summary></parameter><parameter name="end" type="int" usage="required"><summary>&lt;p>Ending value for range&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Object used to generate values from a start value to an end value&lt;/p>
</summary></method><method name="Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="_fade" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Returns an animation that will fade the node defined by
args.node from the start to end values passed (args.start
args.end) (end is mandatory, start is optional)&lt;/p>
</summary></method><method name="fadeIn" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to show the node&lt;/p>
</summary></method><method name="fadeOut" scope="normal" type="Function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The function that returns the &lt;code>dojo.Animation&lt;/code> to hide the node&lt;/p>
</summary></method><method name="_defaultEasing" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="n" type="Decimal" usage="optional"/></parameters><return-types/><summary>&lt;p>The default easing function for Animation(s)&lt;/p>
</summary></method><method name="animateProperty" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>properties (Object, optional): &lt;p>A hash map of style properties to Objects describing the transition,
such as the properties of _Line with an additional &amp;#39;units&amp;#39; property&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>node (DOMNode|String): &lt;p>The node referenced in the animation&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>duration (Integer, optional): &lt;p>Duration of the animation in milliseconds.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>easing (Function, optional): &lt;p>An easing function.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns an animation that will transition the properties of
node defined in &lt;code>args&lt;/code> depending how they are defined in
&lt;code>args.properties&lt;/code>
&lt;/p>
</summary><description>&lt;p>Foundation of most &lt;code>dojo/_base/fx&lt;/code>
animations. It takes an object of &amp;quot;properties&amp;quot; corresponding to
style properties, and animates them in parallel over a set
duration.
&lt;/p>
</description><examples><example>&lt;p>A simple animation that changes the width of the specified node.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    properties: { width: 400 },
  }).play();&lt;/code>&lt;/pre>
&lt;p>Dojo figures out the start value for the width and converts the
integer specified for the width to the more expressive but
verbose form &lt;code>{ width: { end: &amp;#39;400&amp;#39;, units: &amp;#39;px&amp;#39; } }&lt;/code> which you
can also specify directly. Defaults to &amp;#39;px&amp;#39; if omitted.
&lt;/p>
</example><example>&lt;p>Animate width, height, and padding over 2 seconds... the
pedantic way:&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({ node: node, duration:2000,
    properties: {
      width: { start: &amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      height: { start:&amp;#39;200&amp;#39;, end: &amp;#39;400&amp;#39;, units:&amp;quot;px&amp;quot; },
      paddingTop: { start:&amp;#39;5&amp;#39;, end:&amp;#39;50&amp;#39;, units:&amp;quot;px&amp;quot; }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>Note &amp;#39;paddingTop&amp;#39; is used over &amp;#39;padding-top&amp;#39;. Multi-name CSS properties
are written using &amp;quot;mixed case&amp;quot;, as the hyphen is illegal as an object key.
&lt;/p>
</example><example>&lt;p>Plug in a different easing function and register a callback for
when the animation ends. Easing functions accept values between
zero and one and return a value on that basis. In this case, an
exponential-in curve.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node: &amp;quot;nodeId&amp;quot;,
    // dojo figures out the start value
    properties: { width: { end: 400 } },
    easing: function(n){
      return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
    },
    onEnd: function(node){
      // called when the animation finishes. The animation
      // target is passed to this function
    }
  }).play(500); // delay playing half a second&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Like all &lt;code>Animation&lt;/code>s, animateProperty returns a handle to the
Animation instance, which fires the events common to Dojo FX. Use &lt;code>aspect.after&lt;/code>
to access these events outside of the Animation definition:&lt;/p>
&lt;pre>&lt;code>  var anim = basefx.animateProperty({
    node:&amp;quot;someId&amp;quot;,
    properties:{
      width:400, height:500
    }
  });
  aspect.after(anim, &amp;quot;onEnd&amp;quot;, function(){
    console.log(&amp;quot;animation ended&amp;quot;);
  }, true);
  // play the animation now:
  anim.play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Each property can be a function whose return value is substituted along.
Additionally, each measurement (eg: start, end) can be a function. The node
reference is passed directly to callbacks.&lt;/p>
&lt;pre>&lt;code>  basefx.animateProperty({
    node:&amp;quot;mine&amp;quot;,
    properties:{
      height:function(node){
        // shrink this node by 50%
        return domGeom.position(node).h / 2
      },
      width:{
        start:function(node){ return 100; },
        end:function(node){ return 200; }
      }
    }
  }).play();&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="anim" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>a DOM node or the id of a node to animate CSS properties on&lt;/p>
</summary></parameter><parameter name="properties" type="Object" usage="required"/><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds over which the animation
should run. Defaults to the global animation default duration
(350ms).&lt;/p>
</summary></parameter><parameter name="easing" type="Function" usage="optional"><summary>&lt;p>An easing function over which to calculate acceleration
and deceleration of the animation through its duration.
A default easing algorithm is provided, but you may
plug in any you wish. A large selection of easing algorithms
are available in &lt;code>dojo/fx/easing&lt;/code>.&lt;/p>
</summary></parameter><parameter name="onEnd" type="Function" usage="optional"><summary>&lt;p>A function to be called when the animation finishes
running.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>The number of milliseconds to delay beginning the
animation by. The default is 0.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A simpler interface to &lt;code>animateProperty()&lt;/code>, also returns
an instance of &lt;code>Animation&lt;/code> but begins the animation
immediately, unlike nearly every other Dojo animation API.&lt;/p>
</summary><description>&lt;p>Simpler (but somewhat less powerful) version
of &lt;code>animateProperty&lt;/code>.  It uses defaults for many basic properties
and allows for positional parameters to be used in place of the
packed &amp;quot;property bag&amp;quot; which is used for other Dojo animation
methods.

&lt;/p>
&lt;p>The &lt;code>Animation&lt;/code> object returned will be already playing, so
calling play() on it again is (usually) a no-op.&lt;/p>
</description><examples><example>&lt;p>Fade out a node&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 });&lt;/code>&lt;/pre>
</example><example>&lt;p>Fade out a node over a full second&lt;/p>
&lt;pre>&lt;code>  basefx.anim(&amp;quot;id&amp;quot;, { opacity: 0 }, 1000);&lt;/code>&lt;/pre>
</example></examples></method><method name="_Animation" scope="normal" type="function" from="dojo/_base/fx"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>The &amp;#39;magic argument&amp;#39;, mixing all the properties into this
animation instance.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states.&lt;/p>
</summary><description>&lt;p>A generic animation class that fires callbacks into its handlers
object at various states. Nearly all dojo animation functions
return an instance of this method, usually without calling the
.play() method beforehand. Therefore, you will likely need to
call .play() on instances of &lt;code>Animation&lt;/code> when one is
returned.&lt;/p>
</description></method><method name="addOnLoad" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="ready" scope="normal" type="function" from="dojo/ready"><parameters><parameter name="priority" type="Integer" usage="optional"><summary>&lt;p>The order in which to exec this callback relative to other callbacks, defaults to 1000&lt;/p>
</summary></parameter><parameter name="context" type="undefined" usage="required"><summary>&lt;p>The context in which to run execute callback, or a callback if not using context&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The function to execute.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
In most cases, the &lt;code>domReady&lt;/code> plug-in should suffice and this method should not be needed.&lt;/p>
</summary><examples><example>&lt;p>Simple DOM and Modules ready syntax&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(function(){ alert(&amp;quot;Dom ready!&amp;quot;); });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using a priority&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(2, function(){ alert(&amp;quot;low priority ready!&amp;quot;); })
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using context&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    ready(foo, function(){
      // in here, this == foo
    });
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Using dojo/hitch style args:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/ready&amp;quot;], function(ready){
    var foo = { dojoReady: function(){ console.warn(this, &amp;quot;dojo dom and modules ready.&amp;quot;); } };
    ready(foo, &amp;quot;dojoReady&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="byId" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="id" type="String|DOMNode" usage="required"><summary>&lt;p>A string to match an HTML id attribute or a reference to a DOM Node
&lt;/p>
</summary></parameter><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Document to work in. Defaults to the current value of
dojo.doc.  Can be used to retrieve
node references from other documents.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Returns DOM node with matching &lt;code>id&lt;/code> attribute or falsy value (ex: null or undefined)
if not found.  If &lt;code>id&lt;/code> is a DomNode, this function is a no-op.
&lt;/p>
</summary><examples><example>&lt;p>Look up a node by ID:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Check if a node exists, and use it.&lt;/p>
&lt;pre>&lt;code>  var n = dojo.byId(&amp;quot;bar&amp;quot;);
  if(n){ doStuff() ... }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Allow string or DomNode references to be passed to a custom function:&lt;/p>
&lt;pre>&lt;code>  var foo = function(nodeOrId){
    nodeOrId = dojo.byId(nodeOrId);
    // ... more stuff
  }&lt;/code>&lt;/pre>
</example></examples></method><method name="isDescendant" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference to test&lt;/p>
</summary></parameter><parameter name="ancestor" type="DOMNode|String" usage="required"><summary>&lt;p>string id or node reference of potential parent to test against
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns true if node is a descendant of ancestor&lt;/p>
</summary><examples><example>&lt;p>Test is node id=&amp;quot;bar&amp;quot; is a descendant of node id=&amp;quot;foo&amp;quot;&lt;/p>
&lt;pre>&lt;code>  if(dojo.isDescendant(&amp;quot;bar&amp;quot;, &amp;quot;foo&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="setSelectable" scope="normal" type="function" from="dojo/dom"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="selectable" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/><return-type type="null"/></return-types><return-description>the value of the requested attribute or null if that attribute does not have a specified or
default value;
</return-description><summary>&lt;p>Gets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of attributes on DOM Nodes.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.getAttr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to set, or a hash of key-value pairs to set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>the value to set for the attribute, if the name is a string.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of attributes on DOM Nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.setAttr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setAttr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setAttr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.setStyle(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to check&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>true if the requested attribute is specified on the
given element, and false otherwise</return-description><summary>&lt;p>Returns true if the requested attribute is specified on the
given element, and false otherwise.&lt;/p>
</summary></method><method name="removeAttr" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute to remove&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes an attribute from an HTML element.&lt;/p>
</summary></method><method name="getNodeProp" scope="normal" type="function" from="dojo/dom-attr"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to remove the attribute from&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the attribute</return-description><summary>&lt;p>Returns an effective value of a property or an attribute.&lt;/p>
</summary></method><method name="attr" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the attribute on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the attribute to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the attribute&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested attribute
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets an attribute on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of attributes on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; attribute on a node
  dojo.attr(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use attr() to set the tab index
  dojo.attr(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.attr(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.attr(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="hasClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to check the class for.&lt;/p>
</summary></parameter><parameter name="classStr" type="String" usage="required"><summary>&lt;p>A string class name to look for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Returns whether or not the specified classes are a portion of the
class list currently applied to the node.&lt;/p>
</summary><examples><example>&lt;p>Do something if a node with id=&amp;quot;someNode&amp;quot; has class=&amp;quot;aSillyClassName&amp;quot; present&lt;/p>
&lt;pre>&lt;code>  if(dojo.hasClass(&amp;quot;someNode&amp;quot;,&amp;quot;aSillyClassName&amp;quot;)){ ... }&lt;/code>&lt;/pre>
</example></examples></method><method name="addClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to add a class string too
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds the specified classes to the end of the class list on the
passed node. Will not re-apply duplicate classes.
&lt;/p>
</summary><examples><example>&lt;p>Add a class to some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;anewClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Add two classes at once (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.add(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple additions&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).addClass(&amp;quot;firstLevel&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="removeClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="optional"><summary>&lt;p>An optional String class name to remove, or several space-separated
class names, or an array of class names. If omitted, all class names
will be deleted.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Removes the specified classes from node. No &lt;code>contains()&lt;/code>
check is required.
&lt;/p>
</summary><examples><example>&lt;p>Remove a class from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, &amp;quot;firstClass secondClass&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove two classes from some node (using array):&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;, [&amp;quot;firstClass&amp;quot;, &amp;quot;secondClass&amp;quot;]);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Remove all classes from some node:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.remove(&amp;quot;someNode&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple removal&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;ul &amp;gt; li&amp;quot;).removeClass(&amp;quot;foo&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toggleClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to toggle a class string
&lt;/p>
</summary></parameter><parameter name="classStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to toggle, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="condition" type="Boolean" usage="optional"><summary>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/></return-types><return-description>&lt;p>If passed, true means to add the class, false means to remove.
Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
&lt;/p>
</return-description><summary>&lt;p>Adds a class to node if not present, or removes if present.
Pass a boolean condition if you want to explicitly add or remove.
Returns the condition that was specified directly or indirectly.
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Forcefully add a class&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.toggle(&amp;quot;someNode&amp;quot;, &amp;quot;hovered&amp;quot;, true);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.toggleMe&amp;quot;).toggleClass(&amp;quot;toggleMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="replaceClass" scope="normal" type="function" from="dojo/dom-class"><parameters><parameter name="node" type="String|DOMNode" usage="required"><summary>&lt;p>String ID or DomNode reference to remove the class from.
&lt;/p>
</summary></parameter><parameter name="addClassStr" type="String|Array" usage="required"><summary>&lt;p>A String class name to add, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter><parameter name="removeClassStr" type="String|Array" usage="optional"><summary>&lt;p>A String class name to remove, or several space-separated class names,
or an array of class names.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Replaces one or more classes on a node if not present.
Operates more quickly than calling dojo.removeClass and dojo.addClass
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;add1 add2&amp;quot;, &amp;quot;remove1 remove2&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Replace all classes with addMe&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/dom-class&amp;quot;], function(domClass){
    domClass.replace(&amp;quot;someNode&amp;quot;, &amp;quot;addMe&amp;quot;);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Available in &lt;code>dojo/NodeList&lt;/code> for multiple toggles&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/query&amp;quot;], function(query){
    query(&amp;quot;.findMe&amp;quot;).replaceClass(&amp;quot;addMe&amp;quot;, &amp;quot;removeMe&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="_toDom" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="frag" type="String" usage="required"><summary>&lt;p>the HTML fragment&lt;/p>
</summary></parameter><parameter name="doc" type="DocumentNode" usage="optional"><summary>&lt;p>optional document to use when creating DOM nodes, defaults to
dojo.doc if not specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>Document fragment, unless it's a single node in which case it returns the node itself</return-description><summary>&lt;p>instantiates an HTML fragment returning the corresponding DOM.&lt;/p>
</summary><examples><example>&lt;p>Create a table row:&lt;/p>
&lt;pre>&lt;code>  var tr = dojo.toDom(&amp;quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;First!&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="place" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="required"><summary>&lt;p>id or node reference to use as basis for placement&lt;/p>
</summary></parameter><parameter name="position" type="String|Number" usage="optional"><summary>&lt;p>string noting the position of node relative to refNode or a
number indicating the location in the childNodes collection of refNode.
Accepted string values are:

&lt;/p>
&lt;ul>
&lt;li>before&lt;/li>
&lt;li>after&lt;/li>
&lt;li>replace&lt;/li>
&lt;li>only&lt;/li>
&lt;li>first&lt;/li>
&lt;li>last&lt;/li>
&lt;/ul>
&lt;p>&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified&lt;/p>
</summary></parameter></parameters><return-types><return-type type="DOMNode"/><return-type type="undefined"/></return-types><return-description>Returned values is the first argument resolved to a DOM node.

.place() is also a method of `dojo/NodeList`, allowing `dojo.query` node lookups.</return-description><summary>&lt;p>Attempt to insert node into the DOM, choosing from various positioning options.
Returns the first argument resolved to a DOM node.&lt;/p>
</summary><examples><example>&lt;p>Place a node by string id as the last child of another node by string id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Place a node by string id before another node by string id&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;someNode&amp;quot;, &amp;quot;anotherNode&amp;quot;, &amp;quot;before&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Create a Node, and place it in the body element (last child):&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;quot;, dojo.body());&lt;/code>&lt;/pre>
</example><example>&lt;p>Put a new LI as the first child of a list by id:&lt;/p>
&lt;pre>&lt;code>  dojo.place(&amp;quot;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;, &amp;quot;someUl&amp;quot;, &amp;quot;first&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="create" scope="normal" type="function" from="dojo/dom-construct"><parameters><parameter name="tag" type="DOMNode|String" usage="required"><summary>&lt;p>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
or an existing DOM node to process.&lt;/p>
</summary></parameter><parameter name="attrs" type="Object" usage="required"><summary>&lt;p>An object-hash of attributes to set on the newly created node.
Can be null, if you don&amp;#39;t want to set any attributes/styles.
See: &lt;code>dojo.setAttr&lt;/code> for a description of available attributes.&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode|String" usage="optional"><summary>&lt;p>Optional reference node. Used by &lt;code>dojo.place&lt;/code> to place the newly created
node somewhere in the dom relative to refNode. Can be a DomNode reference
or String ID of a node.&lt;/p>
</summary></parameter><parameter name="pos" type="String" usage="optional"><summary>&lt;p>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code>dojo.place&lt;/code>,
though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
to further control the placement of the new node relative to the refNode.
&amp;#39;refNode&amp;#39; is required if a &amp;#39;pos&amp;#39; is specified.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create an element, allowing for optional attribute decoration
and placement.&lt;/p>
</summary><description>&lt;p>A DOM Element creation function. A shorthand method for creating a node or
a fragment, and allowing for a convenient optional attribute setting step,
as well as an optional DOM placement reference.

&lt;/p>
&lt;p>Attributes are set by passing the optional object through &lt;code>dojo.setAttr&lt;/code>.
See &lt;code>dojo.setAttr&lt;/code> for noted caveats and nuances, and API if applicable.

&lt;/p>
&lt;p>Placement is done via &lt;code>dojo.place&lt;/code>, assuming the new node to be the action
node, passing along the optional reference node and position.&lt;/p>
</description><examples><example>&lt;p>Create a DIV:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a DIV with content:&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, { innerHTML:&amp;quot;&amp;lt;p&amp;gt;hi&amp;lt;/p&amp;gt;&amp;quot; });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Place a new DIV in the BODY, with no attributes set&lt;/p>
&lt;pre>&lt;code>  var n = dojo.create(&amp;quot;div&amp;quot;, null, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an UL, and populate it with LI&amp;#39;s. Place the list as the first-child of a
node with id=&amp;quot;someId&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  var ul = dojo.create(&amp;quot;ul&amp;quot;, null, &amp;quot;someId&amp;quot;, &amp;quot;first&amp;quot;);
  var items = [&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;];
  dojo.forEach(items, function(data){
    dojo.create(&amp;quot;li&amp;quot;, { innerHTML: data }, ul);
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create an anchor, with an href. Place in BODY:&lt;/p>
&lt;pre>&lt;code>  dojo.create(&amp;quot;a&amp;quot;, { href:&amp;quot;foo.html&amp;quot;, title:&amp;quot;Goto FOO!&amp;quot; }, dojo.body());&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Create a &lt;code>dojo/NodeList()&lt;/code> from a new element (for syntactic sugar):&lt;/p>
&lt;pre>&lt;code>  dojo.query(dojo.create(&amp;#39;div&amp;#39;))
    .addClass(&amp;quot;newDiv&amp;quot;)
    .onclick(function(e){ console.log(&amp;#39;clicked&amp;#39;, e.target) })
    .place(&amp;quot;#someNode&amp;quot;); // redundant, but cleaner.&lt;/code>&lt;/pre>
</example></examples></method><method name="empty" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="destroy" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="_destroyElement" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="undefined" usage="required"/></parameters><return-types/></method><method name="getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with special values specifically useful for node
fitting.&lt;/p>
</summary><description>&lt;p>Returns an object with &lt;code>w&lt;/code>, &lt;code>h&lt;/code>, &lt;code>l&lt;/code>, &lt;code>t&lt;/code> properties:&lt;/p>
&lt;pre>&lt;code>    l/t/r/b = left/top/right/bottom padding (respectively)
    w = the total of the left and right padding
    h = the total of the top and bottom padding&lt;/code>&lt;/pre>
&lt;p>If &amp;#39;node&amp;#39; has position, l/t forms the origin for child nodes.
The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object with properties useful for noting the border
dimensions.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right border&lt;/li>
&lt;li>h = the sum of the top and bottom border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="_getPadBorderExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns object with properties useful for box fitting with
regards to padding.&lt;/p>
</summary><description>&lt;ul>
&lt;li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)&lt;/li>
&lt;li>w = the sum of the left and right padding and border&lt;/li>
&lt;li>h = the sum of the top and bottom padding and border&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</description></method><method name="getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="_getMarginExtents" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns object with properties useful for box fitting with
regards to box margins (i.e., the outer-box).

&lt;/p>
&lt;ul>
&lt;li>l/t = marginLeft, marginTop, respectively&lt;/li>
&lt;li>w = total width, margin inclusive&lt;/li>
&lt;li>h = total height, margin inclusive&lt;/li>
&lt;/ul>
&lt;p>The w/h are used for calculating boxes.
Normally application code will not need to invoke this
directly, and will use the ...box... functions instead.&lt;/p>
</summary></method><method name="getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="_getMarginSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width and height of
the node&amp;#39;s margin box&lt;/p>
</summary></method><method name="getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="_getMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s margin box.&lt;/p>
</summary></method><method name="setMarginBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;l&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>sets the size of the node&amp;#39;s margin box and placement
(left/top), irrespective of box model. Think of it as a
passthrough to setBox that handles box-model vagaries for
you.&lt;/p>
</summary></method><method name="getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="_getContentBox" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Returns an object that encodes the width, height, left and top
positions of the node&amp;#39;s content box, irrespective of the
current box model.&lt;/p>
</summary></method><method name="setContentSize" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="box" type="Object" usage="required"><summary>&lt;p>hash with optional &amp;quot;w&amp;quot;, and &amp;quot;h&amp;quot; properties for &amp;quot;width&amp;quot;, and &amp;quot;height&amp;quot;
respectively. All specified properties should have numeric values in whole pixels.&lt;/p>
</summary></parameter><parameter name="computedStyle" type="Object" usage="optional"><summary>&lt;p>This parameter accepts computed styles object.
If this parameter is omitted, the functions will call
dojo.getComputedStyle to get one. It is a better way, calling
dojo.computedStyle once, and then pass the reference to this
computedStyle parameter. Wherever possible, reuse the returned
object of dojo/dom-style.getComputedStyle().&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the size of the node&amp;#39;s contents, irrespective of margins,
padding, or borders.&lt;/p>
</summary></method><method name="isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="_isBodyLtr" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><summary>&lt;p>Returns true if the current language is left-to-right, and false otherwise.&lt;/p>
</summary></method><method name="docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="_docScroll" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object with {node, x, y} with corresponding offsets.&lt;/p>
</summary></method><method name="getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="_getIeDocumentElementOffset" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>returns the offset in x and y from the document body to the
visual edge of the page for IE&lt;/p>
</summary><description>&lt;p>The following values in IE contain an offset:&lt;/p>
&lt;pre>&lt;code>    event.clientX
    event.clientY
    node.getBoundingClientRect().left
    node.getBoundingClientRect().top&lt;/code>&lt;/pre>
&lt;p>But other position related values do not contain this offset,
such as node.offsetLeft, node.offsetTop, node.style.left and
node.style.top. The offset is always (2, 2) in LTR direction.
When the body is in RTL direction, the offset counts the width
of left scroll bar&amp;#39;s width.  This function computes the actual
offset.&lt;/p>
</description></method><method name="fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="_fixIeBiDiScrollLeft" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="scrollLeft" type="Number" usage="required"/><parameter name="doc" type="Document" usage="optional"><summary>&lt;p>Optional document to query.   If unspecified, use win.doc.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="number"/></return-types><summary>&lt;p>In RTL direction, scrollLeft should be a negative value, but IE
returns a positive one. All codes using documentElement.scrollLeft
must call this function to fix this error, otherwise the position
will offset to right when there is a horizontal scrollbar.&lt;/p>
</summary></method><method name="position" scope="normal" type="function" from="dojo/dom-geometry"><parameters><parameter name="node" type="DOMNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Object"/><return-type type="object"/></return-types><summary>&lt;p>Gets the position and size of the passed element relative to
the viewport (if includeScroll==false), or relative to the
document root (if includeScroll==true).
&lt;/p>
</summary><description>&lt;p>Returns an object of the form:
&lt;code>{ x: 100, y: 300, w: 20, h: 15 }&lt;/code>.
If includeScroll==true, the x and y values will include any
document offsets that may affect the position relative to the
viewport.
Uses the border-box model (inclusive of border and padding but
not margin).  Does not act as a setter.&lt;/p>
</description></method><method name="marginBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.marginBox() should
update/set the margin box for node. Box is an object in the
above format. All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the margin-box of node.&lt;/p>
</summary><description>&lt;p>Getter/setter for the margin-box of node.
Returns an object in the expected format of box (regardless
if box is passed). The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a margin width of 300px and a margin-height of
150px.&lt;/p>
</description><examples><example>&lt;p>Retrieve the margin box of a passed node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  console.dir(box);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set a node&amp;#39;s margin box to the size of another node&lt;/p>
&lt;pre>&lt;code>  var box = dojo.marginBox(&amp;quot;someNodeId&amp;quot;);
  dojo.marginBox(&amp;quot;someOtherNode&amp;quot;, box);&lt;/code>&lt;/pre>
</example></examples></method><method name="contentBox" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to DOM Node to get/set box for&lt;/p>
</summary></parameter><parameter name="box" type="Object" usage="optional"><summary>&lt;p>If passed, denotes that dojo.contentBox() should
update/set the content box for node. Box is an object in the
above format, but only w (width) and h (height) are supported.
All properties are optional if passed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Getter/setter for the content-box of node.&lt;/p>
</summary><description>&lt;p>Returns an object in the expected format of box (regardless if box is passed).
The object might look like:
&lt;code>{ l: 50, t: 200, w: 300: h: 150 }&lt;/code>
for a node offset from its parent 50px to the left, 200px from
the top with a content width of 300px and a content-height of
150px. Note that the content box may have a much larger border
or margin box, depending on the box model currently in use and
CSS values set/inherited for node.
While the getter will return top and left values, the
setter only accepts setting the width and height.&lt;/p>
</description></method><method name="coords" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"/><parameter name="includeScroll" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>Deprecated: Use position() for border-box x/y/w/h
or marginBox() for margin-box w/h/l/t.

&lt;/p>
&lt;p>Returns an object that measures margin-box (w)idth/(h)eight
and absolute position x/y of the border-box. Also returned
is computed (l)eft and (t)op values in pixels from the
node&amp;#39;s offsetParent as returned from marginBox().
Return value will be in the form:&lt;/p>
&lt;pre>&lt;code>      { l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }&lt;/code>&lt;/pre>
&lt;p>Does not act as a setter. If includeScroll is passed, the x and
y params are affected as one would expect in dojo.position().&lt;/p>
</summary></method><method name="getProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to get the property on&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="required"><summary>&lt;p>the name of the property to get.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the value of the requested property or its default value
</return-description><summary>&lt;p>Gets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting of properties on DOM nodes.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.getProp(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.getProp(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="setProp" scope="normal" type="function" from="dojo/dom-prop"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to the element to set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to set, or a hash object to set
multiple properties at once.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>the DOM node
</return-description><summary>&lt;p>Sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized setting of properties on DOM nodes.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.setProp(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.setProp(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.setProp(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="prop" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DomNode|String" usage="required"><summary>&lt;p>id or reference to the element to get or set the property on&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the name of the property to get or set.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>The value to set for the property&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, the value of the requested property
or null if that attribute does not have a specified or
default value;

when used as a setter, the DOM node
</return-description><summary>&lt;p>Gets or sets a property on an HTML element.&lt;/p>
</summary><description>&lt;p>Handles normalized getting and setting of properties on DOM
Nodes. If 2 arguments are passed, and a the second argument is a
string, acts as a getter.

&lt;/p>
&lt;p>If a third argument is passed, or if the second argument is a
map of attributes, acts as a setter.

&lt;/p>
&lt;p>When passing functions as values, note that they will not be
directly assigned to slots on the node, but rather the default
behavior will be removed and the new behavior will be added
using &lt;code>dojo.connect()&lt;/code>, meaning that event handler properties
will be normalized and that some caveats with regards to
non-standard behaviors for onsubmit apply. Namely that you
should cancel form submission using &lt;code>dojo.stopEvent()&lt;/code> on the
passed event object instead of returning a boolean value from
the handler itself.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  // get the current value of the &amp;quot;foo&amp;quot; property on a node
  dojo.prop(dojo.byId(&amp;quot;nodeId&amp;quot;), &amp;quot;foo&amp;quot;);
  // or we can just pass the id:
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;pre>&lt;code>  // use prop() to set the tab index
  dojo.prop(&amp;quot;nodeId&amp;quot;, &amp;quot;tabIndex&amp;quot;, 3);
&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Set multiple values at once, including event handlers:&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;formId&amp;quot;, {
    &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;,
    &amp;quot;tabIndex&amp;quot;: -1,
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;onsubmit&amp;quot;: function(e){
      // stop submitting the form. Note that the IE behavior
      // of returning true or false will have no effect here
      // since our handler is connect()ed to the built-in
      // onsubmit behavior and so we need to use
      // dojo.stopEvent() to ensure that the submission
      // doesn&amp;#39;t proceed.
      dojo.stopEvent(e);

      // submit the form with Ajax
      dojo.xhrPost({ form: &amp;quot;formId&amp;quot; });
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Style is s special case: Only set with an object hash of styles&lt;/p>
&lt;pre>&lt;code>  dojo.prop(&amp;quot;someNode&amp;quot;,{
    id:&amp;quot;bar&amp;quot;,
    style:{
      width:&amp;quot;200px&amp;quot;, height:&amp;quot;100px&amp;quot;, color:&amp;quot;#000&amp;quot;
    }
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Again, only set style as an object hash of styles:&lt;/p>
&lt;pre>&lt;code>  var obj = { color:&amp;quot;#fff&amp;quot;, backgroundColor:&amp;quot;#000&amp;quot; };
  dojo.prop(&amp;quot;someNode&amp;quot;, &amp;quot;style&amp;quot;, obj);

  // though shorter to use `dojo.style()` in this case:
  dojo.style(&amp;quot;someNode&amp;quot;, obj);&lt;/code>&lt;/pre>
</example></examples></method><method name="getStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get style for&lt;/p>
</summary></parameter><parameter name="name" type="String" usage="optional"><summary>&lt;p>the style property to get&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Accesses styles on a node.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.getStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
</example></examples></method><method name="setStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="required"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><return-description>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.
&lt;/p>
</return-description><summary>&lt;p>Sets styles on a node.&lt;/p>
</summary><examples><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.setStyle(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo.query()&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="getComputedStyle" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"><summary>&lt;p>A reference to a DOM node. Does NOT support taking an
ID string for speed reasons.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &amp;quot;computed style&amp;quot; object.
&lt;/p>
</summary><description>&lt;p>Gets a &amp;quot;computed style&amp;quot; object which can be used to gather
information about the current state of the rendered node.

&lt;/p>
&lt;p>Note that this may behave differently on different browsers.
Values may have different formats and value encodings across
browsers.

&lt;/p>
&lt;p>Note also that this method is expensive.  Wherever possible,
reuse the returned object.

&lt;/p>
&lt;p>Use the dojo.style() method for more consistent (pixelized)
return values.
&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.getComputedStyle(dojo.byId(&amp;#39;foo&amp;#39;)).borderWidth;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Reusing the returned object, avoiding multiple lookups:&lt;/p>
&lt;pre>&lt;code>  var cs = dojo.getComputedStyle(dojo.byId(&amp;quot;someNode&amp;quot;));
  var w = cs.width, h = cs.height;&lt;/code>&lt;/pre>
</example></examples></method><method name="toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="__toPixelValue" scope="normal" type="function" from="dojo/dom-style"><parameters><parameter name="node" type="DOMNode" usage="required"/><parameter name="value" type="String" usage="required"/></parameters><return-types><return-type type="Number"/></return-types><summary>&lt;p>converts style value to pixels on IE or return a numeric value.&lt;/p>
</summary></method><method name="style" scope="normal" type="function" from="dojo/_base/html"><parameters><parameter name="node" type="DOMNode|String" usage="required"><summary>&lt;p>id or reference to node to get/set style for&lt;/p>
</summary></parameter><parameter name="name" type="String|Object" usage="optional"><summary>&lt;p>the style property to set in DOM-accessor format
(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
pairs suitable for setting each property.&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>If passed, sets value on the node for style, handling
cross-browser concerns.  When setting a pixel value,
be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
Otherwise, in some cases, some browsers will not apply the style.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>when used as a getter, return the computed style of the node if passing in an ID or node,
or return the normalized, computed value for the property when passing in a node and a style property</return-description><summary>&lt;p>Accesses styles on a node. If 2 arguments are
passed, acts as a getter. If 3 arguments are passed, acts
as a setter.&lt;/p>
</summary><description>&lt;p>Getting the style value uses the computed style for the node, so the value
will be a calculated value, not just the immediate node.style value.
Also when getting values, use specific style names,
like &amp;quot;borderBottomWidth&amp;quot; instead of &amp;quot;border&amp;quot; since compound values like
&amp;quot;border&amp;quot; are not necessarily reflected as expected.
If you want to get node dimensions, use &lt;code>dojo.marginBox()&lt;/code>,
&lt;code>dojo.contentBox()&lt;/code> or &lt;code>dojo.position()&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Passing only an ID or node returns the computed style object of
the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>Passing a node and a style property returns the current
normalized, computed value for that property:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;); // 1 by default&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, a style property, and a value changes the
current display of the node and returns the new computed value&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, &amp;quot;opacity&amp;quot;, 0.5); // == 0.5&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;, {
    &amp;quot;opacity&amp;quot;: 0.5,
    &amp;quot;border&amp;quot;: &amp;quot;3px solid black&amp;quot;,
    &amp;quot;height&amp;quot;: &amp;quot;300px&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>When the CSS style property is hyphenated, the JavaScript property is camelCased.
font-size becomes fontSize, and so on.&lt;/p>
&lt;pre>&lt;code>  dojo.style(&amp;quot;thinger&amp;quot;,{
    fontSize:&amp;quot;14pt&amp;quot;,
    letterSpacing:&amp;quot;1.2em&amp;quot;
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>dojo/NodeList implements .style() using the same syntax, omitting the &amp;quot;node&amp;quot; parameter, calling
dojo.style() on every element of the list. See: &lt;code>dojo/query&lt;/code> and &lt;code>dojo/NodeList&lt;/code>&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.someClassName&amp;quot;).style(&amp;quot;visibility&amp;quot;,&amp;quot;hidden&amp;quot;);
  // or
  dojo.query(&amp;quot;#baz &amp;gt; div&amp;quot;).style({
    opacity:0.75,
    fontSize:&amp;quot;13pt&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="_Url" scope="normal" type="function" from="dojo/_base/url"><parameters/><return-types/></method><method name="fromJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="js" type="String" usage="required"><summary>&lt;p>a string literal of a JavaScript expression, for instance:
&lt;code>&amp;#39;{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }&amp;#39;&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Parses a JavaScript expression and returns a JavaScript value.&lt;/p>
</summary><description>&lt;p>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
always delegates to eval(). The content passed to this method must therefore come
from a trusted source.
It is recommend that you use dojo/json&amp;#39;s parse function for an
implementation uses the (faster) native JSON parse when available.&lt;/p>
</description></method><method name="_escapeString" scope="normal" type="function" from="dojo/json"><parameters><parameter name="value" type="undefined" usage="required"><summary>&lt;p>A value to be serialized.&lt;/p>
</summary></parameter><parameter name="replacer" type="undefined" usage="required"><summary>&lt;p>A replacer function that is called for each value and can return a replacement&lt;/p>
</summary></parameter><parameter name="spacer" type="undefined" usage="required"><summary>&lt;p>A spacer string to be used for pretty printing of JSON&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
This function follows &lt;a href=&quot;https://developer.mozilla.org/en/JSON&quot;>native JSON API&lt;/a>
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  define([&amp;quot;dojo/json&amp;quot;], function(JSON){
    var jsonStr = JSON.stringify({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
    doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example></examples></method><method name="toJson" scope="normal" type="function" from="dojo/_base/json"><parameters><parameter name="it" type="Object" usage="required"><summary>&lt;p>an object to be serialized. Objects may define their own
serialization via a special &amp;quot;&lt;strong>json&lt;/strong>&amp;quot; or &amp;quot;json&amp;quot; function
property. If a specialized serializer has been defined, it will
be used as a fallback.
Note that in 1.6, toJson would serialize undefined, but this no longer supported
since it is not supported by native JSON serializer.&lt;/p>
</summary></parameter><parameter name="prettyPrint" type="Boolean" usage="optional"><summary>&lt;p>if true, we indent objects and arrays to make the output prettier.
The variable &lt;code>dojo.toJsonIndentStr&lt;/code> is used as the indent string --
to use something other than the default (tab), change that variable
before calling dojo.toJson().
Note that if native JSON support is available, it will be used for serialization,
and native implementations vary on the exact spacing used in pretty printing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A JSON string serialization of the passed-in object.</return-description><summary>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.&lt;/p>
</summary><description>&lt;p>Returns a &lt;a href=&quot;http://json.org&quot;>JSON&lt;/a> serialization of an object.
Note that this doesn&amp;#39;t check for infinite recursion, so don&amp;#39;t do that!
It is recommend that you use dojo/json&amp;#39;s stringify function for an lighter
and faster implementation that matches the native JSON API and uses the
native JSON serializer when available.&lt;/p>
</description><examples><example>&lt;p>simple serialization of a trivial object&lt;/p>
&lt;pre>&lt;code>  var jsonStr = dojo.toJson({ howdy: &amp;quot;stranger!&amp;quot;, isStrange: true });
  doh.is(&amp;#39;{&amp;quot;howdy&amp;quot;:&amp;quot;stranger!&amp;quot;,&amp;quot;isStrange&amp;quot;:true}&amp;#39;, jsonStr);&lt;/code>&lt;/pre>
</example><example>&lt;p>a custom serializer for an objects of a particular class:&lt;/p>
&lt;pre>&lt;code>  dojo.declare(&amp;quot;Furby&amp;quot;, null, {
    furbies: &amp;quot;are strange&amp;quot;,
    furbyCount: 10,
    __json__: function(){
    },
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="Stateful" scope="normal" type="constructor" from="dojo/Stateful"><parameters/><return-types/></method><method name="windowUnloaded" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>signal fired by impending window destruction. You may use
dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
page/application cleanup methods. See dojo.addOnWindowUnload for more info.&lt;/p>
</summary></method><method name="addOnWindowUnload" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="obj" type="Object" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when window.onunload fires.
Be careful trying to modify the DOM or access JavaScript properties
during this phase of page unloading: they may not always be available.
Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
JavaScript work.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.addOnWindowUnload(functionPointer)
  dojo.addOnWindowUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnWindowUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="addOnUnload" scope="normal" type="function" from="dojo/_base/unload"><parameters><parameter name="obj" type="Object?|Function" usage="optional"/><parameter name="functionName" type="String|Function" usage="optional"/></parameters><return-types/><summary>&lt;p>registers a function to be triggered when the page unloads.&lt;/p>
</summary><description>&lt;p>The first time that addOnUnload is called Dojo will
register a page listener to trigger your unload handler
with.

&lt;/p>
&lt;p>In a browser environment, the functions will be triggered
during the window.onbeforeunload event. Be careful of doing
too much work in an unload handler. onbeforeunload can be
triggered if a link to download a file is clicked, or if
the link is a javascript: link. In these cases, the
onbeforeunload event fires, but the document is not
actually destroyed. So be careful about doing destructive
operations in a dojo.addOnUnload callback.

&lt;/p>
&lt;p>Further note that calling dojo.addOnUnload will prevent
browsers from using a &amp;quot;fast back&amp;quot; cache to make page
loading via back button instantaneous.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.addOnUnload(functionPointer)
  dojo.addOnUnload(object, &amp;quot;functionName&amp;quot;)
  dojo.addOnUnload(object, function(){ /* ... */});&lt;/code>&lt;/pre>
</example></examples></method><method name="_xhrObj" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/></method><method name="objectToQuery" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="map" type="Object" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>takes a name/value mapping object and returns a string representing
a URL-encoded version of that object.&lt;/p>
</summary><examples><example>&lt;p>this object:

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields the following query string:

&lt;/p>
&lt;pre>&lt;code>  &amp;quot;blah=blah&amp;amp;multi=thud&amp;amp;multi=thonk&amp;quot;&lt;/code>&lt;/pre>
</example></examples></method><method name="queryToObject" scope="normal" type="function" from="dojo/io-query"><parameters><parameter name="str" type="String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Create an object representing a de-serialized query section of a
URL. Query keys with multiple values are returned in an array.
&lt;/p>
</summary><examples><example>&lt;p>This string:

&lt;/p>
&lt;pre>&lt;code>    &amp;quot;foo=bar&amp;amp;foo=baz&amp;amp;thinger=%20spaces%20=blah&amp;amp;zonk=blarg&amp;amp;&amp;quot;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>results in this object structure:

&lt;/p>
&lt;pre>&lt;code>    {
      foo: [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ],
      thinger: &amp;quot; spaces =blah&amp;quot;,
      zonk: &amp;quot;blarg&amp;quot;
    }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>Note that spaces and other urlencoded entities are correctly
handled.&lt;/p>
</example></examples></method><method name="fieldToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="inputNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><summary>&lt;p>Serialize a form field to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the value encoded in a form field as
as a string or an array of strings. Disabled form elements
and unchecked radio and checkboxes are skipped.  Multi-select
elements are returned as an array of string values.&lt;/p>
</description></method><method name="formToObject" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>Serialize a form node to a JavaScript object.&lt;/p>
</summary><description>&lt;p>Returns the values encoded in an HTML form as
string properties in an object which it then returns. Disabled form
elements, buttons, and other non-value form elements are skipped.
Multi-select elements are returned as an array of string values.&lt;/p>
</description><examples><example>&lt;p>This form:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;form id=&amp;quot;test_form&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;blah&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;no_value&amp;quot; value=&amp;quot;blah&amp;quot; disabled&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; name=&amp;quot;no_value2&amp;quot; value=&amp;quot;blah&amp;quot;&amp;gt;
    &amp;lt;select type=&amp;quot;select&amp;quot; multiple name=&amp;quot;multi&amp;quot; size=&amp;quot;5&amp;quot;&amp;gt;
      &amp;lt;option value=&amp;quot;blah&amp;quot;&amp;gt;blah&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thud&amp;quot; selected&amp;gt;thud&amp;lt;/option&amp;gt;
      &amp;lt;option value=&amp;quot;thonk&amp;quot; selected&amp;gt;thonk&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/form&amp;gt;&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>yields this object structure as the result of a call to
formToObject():

&lt;/p>
&lt;pre>&lt;code>  {
    blah: &amp;quot;blah&amp;quot;,
    multi: [
      &amp;quot;thud&amp;quot;,
      &amp;quot;thonk&amp;quot;
    ]
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="formToQuery" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns a URL-encoded string representing the form passed as either a
node or string ID identifying the form to serialize&lt;/p>
</summary></method><method name="formToJson" scope="normal" type="function" from="dojo/dom-form"><parameters><parameter name="formNode" type="DOMNode|String" usage="required"/><parameter name="prettyPrint" type="Boolean" usage="optional"/></parameters><return-types><return-type type="String"/><return-type type="undefined"/></return-types><summary>&lt;p>Create a serialized JSON string from a form node or string
ID identifying the form to serialize&lt;/p>
</summary></method><method name="__IoArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoCallbackArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="__IoPublish" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="_ioSetArgs" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="dojo/main.__IoArgs" usage="required"><summary>&lt;p>The args object passed into the public io call. Recognized properties on
the args object are:&lt;/p>
</summary></parameter><parameter name="canceller" type="Function" usage="required"><summary>&lt;p>The canceller function used for the Deferred object. The function
will receive one argument, the Deferred object that is related to the
canceller.&lt;/p>
</summary></parameter><parameter name="okHandler" type="Function" usage="required"><summary>&lt;p>The first OK callback to be registered with Deferred. It has the opportunity
to transform the OK response. It will receive one argument -- the Deferred
object returned from this function.&lt;/p>
</summary></parameter><parameter name="errHandler" type="Function" usage="required"><summary>&lt;p>The first error callback to be registered with Deferred. It has the opportunity
to do cleanup on an error. It will receive two arguments: error (the
Error object) and dfd, the Deferred object returned from this function.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>sets up the Deferred and ioArgs property on the Deferred so it
can be used in an io call.&lt;/p>
</summary></method><method name="_ioCancelAll" scope="normal" type="function" from="dojo/_base/xhr"><parameters/><return-types/><summary>&lt;p>Cancels all pending IO requests, regardless of IO type
(xhr, script, iframe).&lt;/p>
</summary></method><method name="_ioNotifyStart" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"/></parameters><return-types/><summary>&lt;p>If dojo.publish is available, publish topics
about the start of a request queue and/or the
the beginning of request.

&lt;/p>
&lt;p>Used by IO transports. An IO transport should
call this method before making the network connection.&lt;/p>
</summary></method><method name="_ioWatch" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="dfd" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The Deferred object to watch.&lt;/p>
</summary></parameter><parameter name="validCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if the IO request is still valid. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="ioCheck" type="Function" usage="required"><summary>&lt;p>Function used to check if basic IO call worked. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter><parameter name="resHandle" type="Function" usage="required"><summary>&lt;p>Function used to process response. Gets the dfd
object as its only argument.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Watches the io request represented by dfd to see if it completes.&lt;/p>
</summary></method><method name="_ioAddQueryToUrl" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="ioArgs" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>args (Object): &lt;p>the original object argument to the IO call.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>xhr (XMLHttpRequest): &lt;p>For XMLHttpRequest calls only, the
XMLHttpRequest object that was used for the
request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>The final URL used for the call. Many times it
will be different than the original args.url
value.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>query (String): &lt;p>For non-GET requests, the
name1=value1&amp;amp;name2=value2 parameters sent up in
the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handleAs (String): &lt;p>The final indicator on how the response will be
handled.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String): &lt;p>For dojo/io/script calls only, the internal
script ID used for the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>canDelete (Boolean): &lt;p>For dojo/io/script calls only, indicates
whether the script tag that represents the
request can be deleted after callbacks have
been called. Used internally to know when
cleanup can happen on JSONP-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>json (Object): &lt;p>For dojo/io/script calls only: holds the JSON
response for JSONP-type requests. Used
internally to hold on to the JSON responses.
You should not need to access it directly --
the same object should be passed to the success
callbacks directly.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Adds query params discovered by the io deferred construction to the URL.
Only use this for operations which are fundamentally GET-type operations.&lt;/p>
</summary></method><method name="__XhrArgs" scope="normal" type="constructor" from="dojo/_base/xhr"><parameters/><return-types/></method><method name="xhr" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="method" type="String" usage="required"><summary>&lt;p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter><parameter name="hasBody" type="Boolean" usage="optional"><summary>&lt;p>If the request has an HTTP body, then pass true for hasBody.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deprecated.   Use dojo/request instead.&lt;/p>
</summary><description>&lt;p>Sends an HTTP request with the given method.
See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
for those HTTP methods. There are also methods for &amp;quot;raw&amp;quot; PUT and POST methods
via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.&lt;/p>
</description></method><method name="xhrGet" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP GET request to the server.&lt;/p>
</summary></method><method name="xhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPost" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP POST request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="rawXhrPut" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP PUT request to the server. In addition to the properties
listed for the dojo.__XhrArgs type, the following property is allowed:&lt;/p>
</summary></method><method name="xhrDelete" scope="normal" type="function" from="dojo/_base/xhr"><parameters><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>handleAs (String, optional): &lt;p>Acceptable values are: text (default), json, json-comment-optional,
json-comment-filtered, javascript, xml. See &lt;code>dojo/_base/xhr.contentHandlers&lt;/code>&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sync (Boolean, optional): &lt;p>false is default. Indicates whether the request should
be a synchronous (blocking) request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional HTTP headers to send in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>failOk (Boolean, optional): &lt;p>false is default. Indicates whether a request should be
allowed to fail (and therefore no console error message in
the event of a failure)&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>contentType (String|Boolean): &lt;p>&amp;quot;application/x-www-form-urlencoded&amp;quot; is default. Set to false to
prevent a Content-Type header from being sent, or to a string
to send a different Content-Type.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>load: &lt;p>This function will be
called on a successful HTTP response code.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>error: &lt;p>This function will
be called when the request fails due to a network or server error, the url
is invalid, etc. It will also be called if the load or handle callback throws an
exception, unless djConfig.debugAtAllCosts is true.   This allows deployed applications
to continue to run even when a logic error happens in the callback, while making
it easier to troubleshoot while in debug mode.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>handle: &lt;p>This function will
be called at the end of every request, whether or not an error occurs.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>url (String): &lt;p>URL to server endpoint.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>content (Object, optional): &lt;p>Contains properties with string values. These
properties will be serialized as name1=value2 and
passed in the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>timeout (Integer, optional): &lt;p>Milliseconds to wait for the response. If this time
passes, the then error callbacks are called.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>form (DOMNode, optional): &lt;p>DOM node for a form. Used to extract the form values
and send to the server.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>preventCache (Boolean, optional): &lt;p>Default is false. If true, then a
&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
with a value that changes with each request
(timestamp). Useful only with GET-type requests.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>rawBody (String, optional): &lt;p>Sets the raw body for an HTTP request. If this is used, then the content
property is ignored. This is mostly useful for HTTP methods that have
a body to their requests, like PUT or POST. This property can be used instead
of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>ioPublish (Boolean, optional): &lt;p>Set this explicitly to false to prevent publishing of topics related to
IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
will be published via dojo/topic.publish() for different phases of an IO operation.
See dojo/main.__IoPublish for a list of topics that are published.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Sends an HTTP DELETE request to the server.&lt;/p>
</summary></method><method name="_isDocumentOk" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="http" type="undefined" usage="required"/></parameters><return-types/></method><method name="_getText" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="uri" type="URI" usage="required"><summary>&lt;p>A relative or absolute uri. If absolute, it still must be in
the same &amp;quot;domain&amp;quot; as we are.&lt;/p>
</summary></parameter><parameter name="fail_ok" type="Boolean" usage="required"><summary>&lt;p>Default false. If fail_ok and loading fails, return null
instead of throwing.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>The response text. null is returned when there is a
failure and failure is okay (an exception otherwise)</return-description><summary>&lt;p>Read the contents of the specified uri and return those contents.&lt;/p>
</summary></method><method name="_loadUri" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="uri" type="undefined" usage="required"/></parameters><return-types/></method><method name="pushContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="Object|String" usage="optional"><summary>&lt;p>The global context. If a string, the id of the frame to
search for a context and document.&lt;/p>
</summary></parameter><parameter name="d" type="MDocumentElement" usage="optional"><summary>&lt;p>The document element to execute subsequent code with.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>causes subsequent calls to Dojo methods to assume the
passed object and, optionally, document as the default
scopes to use. A 2-element array of the previous global and
document are returned.&lt;/p>
</summary><description>&lt;p>dojo.pushContext treats contexts as a stack. The
auto-detected contexts which are initially provided using
dojo.setContext() require authors to keep state in order to
&amp;quot;return&amp;quot; to a previous context, whereas the
dojo.pushContext and dojo.popContext methods provide a more
natural way to augment blocks of code to ensure that they
execute in a different window or frame without issue. If
called without any arguments, the default context (the
context when Dojo is first loaded) is instead pushed into
the stack. If only a single string is passed, a node in the
intitial context&amp;#39;s document is looked up and its
contextWindow and contextDocument properties are used as
the context to push. This means that iframes can be given
an ID and code can be executed in the scope of the iframe&amp;#39;s
document in subsequent calls easily.&lt;/p>
</description></method><method name="popContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters/><return-types/><summary>&lt;p>If the context stack contains elements, ensure that
subsequent code executes in the &lt;em>previous&lt;/em> context to the
current context. The current context set ([global,
document]) is returned.&lt;/p>
</summary></method><method name="_inContext" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="d" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="_loadInit" scope="normal" type="function" from="dojo/_base/configFirefoxExtension"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_spidermonkeyCurrentFile" scope="normal" type="function" from="dojo/_base/configSpidermonkey"><parameters><parameter name="depth" type="undefined" usage="required"/></parameters><return-types/></method><method name="provide" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="mid" type="undefined" usage="required"/></parameters><return-types/></method><method name="require" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"><summary>&lt;p>module name to load, using periods for separators,
e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo&amp;#39;s
internal mapping of locations to names and are disambiguated by
longest prefix. See &lt;code>dojo.registerModulePath()&lt;/code> for details on
registering new modules.
&lt;/p>
</summary></parameter><parameter name="omitModuleCheck" type="Boolean" usage="optional"><summary>&lt;p>if &lt;code>true&lt;/code>, omitModuleCheck skips the step of ensuring that the
loaded file actually defines the symbol it is referenced by.
For example if it called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;)&lt;/code> and the
file located at &lt;code>a/b/c.js&lt;/code> does not define an object &lt;code>a.b.c&lt;/code>,
and exception will be throws whereas no exception is raised
when called as &lt;code>dojo.require(&amp;quot;a.b.c&amp;quot;, true)&lt;/code>
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>the required namespace object</return-description><summary>&lt;p>loads a Javascript module from the appropriate URI
&lt;/p>
</summary><description>&lt;p>Modules are loaded via dojo.require by using one of two loaders: the normal loader
and the xdomain loader. The xdomain loader is used when dojo was built with a
custom build that specified loader=xdomain and the module lives on a modulePath
that is a whole URL, with protocol and a domain. The versions of Dojo that are on
the Google and AOL CDNs use the xdomain loader.

&lt;/p>
&lt;p>If the module is loaded via the xdomain loader, it is an asynchronous load, since
the module is added via a dynamically created script tag. This
means that dojo.require() can return before the module has loaded. However, this
should only happen in the case where you do dojo.require calls in the top-level
HTML page, or if you purposely avoid the loader checking for dojo.require
dependencies in your module by using a syntax like dojo[&amp;quot;require&amp;quot;] to load the module.

&lt;/p>
&lt;p>Sometimes it is useful to not have the loader detect the dojo.require calls in the
module so that you can dynamically load the modules as a result of an action on the
page, instead of right at module load time.

&lt;/p>
&lt;p>Also, for script blocks in an HTML page, the loader does not pre-process them, so
it does not know to download the modules before the dojo.require calls occur.

&lt;/p>
&lt;p>So, in those two cases, when you want on-the-fly module loading or for script blocks
in the HTML page, special care must be taken if the dojo.required code is loaded
asynchronously. To make sure you can execute code that depends on the dojo.required
modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
executing.

&lt;/p>
&lt;p>This type of syntax works with both xdomain and normal loaders, so it is good
practice to always use this idiom for on-the-fly code loading and in HTML script
blocks. If at some point you change loaders and where the code is loaded from,
it will all still work.

&lt;/p>
&lt;p>More on how dojo.require
&lt;code>dojo.require(&amp;quot;A.B&amp;quot;)&lt;/code> first checks to see if symbol A.B is
defined. If it is, it is simply returned (nothing to do).

&lt;/p>
&lt;p>If it is not defined, it will look for &lt;code>A/B.js&lt;/code> in the script root
directory.

&lt;/p>
&lt;p>&lt;code>dojo.require&lt;/code> throws an exception if it cannot find a file
to load, or if the symbol &lt;code>A.B&lt;/code> is not defined after loading.

&lt;/p>
&lt;p>It returns the object &lt;code>A.B&lt;/code>, but note the caveats above about on-the-fly loading and
HTML script blocks when the xdomain loader is loading a module.

&lt;/p>
&lt;p>&lt;code>dojo.require()&lt;/code> does nothing about importing symbols into
the current namespace.  It is presumed that the caller will
take care of that.
&lt;/p>
</description><examples><example>&lt;p>To use dojo.require in conjunction with dojo.ready:

&lt;/p>
&lt;pre>&lt;code>  dojo.require(&amp;quot;foo&amp;quot;);
  dojo.require(&amp;quot;bar&amp;quot;);
  dojo.addOnLoad(function(){
    //you can now safely do something with foo and bar
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>For example, to import all symbols into a local block, you might write:

&lt;/p>
&lt;pre>&lt;code>  with (dojo.require(&amp;quot;A.B&amp;quot;)) {
    ...
  }&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>And to import just the leaf symbol to a local variable:

&lt;/p>
&lt;pre>&lt;code>  var B = dojo.require(&amp;quot;A.B&amp;quot;);
  ...&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></method><method name="loadInit" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="f" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerModulePath" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="prefix" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Maps a module name to a path&lt;/p>
</summary><description>&lt;p>An unregistered module is given the default path of ../[module],
relative to Dojo root. For example, module acme is mapped to
../acme.  If you want to use a different module name, use
dojo.registerModulePath.&lt;/p>
</description><examples><example>&lt;p>If your dojo.js is located at this location in the web root:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/dojo/dojo/dojo.js&lt;/code>&lt;/pre>
&lt;p>and your modules are located at:&lt;/p>
&lt;pre>&lt;code>  /myapp/js/foo/bar.js
  /myapp/js/foo/baz.js
  /myapp/js/foo/thud/xyzzy.js&lt;/code>&lt;/pre>
&lt;p>Your application can tell Dojo to locate the &amp;quot;foo&amp;quot; namespace by calling:&lt;/p>
&lt;pre>&lt;code>  dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>At which point you can then use dojo.require() to load the
modules (assuming they provide() the same things which are
required). The full code might be:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;
    src=&amp;quot;/myapp/js/dojo/dojo/dojo.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    dojo.registerModulePath(&amp;quot;foo&amp;quot;, &amp;quot;../../foo&amp;quot;);
    dojo.require(&amp;quot;foo.bar&amp;quot;);
    dojo.require(&amp;quot;foo.baz&amp;quot;);
    dojo.require(&amp;quot;foo.thud.xyzzy&amp;quot;);
  &amp;lt;/script&amp;gt;&lt;/code>&lt;/pre>
</example></examples></method><method name="platformRequire" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="modMap" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>require one or more modules based on which host environment
Dojo is currently operating in&lt;/p>
</summary><description>&lt;p>This method takes a &amp;quot;map&amp;quot; of arrays which one can use to
optionally load dojo modules. The map is indexed by the
possible dojo.name&lt;em> values, with two additional values:
&amp;quot;default&amp;quot; and &amp;quot;common&amp;quot;. The items in the &amp;quot;default&amp;quot; array will
be loaded if none of the other items have been choosen based on
dojo.name&lt;/em>, set by your host environment. The items in the
&amp;quot;common&amp;quot; array will &lt;em>always&lt;/em> be loaded, regardless of which
list is chosen.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  dojo.platformRequire({
    browser: [
      &amp;quot;foo.sample&amp;quot;, // simple module
      &amp;quot;foo.test&amp;quot;,
      [&amp;quot;foo.bar.baz&amp;quot;, true] // skip object check in _loadModule (dojo.require)
    ],
    default: [ &amp;quot;foo.sample._base&amp;quot; ],
    common: [ &amp;quot;important.module.common&amp;quot; ]
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="requireAfterIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireIf" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="condition" type="Boolean" usage="required"/><parameter name="moduleName" type="String" usage="required"/><parameter name="omitModuleCheck" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>If the condition is true then call &lt;code>dojo.require()&lt;/code> for the specified
resource
&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  dojo.requireIf(dojo.isBrowser, &amp;quot;my.special.Module&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="requireLocalization" scope="normal" type="function" from="dojo/_base/loader"><parameters><parameter name="moduleName" type="String" usage="required"/><parameter name="bundleName" type="String" usage="required"/><parameter name="locale" type="String" usage="optional"/></parameters><return-types/></method><method name="cache" scope="normal" type="function" from="dojo/text"><parameters><parameter name="module" type="String||Object" usage="required"><summary>&lt;p>dojo/cldr/supplemental&lt;/p>
</summary></parameter><parameter name="url" type="String" usage="required"><summary>&lt;p>The rest of the path to append to the path derived from the module argument. If
module is an object, then this second argument should be the &amp;quot;value&amp;quot; argument instead.&lt;/p>
</summary></parameter><parameter name="value" type="String||Object" usage="optional"><summary>&lt;p>If a String, the value to use in the cache for the module/url combination.
If an Object, it can have two properties: value and sanitize. The value property
should be the value to use in the cache, and sanitize can be set to true or false,
to indicate if XML declarations should be removed from the value and if the HTML
inside a body tag in the value should be extracted as the real value. The value argument
or the value property on the value argument are usually only used by the build system
as it inlines cache content.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>A getter and setter for storing the string content associated with the
module and url arguments.&lt;/p>
</summary><description>&lt;p>If module is a string that contains slashes, then it is interpretted as a fully
resolved path (typically a result returned by require.toUrl), and url should not be
provided. This is the preferred signature. If module is a string that does not
contain slashes, then url must also be provided and module and url are used to
call &lt;code>dojo.moduleUrl()&lt;/code> to generate a module URL. This signature is deprecated.
If value is specified, the cache value for the moduleUrl will be set to
that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
in its internal cache and return that cached value for the URL. To clear
a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
the URL contents, only modules on the same domain of the page can use this capability.
The build system can inline the cache values though, to allow for xdomain hosting.&lt;/p>
</description><examples><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&amp;quot;cache&amp;quot;] style
of call is used to avoid an issue with the build system erroneously trying to intern
this example. To get the build system to intern your dojo.cache calls, use the
&amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot; that will be
 //the value for the text variable.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
(the dojo[&amp;quot;cache&amp;quot;] style of call is used to avoid an issue with the build system
erroneously trying to intern this example. To get the build system to intern your
dojo.cache calls, use the &amp;quot;dojo.cache&amp;quot; style of call):&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](&amp;quot;my.module&amp;quot;, &amp;quot;template.html&amp;quot;, {sanitize: true});&lt;/code>&lt;/pre>
</example><example>&lt;p>Same example as previous, but demonstrates how an object can be passed in as
the first argument, then the value argument can then be the second argument.&lt;/p>
&lt;pre>&lt;code> //If template.html contains &amp;quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;quot;, the
 //text variable will contain just &amp;quot;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&amp;quot;.
 var text = dojo[&amp;quot;cache&amp;quot;](new dojo._Url(&amp;quot;my/module/template.html&amp;quot;), {sanitize: true});&lt;/code>&lt;/pre>
</example></examples></method><method name="getL10nName" scope="normal" type="function" from="dojo/i18n"><parameters><parameter name="moduleName" type="undefined" usage="required"/><parameter name="bundleName" type="undefined" usage="required"/><parameter name="locale" type="undefined" usage="required"/></parameters><return-types><return-type type="string"/></return-types></method><method name="cookie" scope="normal" type="function" from="dojo/cookie"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of the cookie&lt;/p>
</summary></parameter><parameter name="value" type="String" usage="optional"><summary>&lt;p>Value for the cookie&lt;/p>
</summary></parameter><parameter name="props" type="Object" usage="optional"><summary>&lt;p>Properties for the cookie&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>expires (Date|String|Number, optional): &lt;p>If a number, the number of days from today at which the cookie
will expire. If a date, the date past which the cookie will expire.
If expires is in the past, the cookie will be deleted.
If expires is omitted or is 0, the cookie will expire when the browser closes.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>path (String, optional): &lt;p>The path to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>domain (String, optional): &lt;p>The domain to use for the cookie.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>secure (Boolean, optional): &lt;p>Whether to only send the cookie on secure connections&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Get or set a cookie.&lt;/p>
</summary><description>&lt;p>If one argument is passed, returns the value of the cookie
For two or more arguments, acts as a setter.&lt;/p>
</description><examples><example>&lt;p>set a cookie with the JSON-serialized contents of an object which
will expire 5 days from now:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    cookie(&amp;quot;configObj&amp;quot;, json.stringify(config, {expires: 5 }));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>de-serialize a cookie back into a JavaScript object:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;, &amp;quot;dojo/json&amp;quot;], function(cookie, json){
    config = json.parse(cookie(&amp;quot;configObj&amp;quot;));
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example><example>&lt;p>delete a cookie:&lt;/p>
&lt;pre>&lt;code>  require([&amp;quot;dojo/cookie&amp;quot;], function(cookie){
    cookie(&amp;quot;configObj&amp;quot;, null, {expires: -1});
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="hash" scope="normal" type="function" from="dojo/hash"><parameters><parameter name="hash" type="String" usage="optional"><summary>&lt;p>the hash is set - #string.&lt;/p>
</summary></parameter><parameter name="replace" type="Boolean" usage="optional"><summary>&lt;p>If true, updates the hash value in the current history
state instead of creating a new history state.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>when used as a getter, returns the current hash string.
when used as a setter, returns the new hash string.</return-description><summary>&lt;p>Gets or sets the hash string in the browser URL.&lt;/p>
</summary><description>&lt;p>Handles getting and setting of location.hash.

&lt;/p>
&lt;ul>
&lt;li>If no arguments are passed, acts as a getter.&lt;/li>
&lt;li>If a string is passed, acts as a setter.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  topic.subscribe(&amp;quot;/dojo/hashchange&amp;quot;, context, callback);

  function callback (hashValue){
    // do something based on the hash value.
  }&lt;/code>&lt;/pre>
</example></examples></method></methods><summary>&lt;p>This module is the foundational module of the dojo boot sequence; it defines the dojo object.&lt;/p>
</summary></object><object location="dojo/node" type="object"><properties/><methods><method name="load" scope="normal" type="function" from="dojo/node"><parameters><parameter name="id" type="string" usage="required"/><parameter name="require" type="Function" usage="required"/><parameter name="load" type="Function" usage="required"/></parameters><return-types/><summary>&lt;p>Standard AMD plugin interface. See &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;>https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&lt;/a>
for information.&lt;/p>
</summary></method></methods><summary>&lt;p>This AMD plugin module allows native Node.js modules to be loaded by AMD modules using the Dojo
loader. Note that this plugin will not work with AMD loaders other than the Dojo loader.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  require([&amp;quot;dojo/node!fs&amp;quot;], function(fs){
    var fileData = fs.readFileSync(&amp;quot;foo.txt&amp;quot;, &amp;quot;utf-8&amp;quot;);
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/promise/all" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/promise/all"><parameters><parameter name="objectOrArray" type="Object|Array" usage="optional"><summary>&lt;p>The promise will be fulfilled with a list of results if invoked with an
array, or an object of results when passed an object (using the same
keys). If passed neither an object or array it is resolved with an
undefined value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><summary>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when all promises have been fulfilled.&lt;/p>
</summary><description>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when all promises have been fulfilled. If one of the promises is rejected,
the returned promise is also rejected. Canceling the returned promise will
not* cancel any passed promises.&lt;/p>
</description></method></methods><parameters><parameter name="objectOrArray" type="Object|Array" usage="optional"><summary>&lt;p>The promise will be fulfilled with a list of results if invoked with an
array, or an object of results when passed an object (using the same
keys). If passed neither an object or array it is resolved with an
undefined value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><summary>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when all promises have been fulfilled.&lt;/p>
</summary><description>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when all promises have been fulfilled. If one of the promises is rejected,
the returned promise is also rejected. Canceling the returned promise will
not* cancel any passed promises.&lt;/p>
</description></object><object location="dojo/promise/first" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/promise/first"><parameters><parameter name="objectOrArray" type="Object|Array" usage="optional"><summary>&lt;p>The promises are taken from the array or object values. If no value
is passed, the returned promise is resolved with an undefined value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><summary>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when the first of these promises is fulfilled.&lt;/p>
</summary><description>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when the first of these promises is fulfilled. Canceling the returned
promise will &lt;em>not&lt;/em> cancel any passed promises. The promise will be
fulfilled with the value of the first fulfilled promise.&lt;/p>
</description></method></methods><parameters><parameter name="objectOrArray" type="Object|Array" usage="optional"><summary>&lt;p>The promises are taken from the array or object values. If no value
is passed, the returned promise is resolved with an undefined value.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/promise/Promise"/></return-types><summary>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when the first of these promises is fulfilled.&lt;/p>
</summary><description>&lt;p>Takes multiple promises and returns a new promise that is fulfilled
when the first of these promises is fulfilled. Canceling the returned
promise will &lt;em>not&lt;/em> cancel any passed promises. The promise will be
fulfilled with the value of the first fulfilled promise.&lt;/p>
</description></object><object location="dojo/promise/instrumentation" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/promise/instrumentation"><parameters><parameter name="Deferred" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Initialize instrumentation for the Deferred class.&lt;/p>
</summary><description>&lt;p>Initialize instrumentation for the Deferred class.
Done automatically by &lt;code>dojo/Deferred&lt;/code> if the
&lt;code>deferredInstrumentation&lt;/code> and &lt;code>useDeferredInstrumentation&lt;/code>
config options are set.

&lt;/p>
&lt;p>Sets up &lt;code>dojo/promise/tracer&lt;/code> to log to the console.

&lt;/p>
&lt;p>Sets up instrumentation of rejected deferreds so unhandled
errors are logged to the console.&lt;/p>
</description></method></methods><parameters><parameter name="Deferred" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Initialize instrumentation for the Deferred class.&lt;/p>
</summary><description>&lt;p>Initialize instrumentation for the Deferred class.
Done automatically by &lt;code>dojo/Deferred&lt;/code> if the
&lt;code>deferredInstrumentation&lt;/code> and &lt;code>useDeferredInstrumentation&lt;/code>
config options are set.

&lt;/p>
&lt;p>Sets up &lt;code>dojo/promise/tracer&lt;/code> to log to the console.

&lt;/p>
&lt;p>Sets up instrumentation of rejected deferreds so unhandled
errors are logged to the console.&lt;/p>
</description></object><object location="dojo/promise/tracer" type="object"><properties/><methods><method name="on" scope="normal" type="function" from="dojo/promise/tracer"><parameters><parameter name="type" type="String" usage="required"><summary>&lt;p>&lt;code>resolved&lt;/code>, &lt;code>rejected&lt;/code>, or &lt;code>progress&lt;/code>&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="required"><summary>&lt;p>The listener is passed the traced value and any arguments
that were used with the &lt;code>.trace()&lt;/code> call.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Subscribe to traces.&lt;/p>
</summary><description>&lt;p>See &lt;code>dojo/Evented#on()&lt;/code>.&lt;/p>
</description></method></methods><summary>&lt;p>Trace promise fulfillment.&lt;/p>
</summary><description>&lt;p>Trace promise fulfillment. Calling &lt;code>.trace()&lt;/code> or &lt;code>.traceError()&lt;/code> on a
promise enables tracing. Will emit &lt;code>resolved&lt;/code>, &lt;code>rejected&lt;/code> or &lt;code>progress&lt;/code>
events.&lt;/p>
</description></object><object location="dojo/request/default" type="object"><properties/><methods><method name="getPlatformDefaultId" scope="normal" type="function" from="dojo/request/default"><parameters/><return-types/></method><method name="load" scope="normal" type="function" from="dojo/request/default"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="parentRequire" type="undefined" usage="required"/><parameter name="loaded" type="undefined" usage="required"/><parameter name="config" type="undefined" usage="required"/></parameters><return-types/></method></methods></object><object location="dojo/request/node" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/node"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using the included http or https interface from node.js
with the given URL and options.&lt;/p>
</summary></method><method name="__BaseOptions" scope="normal" type="constructor" from="dojo/request/node"><parameters/><return-types/></method><method name="__MethodOptions" scope="normal" type="constructor" from="dojo/request/node"><parameters/><return-types/></method><method name="__Options" scope="normal" type="constructor" from="dojo/request/node"><parameters/><return-types/></method><method name="get" scope="normal" type="function" from="dojo/request/node"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP GET request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="post" scope="normal" type="function" from="dojo/request/node"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP POST request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="put" scope="normal" type="function" from="dojo/request/node"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP PUT request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method><method name="del" scope="normal" type="function" from="dojo/request/node"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__BaseOptions" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.&lt;/p>
</summary></method></methods><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to request&lt;/p>
</summary></parameter><parameter name="options" type="dojo/request/node.__Options" usage="optional"><summary>&lt;p>Options for the request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/request.__Promise"/></return-types><summary>&lt;p>Sends a request using the included http or https interface from node.js
with the given URL and options.&lt;/p>
</summary></object><object location="dojo/request/notify" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/notify"><parameters><parameter name="type" type="String" usage="optional"><summary>&lt;p>The event to listen for. Events emitted: &amp;quot;start&amp;quot;, &amp;quot;send&amp;quot;,
&amp;quot;load&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;done&amp;quot;, &amp;quot;stop&amp;quot;.&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="optional"><summary>&lt;p>A callback to be run when an event happens.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A signal object that can be used to cancel the listener.
If remove() is called on this signal object, it will
stop the listener from being executed.</return-description><summary>&lt;p>Register a listener to be notified when an event
in dojo/request happens.&lt;/p>
</summary></method><method name="emit" scope="normal" type="function" from="dojo/request/notify"><parameters><parameter name="type" type="undefined" usage="required"/><parameter name="event" type="undefined" usage="required"/><parameter name="cancel" type="undefined" usage="required"/></parameters><return-types/></method></methods><parameters><parameter name="type" type="String" usage="optional"><summary>&lt;p>The event to listen for. Events emitted: &amp;quot;start&amp;quot;, &amp;quot;send&amp;quot;,
&amp;quot;load&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;done&amp;quot;, &amp;quot;stop&amp;quot;.&lt;/p>
</summary></parameter><parameter name="listener" type="Function" usage="optional"><summary>&lt;p>A callback to be run when an event happens.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>A signal object that can be used to cancel the listener.
If remove() is called on this signal object, it will
stop the listener from being executed.</return-description><summary>&lt;p>Register a listener to be notified when an event
in dojo/request happens.&lt;/p>
</summary></object><object location="dojo/request/registry" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/request/registry"><parameters><parameter name="url" type="undefined" usage="required"/><parameter name="options" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="register" scope="normal" type="function" from="dojo/request/registry"><parameters><parameter name="url" type="undefined" usage="required"/><parameter name="provider" type="undefined" usage="required"/><parameter name="first" type="undefined" usage="required"/></parameters><return-types/></method><method name="load" scope="normal" type="function" from="dojo/request/registry"><parameters><parameter name="id" type="undefined" usage="required"/><parameter name="parentRequire" type="undefined" usage="required"/><parameter name="loaded" type="undefined" usage="required"/><parameter name="config" type="undefined" usage="required"/></parameters><return-types/></method></methods><parameters><parameter name="url" type="undefined" usage="required"/><parameter name="options" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></object><object location="dojo/require" type="object"><properties><property name="dynamic" scope="normal" type="number" from="dojo/require"/><property name="load" scope="normal" type="undefined" from="dojo/require"/></properties><methods><method name="normalize" scope="normal" type="function" from="dojo/require"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method></methods></object><object location="dojo/robot" type="object"><properties><property name="_robotLoaded" scope="normal" type="boolean" from="doh/robot"/><property name="_robotInitialized" scope="normal" type="boolean" from="doh/robot"/><property name="_spaceReceived" scope="normal" type="boolean" from="doh/robot"/><property name="_primePump" scope="normal" type="boolean" from="doh/robot"/><property name="_runsemaphore" scope="normal" type="object" from="doh/robot"/><property name="_appletDead" scope="normal" type="boolean" from="doh/robot"/><property name="mouseWheelSize" scope="normal" type="number" from="doh/robot"/><property name="window" scope="normal" type="undefined" from="dojo/robotx"/><property name="doc" scope="normal" type="undefined" from="dojo/robotx"/></properties><methods><method name="_killApplet" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="killRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="startRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initRobot" scope="normal" type="function" from="doh/robot"><parameters><parameter name="r" type="undefined" usage="required"/></parameters><return-types/></method><method name="_run" scope="normal" type="function" from="doh/robot"><parameters><parameter name="frame" type="undefined" usage="required"/></parameters><return-types/></method><method name="_initKeyboard" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initWheel" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_setDocumentBounds" scope="normal" type="function" from="doh/robot"><parameters><parameter name="docScreenX" type="undefined" usage="required"/><parameter name="docScreenY" type="undefined" usage="required"/></parameters><return-types/></method><method name="_notified" scope="normal" type="function" from="doh/robot"><parameters><parameter name="keystring" type="undefined" usage="required"/></parameters><return-types/></method><method name="_assertRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"/><parameter name="y" type="Number" usage="required"/><parameter name="absolute" type="Boolean" usage="required"/><parameter name="duration" type="Integer" usage="optional"/></parameters><return-types/></method><method name="sequence" scope="normal" type="function" from="doh/robot"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>A function containing actions you want to defer.  It can return a Promise
to delay further actions.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Delay to wait after firing.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Defer an action by adding it to the robot&amp;#39;s incrementally delayed queue of actions to execute.&lt;/p>
</summary></method><method name="typeKeys" scope="normal" type="function" from="doh/robot"><parameters><parameter name="chars" type="String|Number" usage="required"><summary>&lt;p>String of characters to type, or a dojo.keys.* constant&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Time, in milliseconds, to spend pressing all of the keys.
The default is (string length)*50 ms.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</summary><description>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  robot.typeKeys(&amp;quot;dijit.ed&amp;quot;, 500);&lt;/code>&lt;/pre>
</example></examples></method><method name="keyPress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to press&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="modifiers" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the modifier keys being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>shift&lt;/li>
&lt;li>alt&lt;/li>
&lt;li>ctrl&lt;/li>
&lt;li>meta&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="asynchronous" type="Boolean" usage="required"><summary>&lt;p>If true, the delay happens asynchronously and immediately, outside of the browser&amp;#39;s JavaScript thread and any previous calls.
This is useful for interacting with the browser&amp;#39;s modal dialogs.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</summary><description>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</description><examples><example>&lt;p>to press shift-tab immediately, call robot.keyPress(dojo.keys.TAB, 0, {shift: true})&lt;/p>
</example></examples></method><method name="keyDown" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to hold down
Warning: holding down a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to hold down the &amp;#39;a&amp;#39; key immediately, call robot.keyDown(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="keyUp" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to release
Warning: releasing a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to release the &amp;#39;a&amp;#39; key immediately, call robot.keyUp(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="mouseClick" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</summary><description>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mousePress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the mouse buttons being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>left&lt;/li>
&lt;li>middle&lt;/li>
&lt;li>right&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Presses mouse buttons.&lt;/p>
</summary><description>&lt;p>Presses the mouse buttons you pass as true.
Example: to press the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.&lt;/p>
</description></method><method name="mouseMoveTo" scope="normal" type="function" from="doh/robot"><parameters><parameter name="point" type="Object" usage="required"><summary>&lt;p>x, y position relative to viewport, or if absolute == true, to document&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"/><parameter name="duration" type="Integer" usage="optional"/><parameter name="absolute" type="Boolean" usage="required"/></parameters><return-types/><summary>&lt;p>Move the mouse from the current position to the specified point.
Delays reading contents point until queued command starts running.
See mouseMove() for details.&lt;/p>
</summary></method><method name="mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"><summary>&lt;p>x offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="y" type="Number" usage="required"><summary>&lt;p>y offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms. This also affects how many mousemove events will
be generated, which is the log of the duration.&lt;/p>
</summary></parameter><parameter name="absolute" type="Boolean" usage="required"><summary>&lt;p>Boolean indicating whether the x and y values are absolute coordinates.
If false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)
If true, then mouseMove expects that the x,y will be absolute. (pageX/Y)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse to the specified x,y offset relative to the viewport.&lt;/p>
</summary></method><method name="mouseRelease" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Releases mouse buttons.&lt;/p>
</summary><description>&lt;p>Releases the mouse buttons you pass as true.
Example: to release the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mouseWheel" scope="normal" type="function" from="doh/robot"><parameters><parameter name="wheelAmt" type="Number" usage="required"><summary>&lt;p>Number of notches to spin the wheel.
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:
robot.mouseClick({left: true}, 100) // first call; wait 100ms
robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/p>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
By default, the Robot will wheel the mouse as fast as possible.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Spins the mouse wheel.&lt;/p>
</summary><description>&lt;p>Spins the wheel wheelAmt &amp;quot;notches.&amp;quot;
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.
Note: this will all happen in one event.
Warning: the size of one mouse wheel notch is an OS setting.
You can access this size from robot.mouseWheelSize&lt;/p>
</description></method><method name="setClipboard" scope="normal" type="function" from="doh/robot"><parameters><parameter name="data" type="String" usage="required"><summary>&lt;p>New clipboard content to set&lt;/p>
</summary></parameter><parameter name="format" type="String" usage="optional"><summary>&lt;p>Set this to &amp;quot;text/html&amp;quot; to put richtext to the clipboard.
Otherwise, data is treated as plaintext. By default, plaintext
is used.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set clipboard content.&lt;/p>
</summary><description>&lt;p>Set data as clipboard content, overriding anything already there. The
data will be put to the clipboard using the given format.&lt;/p>
</description></method><method name="_resolveNode" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="String||DOMNode||Function" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types/></method><method name="_position" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_getWindowChain" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="Array"/></return-types></method><method name="scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Number, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Scroll the passed node into view, if it is not.&lt;/p>
</summary></method><method name="mouseMoveAt" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>  robot.mouseClick({left:true}, 100) // first call; wait 100ms
  robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer, optional" usage="required"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms.&lt;/p>
</summary></parameter><parameter name="offsetX" type="Number, optional" usage="required"><summary>&lt;p>x offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s width.&lt;/p>
</summary></parameter><parameter name="offsetY" type="Number, optional" usage="required"><summary>&lt;p>y offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s height.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.&lt;/p>
</summary><description>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.
If you do not specify an offset, mouseMove will default to move to the middle of the node.
Example: to move the mouse over a ComboBox&amp;#39;s down arrow node, call doh.mouseMoveAt(dijit.byId(&amp;#39;setvaluetest&amp;#39;).downArrowNode);&lt;/p>
</description></method><method name="_updateDocument" scope="normal" type="function" from="dojo/robotx"><parameters/><return-types/><summary>&lt;p>Called every time a new page is loaded into the iframe, to setup variables
Point dojo.global, dojo.publish, etc. to refer to iframe.
Remove for 2.0?&lt;/p>
</summary></method><method name="initRobot" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to open. Any of the test&amp;#39;s dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Opens the application at the specified URL for testing, redirecting dojo to point to the application environment instead of the test environment.&lt;/p>
</summary></method><method name="waitForPageToLoad" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="submitActions" type="Function" usage="required"><summary>&lt;p>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
expecting these actions to create a page change (like a form submit).
After these actions execute and the resulting page loads, the next test will start.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</summary><description>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  runTest: function(){
    return waitForPageLoad(function(){ doh.robot.keyPress(keys.ENTER, 500); });
  }&lt;/code>&lt;/pre>
</example></examples></method></methods></object><object location="doh/_browserRunner" type="object"><properties><property name="_line" scope="normal" type="string" from="doh/runner"/><property name="debug" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="error" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_testCount" scope="normal" type="number" from="doh/runner"/><property name="_groupCount" scope="normal" type="number" from="doh/runner"/><property name="_errorCount" scope="normal" type="number" from="doh/runner"/><property name="_failureCount" scope="normal" type="number" from="doh/runner"/><property name="_currentGroup" scope="normal" type="null" from="doh/runner"/><property name="_currentTest" scope="normal" type="null" from="doh/runner"/><property name="_paused" scope="normal" type="boolean" from="doh/runner"/><property name="_init" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_groups" scope="normal" type="object" from="doh/runner"/><property name="_testTypes" scope="normal" type="object" from="doh/runner"/><property name="registerUrl" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_setupGroupForRun" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="isBrowser" scope="normal" type="boolean" from="doh/_browserRunner"/><property name="_initRobotCalled" scope="normal" type="boolean" from="doh/robot"/><property name="robot" scope="normal" type="object" from="doh/robot"/></properties><methods><method name="_AssertFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="msg" type="undefined" usage="required"/><parameter name="hint" type="undefined" usage="required"/></parameters><return-types/></method><method name="Deferred" scope="normal" type="function" from="doh/runner"><parameters><parameter name="canceller" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerTestType" scope="normal" type="function" from="doh/runner"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The name of the type.&lt;/p>
</summary></parameter><parameter name="initProc" type="Function" usage="required"><summary>&lt;p>Type specific test initializer; called after the test object is created.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds a test type and associates a function used to initialize each test of the given type&lt;/p>
</summary></method><method name="_testRegistered" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_groupStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="_groupFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/><parameter name="s" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"><summary>&lt;p>string name of the group to add the test to&lt;/p>
</summary></parameter><parameter name="test" type="Function||String||Object" usage="required"><summary>&lt;p>TODOC&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="optional"><summary>&lt;p>An identifier denoting the type of testing that the test performs, such
as a performance test. If falsy, defaults to test.type.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>add the provided test function or fixture object to the specified
test group.&lt;/p>
</summary></method><method name="_registerTestAndCheck" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupId" type="undefined" usage="required"/><parameter name="test" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="testArgPosition" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/><parameter name="setUp" type="undefined" usage="required"/><parameter name="tearDown" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerUrl" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="url" type="undefined" usage="required"/><parameter name="timeout" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="dohArgs" type="undefined" usage="required"/></parameters><return-types/></method><method name="register" scope="normal" type="function" from="doh/runner"><parameters><parameter name="a1" type="undefined" usage="required"/><parameter name="a2" type="undefined" usage="required"/><parameter name="a3" type="undefined" usage="required"/><parameter name="a4" type="undefined" usage="required"/><parameter name="a5" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerDocTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="module" type="undefined" usage="required"><summary>&lt;p>dojo/uacss&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get all the doctests from the given module and register each of them
as a single test case here.&lt;/p>
</summary></method><method name="registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="test" type="Array||Function||Object" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, test) instead&lt;/p>
</summary></method><method name="registerGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="tests" type="Array||Function||Object" usage="required"/><parameter name="setUp" type="Function" usage="required"/><parameter name="tearDown" type="Function" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, tests, setUp, tearDown) instead&lt;/p>
</summary></method><method name="registerTestNs" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="ns" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group, ns) instead&lt;/p>
</summary></method><method name="registerTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="testArr" type="Array" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, testArr) instead&lt;/p>
</summary></method><method name="assertTrue" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="t" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="assertFalse" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="f" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="assertError" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="e" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="assertEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="is" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="assertNotEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="isNot" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="_arrayEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_objPropEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_handleFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_runPerfFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The test group that contains this performance test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The performance test fixture.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function handles how to execute a &amp;#39;performance&amp;#39; test
which is different from a straight UT style test.  These
will often do numerous iterations of the same operation and
gather execution statistics about it, like max, min, average,
etc.  It makes use of the already in place DOH deferred test
handling since it is a good idea to put a pause in between each
iteration to allow for GC cleanup and the like.&lt;/p>
</summary></method><method name="_calcTrialIterations" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture we want to calculate iterations for.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function determines the rough number of iterations to
use to reach a particular MS threshold.  This returns a deferred
since tests can theoretically by async.  Async tests aren&amp;#39;t going to
give great perf #s, though.
The callback is passed the # of iterations to hit the requested
threshold.&lt;/p>
</summary></method><method name="_runRegFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The groupName of the test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture to execute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Function to run a generic doh test.  These are not
specialized tests, like performance groups and such.&lt;/p>
</summary></method><method name="_runFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="runGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="idx" type="Integer" usage="required"/></parameters><return-types/><summary>&lt;p>runs the specified test group&lt;/p>
</summary></method><method name="_onEnd" scope="normal" type="function" from="dojo/tests"><parameters/><return-types/></method><method name="_report" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="togglePaused" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="pause" scope="normal" type="function" from="doh/runner"><parameters/><return-types/><summary>&lt;p>halt test run. Can be resumed.&lt;/p>
</summary></method><method name="run" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="runOnLoad" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="_jumpToLog" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_jumpToSuite" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateTestList" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="unwindingBacklog" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateGlobalProgressBar" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="p" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/><parameter name="group" type="undefined" usage="required"/></parameters><return-types/></method><method name="showTestPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showLogPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showPerfTestsPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="toggleRunAll" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method></methods><summary>&lt;p>Functions for registering and running automated tests.&lt;/p>
</summary></object><object location="doh/runner" type="object"><properties><property name="_line" scope="normal" type="string" from="doh/runner"/><property name="debug" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="error" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_testCount" scope="normal" type="number" from="doh/runner"/><property name="_groupCount" scope="normal" type="number" from="doh/runner"/><property name="_errorCount" scope="normal" type="number" from="doh/runner"/><property name="_failureCount" scope="normal" type="number" from="doh/runner"/><property name="_currentGroup" scope="normal" type="null" from="doh/runner"/><property name="_currentTest" scope="normal" type="null" from="doh/runner"/><property name="_paused" scope="normal" type="boolean" from="doh/runner"/><property name="_init" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_groups" scope="normal" type="object" from="doh/runner"/><property name="_testTypes" scope="normal" type="object" from="doh/runner"/><property name="registerUrl" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_setupGroupForRun" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="isBrowser" scope="normal" type="boolean" from="doh/_browserRunner"/><property name="_initRobotCalled" scope="normal" type="boolean" from="doh/robot"/><property name="robot" scope="normal" type="object" from="doh/robot"/></properties><methods><method name="_AssertFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="msg" type="undefined" usage="required"/><parameter name="hint" type="undefined" usage="required"/></parameters><return-types/></method><method name="Deferred" scope="normal" type="function" from="doh/runner"><parameters><parameter name="canceller" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerTestType" scope="normal" type="function" from="doh/runner"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The name of the type.&lt;/p>
</summary></parameter><parameter name="initProc" type="Function" usage="required"><summary>&lt;p>Type specific test initializer; called after the test object is created.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds a test type and associates a function used to initialize each test of the given type&lt;/p>
</summary></method><method name="_testRegistered" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_groupStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="_groupFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/><parameter name="s" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"><summary>&lt;p>string name of the group to add the test to&lt;/p>
</summary></parameter><parameter name="test" type="Function||String||Object" usage="required"><summary>&lt;p>TODOC&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="optional"><summary>&lt;p>An identifier denoting the type of testing that the test performs, such
as a performance test. If falsy, defaults to test.type.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>add the provided test function or fixture object to the specified
test group.&lt;/p>
</summary></method><method name="_registerTestAndCheck" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupId" type="undefined" usage="required"/><parameter name="test" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="testArgPosition" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/><parameter name="setUp" type="undefined" usage="required"/><parameter name="tearDown" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerUrl" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="url" type="undefined" usage="required"/><parameter name="timeout" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="dohArgs" type="undefined" usage="required"/></parameters><return-types/></method><method name="register" scope="normal" type="function" from="doh/runner"><parameters><parameter name="a1" type="undefined" usage="required"/><parameter name="a2" type="undefined" usage="required"/><parameter name="a3" type="undefined" usage="required"/><parameter name="a4" type="undefined" usage="required"/><parameter name="a5" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerDocTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="module" type="undefined" usage="required"><summary>&lt;p>dojo/uacss&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get all the doctests from the given module and register each of them
as a single test case here.&lt;/p>
</summary></method><method name="registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="test" type="Array||Function||Object" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, test) instead&lt;/p>
</summary></method><method name="registerGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="tests" type="Array||Function||Object" usage="required"/><parameter name="setUp" type="Function" usage="required"/><parameter name="tearDown" type="Function" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, tests, setUp, tearDown) instead&lt;/p>
</summary></method><method name="registerTestNs" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="ns" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group, ns) instead&lt;/p>
</summary></method><method name="registerTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="testArr" type="Array" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, testArr) instead&lt;/p>
</summary></method><method name="assertTrue" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="t" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="assertFalse" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="f" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="assertError" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="e" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="assertEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="is" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="assertNotEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="isNot" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="_arrayEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_objPropEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_handleFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_runPerfFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The test group that contains this performance test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The performance test fixture.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function handles how to execute a &amp;#39;performance&amp;#39; test
which is different from a straight UT style test.  These
will often do numerous iterations of the same operation and
gather execution statistics about it, like max, min, average,
etc.  It makes use of the already in place DOH deferred test
handling since it is a good idea to put a pause in between each
iteration to allow for GC cleanup and the like.&lt;/p>
</summary></method><method name="_calcTrialIterations" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture we want to calculate iterations for.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function determines the rough number of iterations to
use to reach a particular MS threshold.  This returns a deferred
since tests can theoretically by async.  Async tests aren&amp;#39;t going to
give great perf #s, though.
The callback is passed the # of iterations to hit the requested
threshold.&lt;/p>
</summary></method><method name="_runRegFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The groupName of the test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture to execute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Function to run a generic doh test.  These are not
specialized tests, like performance groups and such.&lt;/p>
</summary></method><method name="_runFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="runGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="idx" type="Integer" usage="required"/></parameters><return-types/><summary>&lt;p>runs the specified test group&lt;/p>
</summary></method><method name="_onEnd" scope="normal" type="function" from="dojo/tests"><parameters/><return-types/></method><method name="_report" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="togglePaused" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="pause" scope="normal" type="function" from="doh/runner"><parameters/><return-types/><summary>&lt;p>halt test run. Can be resumed.&lt;/p>
</summary></method><method name="run" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="runOnLoad" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="_jumpToLog" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_jumpToSuite" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateTestList" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="unwindingBacklog" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateGlobalProgressBar" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="p" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/><parameter name="group" type="undefined" usage="required"/></parameters><return-types/></method><method name="showTestPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showLogPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showPerfTestsPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="toggleRunAll" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method></methods><summary>&lt;p>Functions for registering and running automated tests.&lt;/p>
</summary></object><object location="doh/robot" type="object"><properties><property name="_robotLoaded" scope="normal" type="boolean" from="doh/robot"/><property name="_robotInitialized" scope="normal" type="boolean" from="doh/robot"/><property name="_spaceReceived" scope="normal" type="boolean" from="doh/robot"/><property name="_primePump" scope="normal" type="boolean" from="doh/robot"/><property name="_runsemaphore" scope="normal" type="object" from="doh/robot"/><property name="_appletDead" scope="normal" type="boolean" from="doh/robot"/><property name="mouseWheelSize" scope="normal" type="number" from="doh/robot"/><property name="window" scope="normal" type="undefined" from="dojo/robotx"/><property name="doc" scope="normal" type="undefined" from="dojo/robotx"/></properties><methods><method name="_killApplet" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="killRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="startRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initRobot" scope="normal" type="function" from="doh/robot"><parameters><parameter name="r" type="undefined" usage="required"/></parameters><return-types/></method><method name="_run" scope="normal" type="function" from="doh/robot"><parameters><parameter name="frame" type="undefined" usage="required"/></parameters><return-types/></method><method name="_initKeyboard" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initWheel" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_setDocumentBounds" scope="normal" type="function" from="doh/robot"><parameters><parameter name="docScreenX" type="undefined" usage="required"/><parameter name="docScreenY" type="undefined" usage="required"/></parameters><return-types/></method><method name="_notified" scope="normal" type="function" from="doh/robot"><parameters><parameter name="keystring" type="undefined" usage="required"/></parameters><return-types/></method><method name="_assertRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"/><parameter name="y" type="Number" usage="required"/><parameter name="absolute" type="Boolean" usage="required"/><parameter name="duration" type="Integer" usage="optional"/></parameters><return-types/></method><method name="sequence" scope="normal" type="function" from="doh/robot"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>A function containing actions you want to defer.  It can return a Promise
to delay further actions.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Delay to wait after firing.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Defer an action by adding it to the robot&amp;#39;s incrementally delayed queue of actions to execute.&lt;/p>
</summary></method><method name="typeKeys" scope="normal" type="function" from="doh/robot"><parameters><parameter name="chars" type="String|Number" usage="required"><summary>&lt;p>String of characters to type, or a dojo.keys.* constant&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Time, in milliseconds, to spend pressing all of the keys.
The default is (string length)*50 ms.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</summary><description>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  robot.typeKeys(&amp;quot;dijit.ed&amp;quot;, 500);&lt;/code>&lt;/pre>
</example></examples></method><method name="keyPress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to press&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="modifiers" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the modifier keys being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>shift&lt;/li>
&lt;li>alt&lt;/li>
&lt;li>ctrl&lt;/li>
&lt;li>meta&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="asynchronous" type="Boolean" usage="required"><summary>&lt;p>If true, the delay happens asynchronously and immediately, outside of the browser&amp;#39;s JavaScript thread and any previous calls.
This is useful for interacting with the browser&amp;#39;s modal dialogs.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</summary><description>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</description><examples><example>&lt;p>to press shift-tab immediately, call robot.keyPress(dojo.keys.TAB, 0, {shift: true})&lt;/p>
</example></examples></method><method name="keyDown" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to hold down
Warning: holding down a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to hold down the &amp;#39;a&amp;#39; key immediately, call robot.keyDown(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="keyUp" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to release
Warning: releasing a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to release the &amp;#39;a&amp;#39; key immediately, call robot.keyUp(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="mouseClick" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</summary><description>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mousePress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the mouse buttons being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>left&lt;/li>
&lt;li>middle&lt;/li>
&lt;li>right&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Presses mouse buttons.&lt;/p>
</summary><description>&lt;p>Presses the mouse buttons you pass as true.
Example: to press the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.&lt;/p>
</description></method><method name="mouseMoveTo" scope="normal" type="function" from="doh/robot"><parameters><parameter name="point" type="Object" usage="required"><summary>&lt;p>x, y position relative to viewport, or if absolute == true, to document&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"/><parameter name="duration" type="Integer" usage="optional"/><parameter name="absolute" type="Boolean" usage="required"/></parameters><return-types/><summary>&lt;p>Move the mouse from the current position to the specified point.
Delays reading contents point until queued command starts running.
See mouseMove() for details.&lt;/p>
</summary></method><method name="mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"><summary>&lt;p>x offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="y" type="Number" usage="required"><summary>&lt;p>y offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms. This also affects how many mousemove events will
be generated, which is the log of the duration.&lt;/p>
</summary></parameter><parameter name="absolute" type="Boolean" usage="required"><summary>&lt;p>Boolean indicating whether the x and y values are absolute coordinates.
If false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)
If true, then mouseMove expects that the x,y will be absolute. (pageX/Y)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse to the specified x,y offset relative to the viewport.&lt;/p>
</summary></method><method name="mouseRelease" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Releases mouse buttons.&lt;/p>
</summary><description>&lt;p>Releases the mouse buttons you pass as true.
Example: to release the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mouseWheel" scope="normal" type="function" from="doh/robot"><parameters><parameter name="wheelAmt" type="Number" usage="required"><summary>&lt;p>Number of notches to spin the wheel.
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:
robot.mouseClick({left: true}, 100) // first call; wait 100ms
robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/p>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
By default, the Robot will wheel the mouse as fast as possible.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Spins the mouse wheel.&lt;/p>
</summary><description>&lt;p>Spins the wheel wheelAmt &amp;quot;notches.&amp;quot;
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.
Note: this will all happen in one event.
Warning: the size of one mouse wheel notch is an OS setting.
You can access this size from robot.mouseWheelSize&lt;/p>
</description></method><method name="setClipboard" scope="normal" type="function" from="doh/robot"><parameters><parameter name="data" type="String" usage="required"><summary>&lt;p>New clipboard content to set&lt;/p>
</summary></parameter><parameter name="format" type="String" usage="optional"><summary>&lt;p>Set this to &amp;quot;text/html&amp;quot; to put richtext to the clipboard.
Otherwise, data is treated as plaintext. By default, plaintext
is used.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set clipboard content.&lt;/p>
</summary><description>&lt;p>Set data as clipboard content, overriding anything already there. The
data will be put to the clipboard using the given format.&lt;/p>
</description></method><method name="_resolveNode" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="String||DOMNode||Function" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types/></method><method name="_position" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_getWindowChain" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="Array"/></return-types></method><method name="scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Number, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Scroll the passed node into view, if it is not.&lt;/p>
</summary></method><method name="mouseMoveAt" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>  robot.mouseClick({left:true}, 100) // first call; wait 100ms
  robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer, optional" usage="required"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms.&lt;/p>
</summary></parameter><parameter name="offsetX" type="Number, optional" usage="required"><summary>&lt;p>x offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s width.&lt;/p>
</summary></parameter><parameter name="offsetY" type="Number, optional" usage="required"><summary>&lt;p>y offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s height.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.&lt;/p>
</summary><description>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.
If you do not specify an offset, mouseMove will default to move to the middle of the node.
Example: to move the mouse over a ComboBox&amp;#39;s down arrow node, call doh.mouseMoveAt(dijit.byId(&amp;#39;setvaluetest&amp;#39;).downArrowNode);&lt;/p>
</description></method><method name="_updateDocument" scope="normal" type="function" from="dojo/robotx"><parameters/><return-types/><summary>&lt;p>Called every time a new page is loaded into the iframe, to setup variables
Point dojo.global, dojo.publish, etc. to refer to iframe.
Remove for 2.0?&lt;/p>
</summary></method><method name="initRobot" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to open. Any of the test&amp;#39;s dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Opens the application at the specified URL for testing, redirecting dojo to point to the application environment instead of the test environment.&lt;/p>
</summary></method><method name="waitForPageToLoad" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="submitActions" type="Function" usage="required"><summary>&lt;p>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
expecting these actions to create a page change (like a form submit).
After these actions execute and the resulting page loads, the next test will start.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</summary><description>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  runTest: function(){
    return waitForPageLoad(function(){ doh.robot.keyPress(keys.ENTER, 500); });
  }&lt;/code>&lt;/pre>
</example></examples></method></methods></object><object location="dojo/robotx" type="object"><properties><property name="_robotLoaded" scope="normal" type="boolean" from="doh/robot"/><property name="_robotInitialized" scope="normal" type="boolean" from="doh/robot"/><property name="_spaceReceived" scope="normal" type="boolean" from="doh/robot"/><property name="_primePump" scope="normal" type="boolean" from="doh/robot"/><property name="_runsemaphore" scope="normal" type="object" from="doh/robot"/><property name="_appletDead" scope="normal" type="boolean" from="doh/robot"/><property name="mouseWheelSize" scope="normal" type="number" from="doh/robot"/><property name="window" scope="normal" type="undefined" from="dojo/robotx"/><property name="doc" scope="normal" type="undefined" from="dojo/robotx"/></properties><methods><method name="_killApplet" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="killRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="startRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initRobot" scope="normal" type="function" from="doh/robot"><parameters><parameter name="r" type="undefined" usage="required"/></parameters><return-types/></method><method name="_run" scope="normal" type="function" from="doh/robot"><parameters><parameter name="frame" type="undefined" usage="required"/></parameters><return-types/></method><method name="_initKeyboard" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_initWheel" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_setDocumentBounds" scope="normal" type="function" from="doh/robot"><parameters><parameter name="docScreenX" type="undefined" usage="required"/><parameter name="docScreenY" type="undefined" usage="required"/></parameters><return-types/></method><method name="_notified" scope="normal" type="function" from="doh/robot"><parameters><parameter name="keystring" type="undefined" usage="required"/></parameters><return-types/></method><method name="_assertRobot" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="_mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"/><parameter name="y" type="Number" usage="required"/><parameter name="absolute" type="Boolean" usage="required"/><parameter name="duration" type="Integer" usage="optional"/></parameters><return-types/></method><method name="sequence" scope="normal" type="function" from="doh/robot"><parameters><parameter name="f" type="Function" usage="required"><summary>&lt;p>A function containing actions you want to defer.  It can return a Promise
to delay further actions.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Delay to wait after firing.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Defer an action by adding it to the robot&amp;#39;s incrementally delayed queue of actions to execute.&lt;/p>
</summary></method><method name="typeKeys" scope="normal" type="function" from="doh/robot"><parameters><parameter name="chars" type="String|Number" usage="required"><summary>&lt;p>String of characters to type, or a dojo.keys.* constant&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Time, in milliseconds, to spend pressing all of the keys.
The default is (string length)*50 ms.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</summary><description>&lt;p>Types a string of characters in order, or types a dojo.keys.* constant.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  robot.typeKeys(&amp;quot;dijit.ed&amp;quot;, 500);&lt;/code>&lt;/pre>
</example></examples></method><method name="keyPress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to press&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="modifiers" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the modifier keys being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>shift&lt;/li>
&lt;li>alt&lt;/li>
&lt;li>ctrl&lt;/li>
&lt;li>meta&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="asynchronous" type="Boolean" usage="required"><summary>&lt;p>If true, the delay happens asynchronously and immediately, outside of the browser&amp;#39;s JavaScript thread and any previous calls.
This is useful for interacting with the browser&amp;#39;s modal dialogs.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</summary><description>&lt;p>Types a key combination, like SHIFT-TAB.&lt;/p>
</description><examples><example>&lt;p>to press shift-tab immediately, call robot.keyPress(dojo.keys.TAB, 0, {shift: true})&lt;/p>
</example></examples></method><method name="keyDown" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to hold down
Warning: holding down a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Holds down a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to hold down the &amp;#39;a&amp;#39; key immediately, call robot.keyDown(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="keyUp" scope="normal" type="function" from="doh/robot"><parameters><parameter name="charOrCode" type="Integer" usage="required"><summary>&lt;p>char/JS keyCode/dojo.keys.* constant for the key you want to release
Warning: releasing a shifted key, like &amp;#39;A&amp;#39;, can have unpredictable results.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</summary><description>&lt;p>Releases a single key, like SHIFT or &amp;#39;a&amp;#39;.&lt;/p>
</description><examples><example>&lt;p>to release the &amp;#39;a&amp;#39; key immediately, call robot.keyUp(&amp;#39;a&amp;#39;)&lt;/p>
</example></examples></method><method name="mouseClick" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</summary><description>&lt;p>Convenience function to do a press/release.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mousePress" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"><summary>&lt;p>JSON object that represents all of the mouse buttons being pressed.
It takes the following Boolean attributes:

&lt;/p>
&lt;ul>
&lt;li>left&lt;/li>
&lt;li>middle&lt;/li>
&lt;li>right&lt;/li>
&lt;/ul>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter></parameters><return-types/><summary>&lt;p>Presses mouse buttons.&lt;/p>
</summary><description>&lt;p>Presses the mouse buttons you pass as true.
Example: to press the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.&lt;/p>
</description></method><method name="mouseMoveTo" scope="normal" type="function" from="doh/robot"><parameters><parameter name="point" type="Object" usage="required"><summary>&lt;p>x, y position relative to viewport, or if absolute == true, to document&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"/><parameter name="duration" type="Integer" usage="optional"/><parameter name="absolute" type="Boolean" usage="required"/></parameters><return-types/><summary>&lt;p>Move the mouse from the current position to the specified point.
Delays reading contents point until queued command starts running.
See mouseMove() for details.&lt;/p>
</summary></method><method name="mouseMove" scope="normal" type="function" from="doh/robot"><parameters><parameter name="x" type="Number" usage="required"><summary>&lt;p>x offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="y" type="Number" usage="required"><summary>&lt;p>y offset relative to the viewport, in pixels, to move the mouse.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>    robot.mouseClick({left: true}, 100) // first call; wait 100ms
    robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms. This also affects how many mousemove events will
be generated, which is the log of the duration.&lt;/p>
</summary></parameter><parameter name="absolute" type="Boolean" usage="required"><summary>&lt;p>Boolean indicating whether the x and y values are absolute coordinates.
If false, then mouseMove expects that the x,y will be relative to the window. (clientX/Y)
If true, then mouseMove expects that the x,y will be absolute. (pageX/Y)&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse to the specified x,y offset relative to the viewport.&lt;/p>
</summary></method><method name="mouseRelease" scope="normal" type="function" from="doh/robot"><parameters><parameter name="buttons" type="Object" usage="required"/><parameter name="delay" type="Integer" usage="optional"/></parameters><return-types/><summary>&lt;p>Releases mouse buttons.&lt;/p>
</summary><description>&lt;p>Releases the mouse buttons you pass as true.
Example: to release the left mouse button, pass {left: true}.
Mouse buttons you don&amp;#39;t specify keep their previous pressed state.
See robot.mousePress for more info.&lt;/p>
</description></method><method name="mouseWheel" scope="normal" type="function" from="doh/robot"><parameters><parameter name="wheelAmt" type="Number" usage="required"><summary>&lt;p>Number of notches to spin the wheel.
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer" usage="optional"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:
robot.mouseClick({left: true}, 100) // first call; wait 100ms
robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/p>
</summary></parameter><parameter name="duration" type="Integer" usage="optional"><summary>&lt;p>Approximate time Robot will spend moving the mouse
By default, the Robot will wheel the mouse as fast as possible.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Spins the mouse wheel.&lt;/p>
</summary><description>&lt;p>Spins the wheel wheelAmt &amp;quot;notches.&amp;quot;
Negative wheelAmt scrolls up/away from the user.
Positive wheelAmt scrolls down/toward the user.
Note: this will all happen in one event.
Warning: the size of one mouse wheel notch is an OS setting.
You can access this size from robot.mouseWheelSize&lt;/p>
</description></method><method name="setClipboard" scope="normal" type="function" from="doh/robot"><parameters><parameter name="data" type="String" usage="required"><summary>&lt;p>New clipboard content to set&lt;/p>
</summary></parameter><parameter name="format" type="String" usage="optional"><summary>&lt;p>Set this to &amp;quot;text/html&amp;quot; to put richtext to the clipboard.
Otherwise, data is treated as plaintext. By default, plaintext
is used.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set clipboard content.&lt;/p>
</summary><description>&lt;p>Set data as clipboard content, overriding anything already there. The
data will be put to the clipboard using the given format.&lt;/p>
</description></method><method name="_resolveNode" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="String||DOMNode||Function" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types/></method><method name="_position" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_getWindowChain" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="n" type="Node" usage="required"/></parameters><return-types><return-type type="Array"/></return-types></method><method name="scrollIntoView" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Number, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Scroll the passed node into view, if it is not.&lt;/p>
</summary></method><method name="mouseMoveAt" scope="normal" type="function" from="dojo/robot"><parameters><parameter name="node" type="String||DOMNode||Function" usage="required"><summary>&lt;p>The id of the node, or the node itself, to move the mouse to.
If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
This is useful if you need to move the mouse to an node that is not yet present.&lt;/p>
</summary></parameter><parameter name="delay" type="Integer, optional" usage="required"><summary>&lt;p>Delay, in milliseconds, to wait before firing.
The delay is a delta with respect to the previous automation call.
For example, the following code ends after 600ms:&lt;/p>
&lt;pre>&lt;code>  robot.mouseClick({left:true}, 100) // first call; wait 100ms
  robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all&lt;/code>&lt;/pre>
</summary></parameter><parameter name="duration" type="Integer, optional" usage="required"><summary>&lt;p>Approximate time Robot will spend moving the mouse
The default is 100ms.&lt;/p>
</summary></parameter><parameter name="offsetX" type="Number, optional" usage="required"><summary>&lt;p>x offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s width.&lt;/p>
</summary></parameter><parameter name="offsetY" type="Number, optional" usage="required"><summary>&lt;p>y offset relative to the node, in pixels, to move the mouse. The default is half the node&amp;#39;s height.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.&lt;/p>
</summary><description>&lt;p>Moves the mouse over the specified node at the specified relative x,y offset.
If you do not specify an offset, mouseMove will default to move to the middle of the node.
Example: to move the mouse over a ComboBox&amp;#39;s down arrow node, call doh.mouseMoveAt(dijit.byId(&amp;#39;setvaluetest&amp;#39;).downArrowNode);&lt;/p>
</description></method><method name="_updateDocument" scope="normal" type="function" from="dojo/robotx"><parameters/><return-types/><summary>&lt;p>Called every time a new page is loaded into the iframe, to setup variables
Point dojo.global, dojo.publish, etc. to refer to iframe.
Remove for 2.0?&lt;/p>
</summary></method><method name="initRobot" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="url" type="String" usage="required"><summary>&lt;p>URL to open. Any of the test&amp;#39;s dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Opens the application at the specified URL for testing, redirecting dojo to point to the application environment instead of the test environment.&lt;/p>
</summary></method><method name="waitForPageToLoad" scope="normal" type="function" from="dojo/robotx"><parameters><parameter name="submitActions" type="Function" usage="required"><summary>&lt;p>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
expecting these actions to create a page change (like a form submit).
After these actions execute and the resulting page loads, the next test will start.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</summary><description>&lt;p>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.&lt;/p>
</description><examples><example>&lt;pre>&lt;code>  runTest: function(){
    return waitForPageLoad(function(){ doh.robot.keyPress(keys.ENTER, 500); });
  }&lt;/code>&lt;/pre>
</example></examples></method></methods></object><object location="doh/main" type="object"><properties><property name="_line" scope="normal" type="string" from="doh/runner"/><property name="debug" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="error" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_testCount" scope="normal" type="number" from="doh/runner"/><property name="_groupCount" scope="normal" type="number" from="doh/runner"/><property name="_errorCount" scope="normal" type="number" from="doh/runner"/><property name="_failureCount" scope="normal" type="number" from="doh/runner"/><property name="_currentGroup" scope="normal" type="null" from="doh/runner"/><property name="_currentTest" scope="normal" type="null" from="doh/runner"/><property name="_paused" scope="normal" type="boolean" from="doh/runner"/><property name="_init" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_groups" scope="normal" type="object" from="doh/runner"/><property name="_testTypes" scope="normal" type="object" from="doh/runner"/><property name="registerUrl" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="_setupGroupForRun" scope="normal" type="undefined" from="doh/_browserRunner"/><property name="isBrowser" scope="normal" type="boolean" from="doh/_browserRunner"/><property name="_initRobotCalled" scope="normal" type="boolean" from="doh/robot"/><property name="robot" scope="normal" type="object" from="doh/robot"/></properties><methods><method name="_AssertFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="msg" type="undefined" usage="required"/><parameter name="hint" type="undefined" usage="required"/></parameters><return-types/></method><method name="Deferred" scope="normal" type="function" from="doh/runner"><parameters><parameter name="canceller" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerTestType" scope="normal" type="function" from="doh/runner"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The name of the type.&lt;/p>
</summary></parameter><parameter name="initProc" type="Function" usage="required"><summary>&lt;p>Type specific test initializer; called after the test object is created.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Adds a test type and associates a function used to initialize each test of the given type&lt;/p>
</summary></method><method name="_testRegistered" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_groupStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="_groupFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testStarted" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="_testFinished" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="g" type="undefined" usage="required"/><parameter name="f" type="undefined" usage="required"/><parameter name="s" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"><summary>&lt;p>string name of the group to add the test to&lt;/p>
</summary></parameter><parameter name="test" type="Function||String||Object" usage="required"><summary>&lt;p>TODOC&lt;/p>
</summary></parameter><parameter name="type" type="String" usage="optional"><summary>&lt;p>An identifier denoting the type of testing that the test performs, such
as a performance test. If falsy, defaults to test.type.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>add the provided test function or fixture object to the specified
test group.&lt;/p>
</summary></method><method name="_registerTestAndCheck" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupId" type="undefined" usage="required"/><parameter name="test" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="testArgPosition" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/><parameter name="setUp" type="undefined" usage="required"/><parameter name="tearDown" type="undefined" usage="required"/></parameters><return-types/></method><method name="_registerUrl" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="url" type="undefined" usage="required"/><parameter name="timeout" type="undefined" usage="required"/><parameter name="type" type="undefined" usage="required"/><parameter name="dohArgs" type="undefined" usage="required"/></parameters><return-types/></method><method name="register" scope="normal" type="function" from="doh/runner"><parameters><parameter name="a1" type="undefined" usage="required"/><parameter name="a2" type="undefined" usage="required"/><parameter name="a3" type="undefined" usage="required"/><parameter name="a4" type="undefined" usage="required"/><parameter name="a5" type="undefined" usage="required"/></parameters><return-types/></method><method name="registerDocTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="module" type="undefined" usage="required"><summary>&lt;p>dojo/uacss&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get all the doctests from the given module and register each of them
as a single test case here.&lt;/p>
</summary></method><method name="registerTest" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="test" type="Array||Function||Object" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, test) instead&lt;/p>
</summary></method><method name="registerGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="tests" type="Array||Function||Object" usage="required"/><parameter name="setUp" type="Function" usage="required"/><parameter name="tearDown" type="Function" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, tests, setUp, tearDown) instead&lt;/p>
</summary></method><method name="registerTestNs" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="ns" type="Object" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group, ns) instead&lt;/p>
</summary></method><method name="registerTests" scope="normal" type="function" from="doh/runner"><parameters><parameter name="group" type="String" usage="required"/><parameter name="testArr" type="Array" usage="required"/><parameter name="type" type="String" usage="required"/></parameters><return-types/><summary>&lt;p>Deprecated.  Use doh.register(group/type, testArr) instead&lt;/p>
</summary></method><method name="assertTrue" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="t" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;truthy&amp;quot;?&lt;/p>
</summary></method><method name="assertFalse" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="f" scope="normal" type="function" from="doh/runner"><parameters><parameter name="condition" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>is the passed item &amp;quot;falsey&amp;quot;?&lt;/p>
</summary></method><method name="assertError" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="e" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expectedError" type="Error object" usage="required"/><parameter name="scope" type="Object" usage="required"/><parameter name="functionName" type="String" usage="required"/><parameter name="args" type="Array" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>Test for a certain error to be thrown by the given function.&lt;/p>
</summary><examples><example>&lt;p>t.assertError(dojox.data.QueryReadStore.InvalidAttributeError, store, &amp;quot;getValue&amp;quot;, [item, &amp;quot;NOT THERE&amp;quot;]);
t.assertError(dojox.data.QueryReadStore.InvalidItemError, store, &amp;quot;getValue&amp;quot;, [&amp;quot;not an item&amp;quot;, &amp;quot;NOT THERE&amp;quot;]);&lt;/p>
</example></examples></method><method name="assertEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="is" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/><parameter name="doNotThrow" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>are the passed expected and actual objects/values deeply
equivalent?&lt;/p>
</summary></method><method name="assertNotEqual" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="isNot" scope="normal" type="function" from="doh/runner"><parameters><parameter name="notExpected" type="Object" usage="required"/><parameter name="actual" type="Object" usage="required"/><parameter name="hint" type="String" usage="optional"/></parameters><return-types/><summary>&lt;p>are the passed notexpected and actual objects/values deeply
not equivalent?&lt;/p>
</summary></method><method name="_arrayEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_objPropEq" scope="normal" type="function" from="doh/runner"><parameters><parameter name="expected" type="undefined" usage="required"/><parameter name="actual" type="undefined" usage="required"/></parameters><return-types/></method><method name="_handleFailure" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_runPerfFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The test group that contains this performance test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The performance test fixture.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function handles how to execute a &amp;#39;performance&amp;#39; test
which is different from a straight UT style test.  These
will often do numerous iterations of the same operation and
gather execution statistics about it, like max, min, average,
etc.  It makes use of the already in place DOH deferred test
handling since it is a good idea to put a pause in between each
iteration to allow for GC cleanup and the like.&lt;/p>
</summary></method><method name="_calcTrialIterations" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture we want to calculate iterations for.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This function determines the rough number of iterations to
use to reach a particular MS threshold.  This returns a deferred
since tests can theoretically by async.  Async tests aren&amp;#39;t going to
give great perf #s, though.
The callback is passed the # of iterations to hit the requested
threshold.&lt;/p>
</summary></method><method name="_runRegFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"><summary>&lt;p>The groupName of the test.&lt;/p>
</summary></parameter><parameter name="fixture" type="Object" usage="required"><summary>&lt;p>The test fixture to execute.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Function to run a generic doh test.  These are not
specialized tests, like performance groups and such.&lt;/p>
</summary></method><method name="_runFixture" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/></parameters><return-types/></method><method name="runGroup" scope="normal" type="function" from="doh/runner"><parameters><parameter name="groupName" type="String" usage="required"/><parameter name="idx" type="Integer" usage="required"/></parameters><return-types/><summary>&lt;p>runs the specified test group&lt;/p>
</summary></method><method name="_onEnd" scope="normal" type="function" from="dojo/tests"><parameters/><return-types/></method><method name="_report" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="togglePaused" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="pause" scope="normal" type="function" from="doh/runner"><parameters/><return-types/><summary>&lt;p>halt test run. Can be resumed.&lt;/p>
</summary></method><method name="run" scope="normal" type="function" from="doh/robot"><parameters/><return-types/></method><method name="runOnLoad" scope="normal" type="function" from="doh/runner"><parameters/><return-types/></method><method name="_jumpToLog" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_jumpToSuite" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="e" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateTestList" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="group" type="undefined" usage="required"/><parameter name="fixture" type="undefined" usage="required"/><parameter name="unwindingBacklog" type="undefined" usage="required"/></parameters><return-types/></method><method name="_updateGlobalProgressBar" scope="normal" type="function" from="doh/_browserRunner"><parameters><parameter name="p" type="undefined" usage="required"/><parameter name="success" type="undefined" usage="required"/><parameter name="group" type="undefined" usage="required"/></parameters><return-types/></method><method name="showTestPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showLogPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="showPerfTestsPage" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method><method name="toggleRunAll" scope="normal" type="function" from="doh/_browserRunner"><parameters/><return-types/></method></methods><summary>&lt;p>Functions for registering and running automated tests.&lt;/p>
</summary></object><object location="dojo/router/RouterBase" type="constructor" classlike="true"><properties><property name="_routes" scope="prototype" type="null" from="dojo/router/RouterBase"/><property name="_routeIndex" scope="prototype" type="null" from="dojo/router/RouterBase"/><property name="_started" scope="prototype" type="boolean" from="dojo/router/RouterBase"/><property name="_currentPath" scope="prototype" type="string" from="dojo/router/RouterBase"/><property name="idMatch" scope="prototype" type="RegExp" from="dojo/router/RouterBase"/><property name="idReplacement" scope="prototype" type="string" from="dojo/router/RouterBase"/><property name="globMatch" scope="prototype" type="RegExp" from="dojo/router/RouterBase"/><property name="globReplacement" scope="prototype" type="string" from="dojo/router/RouterBase"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="kwArgs" type="undefined" usage="required"/></parameters><return-types/></method><method name="register" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="route" type="String|RegExp" usage="required"><summary>&lt;p>A string or regular expression which will be used when
monitoring hash changes.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="required"><summary>&lt;p>When the hash matches a pattern as described in the route,
this callback will be executed. It will receive an event
object that will have several properties:

&lt;/p>
&lt;ul>
&lt;li>params: Either an array or object of properties pulled
from the new hash&lt;/li>
&lt;li>oldPath: The hash in its state before the change&lt;/li>
&lt;li>newPath: The new hash being shifted to&lt;/li>
&lt;li>preventDefault: A method that will stop hash changes
from being actually applied to the active hash. This only
works if the hash change was initiated using &lt;code>router.go&lt;/code>,
as changes initiated more directly to the location.hash
property will already be in place&lt;/li>
&lt;li>stopImmediatePropagation: When called, will stop any
further bound callbacks on this particular route from
being executed. If two distinct routes are bound that are
different, but both happen to match the current hash in
some way, this will &lt;em>not&lt;/em> keep other routes from receiving
notice of the change.&lt;/li>
&lt;/ul>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><return-description>A plain JavaScript object to be used as a handle for
either removing this specific callback's registration, as
well as to add new callbacks with the same route initially
used.</return-description><summary>&lt;p>Registers a route to a handling callback&lt;/p>
</summary><description>&lt;p>Given either a string or a regular expression, the router
will monitor the page&amp;#39;s hash and respond to changes that
match the string or regex as provided.

&lt;/p>
&lt;p>When provided a regex for the route:

&lt;/p>
&lt;ul>
&lt;li>Matching is performed, and the resulting capture groups
are passed through to the callback as an array.&lt;/li>
&lt;/ul>
&lt;p>When provided a string for the route:

&lt;/p>
&lt;ul>
&lt;li>The string is parsed as a URL-like structure, like
&amp;quot;/foo/bar&amp;quot;&lt;/li>
&lt;li>If any portions of that URL are prefixed with a colon
(:), they will be parsed out and provided to the callback
as properties of an object.&lt;/li>
&lt;li>If the last piece of the URL-like structure is prefixed
with a star (*) instead of a colon, it will be replaced in
the resulting regex with a greedy (.+) match and
anything remaining on the hash will be provided as a
property on the object passed into the callback. Think of
it like a basic means of globbing the end of a route.&lt;/li>
&lt;/ul>
</description><examples><example>&lt;pre>&lt;code>  router.register(&amp;quot;/foo/:bar/*baz&amp;quot;, function(object){
    // If the hash was &amp;quot;/foo/abc/def/ghi&amp;quot;,
    // object.bar === &amp;quot;abc&amp;quot;
    // object.baz === &amp;quot;def/ghi&amp;quot;
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="registerBefore" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="route" type="String|RegExp" usage="required"/><parameter name="callback" type="Function" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Registers a route to a handling callback, except before
any previously registered callbacks&lt;/p>
</summary><description>&lt;p>Much like the &lt;code>register&lt;/code> method, &lt;code>registerBefore&lt;/code> allows
us to register route callbacks to happen before any
previously registered callbacks. See the documentation for
&lt;code>register&lt;/code> for more details and examples.&lt;/p>
</description></method><method name="go" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="path" type="undefined" usage="required"/><parameter name="replace" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>A simple pass-through to make changing the hash easy,
without having to require dojo/hash directly. It also
synchronously fires off any routes that match.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  router.go(&amp;quot;/foo/bar&amp;quot;);&lt;/code>&lt;/pre>
</example></examples></method><method name="startup" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters/><return-types/><summary>&lt;p>This method must be called to activate the router. Until
startup is called, no hash changes will trigger route
callbacks.&lt;/p>
</summary></method><method name="_handlePathChange" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="newPath" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="_convertRouteToRegExp" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="route" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method><method name="_getParameterNames" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="route" type="undefined" usage="required"/></parameters><return-types><return-type type="null"/></return-types></method><method name="_indexRoutes" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters/><return-types/></method><method name="_registerRoute" scope="prototype" type="function" from="dojo/router/RouterBase"><parameters><parameter name="route" type="String|RegExp" usage="required"/><parameter name="callback" type="Function" usage="required"/><parameter name="isBefore" type="Boolean" usage="optional"/></parameters><return-types><return-type type="Object"/></return-types></method></methods><parameters><parameter name="kwArgs" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>A module that allows one to easily map hash-based structures into
callbacks. The router module is a singleton, offering one central
point for all registrations of this type.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var router = new RouterBase({});
  router.register(&amp;quot;/widgets/:id&amp;quot;, function(evt){
    // If &amp;quot;/widgets/3&amp;quot; was matched,
    // evt.params.id === &amp;quot;3&amp;quot;
    xhr.get({
      url: &amp;quot;/some/path/&amp;quot; + evt.params.id,
      load: function(data){
        // ...
      }
    });
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/router" type="object"><properties/><methods/><summary>&lt;p>A singleton-style instance of dojo/router/RouterBase. See that
module for specifics.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  router.register(&amp;quot;/widgets/:id&amp;quot;, function(evt){
    // If &amp;quot;/widgets/3&amp;quot; was matched,
    // evt.params.id === &amp;quot;3&amp;quot;
    xhr.get({
      url: &amp;quot;/some/path/&amp;quot; + evt.params.id,
      load: function(data){
        // ...
      }
    });
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/rpc/JsonService" type="constructor" classlike="true" superclass="dojo/rpc/RpcService"><properties><property name="bustCache" scope="prototype" type="boolean" from="dojo/rpc/JsonService"/><property name="contentType" scope="prototype" type="string" from="dojo/rpc/JsonService"/><property name="lastSubmissionId" scope="prototype" type="number" from="dojo/rpc/JsonService"/><property name="strictArgChecks" scope="prototype" type="boolean" from="dojo/rpc/RpcService"/><property name="serviceUrl" scope="prototype" type="string" from="dojo/rpc/RpcService"/></properties><methods><method name="callRemote" scope="prototype" type="function" from="dojo/rpc/JsonService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>the name of the remote method you want to call.&lt;/p>
</summary></parameter><parameter name="params" type="array" usage="required"><summary>&lt;p>array of parameters to pass to method&lt;/p>
</summary></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>call an arbitrary remote method without requiring it to be
predefined with SMD&lt;/p>
</summary></method><method name="bind" scope="prototype" type="function" from="dojo/rpc/JsonService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are calling&lt;/p>
</summary></parameter><parameter name="parameters" type="array" usage="required"><summary>&lt;p>The parameters we are passing off to the method&lt;/p>
</summary></parameter><parameter name="deferredRequestHandler" type="deferred" usage="required"><summary>&lt;p>The Deferred object for this particular request&lt;/p>
</summary></parameter><parameter name="url" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>JSON-RPC bind method. Takes remote method, parameters,
deferred, and a url, calls createRequest to make a JSON-RPC
envelope and passes that off with bind.&lt;/p>
</summary></method><method name="createRequest" scope="prototype" type="function" from="dojo/rpc/JsonService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are creating the request for&lt;/p>
</summary></parameter><parameter name="params" type="dojo/_base/array" usage="required"><summary>&lt;p>The array of parameters for this request;&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>create a JSON-RPC envelope for the request&lt;/p>
</summary></method><method name="parseResults" scope="prototype" type="function" from="dojo/rpc/JsonService"><parameters><parameter name="obj" type="Object" usage="required"><summary>&lt;p>Object containing envelope of data we receive from the server&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/><return-type type="Object"/></return-types><return-description>&lt;p>Object containing envelope of data we receive from the server&lt;/p>
</return-description><summary>&lt;p>parse the result envelope and pass the results back to
the callback function&lt;/p>
</summary></method><method name="constructor" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="args" type="object" usage="required"><summary>&lt;p>Takes a number of properties as kwArgs for defining the service.  It also
accepts a string.  When passed a string, it is treated as a url from
which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
object.  It accepts serviceUrl, to manually define a url for the rpc service
allowing the rpc system to be used without an smd definition. strictArgChecks
forces the system to verify that the # of arguments provided in a call
matches those defined in the smd.  smdString allows a developer to pass
a jsonString directly, which will be converted into an object or alternatively
smdObject is accepts an smdObject directly.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
as a definition for the service
&lt;/p>
</summary></method><method name="errorCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>create callback that calls the Deferred errback method&lt;/p>
</summary></method><method name="resultCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>create callback that calls the Deferred&amp;#39;s callback method&lt;/p>
</summary></method><method name="generateMethod" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are generating&lt;/p>
</summary></parameter><parameter name="parameters" type="dojo/_base/array" usage="required"><summary>&lt;p>the array of parameters for this call.&lt;/p>
</summary></parameter><parameter name="url" type="string" usage="required"><summary>&lt;p>the service url for this call&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>generate the local bind methods for the remote object&lt;/p>
</summary></method><method name="processSmd" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="object" type="undefined" usage="required"><summary>&lt;p>smd object defining this service.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>callback method for receipt of a smd object.  Parse the smd
and generate functions based on the description&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/rpc/RpcService"/></mixins><parameters><parameter name="args" type="object" usage="required"><summary>&lt;p>Takes a number of properties as kwArgs for defining the service.  It also
accepts a string.  When passed a string, it is treated as a url from
which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
object.  It accepts serviceUrl, to manually define a url for the rpc service
allowing the rpc system to be used without an smd definition. strictArgChecks
forces the system to verify that the # of arguments provided in a call
matches those defined in the smd.  smdString allows a developer to pass
a jsonString directly, which will be converted into an object or alternatively
smdObject is accepts an smdObject directly.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/rpc/RpcService" type="constructor" classlike="true"><properties><property name="strictArgChecks" scope="prototype" type="boolean" from="dojo/rpc/RpcService"/><property name="serviceUrl" scope="prototype" type="string" from="dojo/rpc/RpcService"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="args" type="object" usage="required"><summary>&lt;p>Takes a number of properties as kwArgs for defining the service.  It also
accepts a string.  When passed a string, it is treated as a url from
which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
object.  It accepts serviceUrl, to manually define a url for the rpc service
allowing the rpc system to be used without an smd definition. strictArgChecks
forces the system to verify that the # of arguments provided in a call
matches those defined in the smd.  smdString allows a developer to pass
a jsonString directly, which will be converted into an object or alternatively
smdObject is accepts an smdObject directly.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
as a definition for the service
&lt;/p>
</summary></method><method name="parseResults" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="obj" type="Object" usage="required"><summary>&lt;p>Object that is the return results from an rpc request&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Object that is the return results from an rpc request&lt;/p>
</return-description><summary>&lt;p>parse the results coming back from an rpc request.  this
base implementation, just returns the full object
subclasses should parse and only return the actual results&lt;/p>
</summary></method><method name="errorCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>create callback that calls the Deferred errback method&lt;/p>
</summary></method><method name="resultCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>create callback that calls the Deferred&amp;#39;s callback method&lt;/p>
</summary></method><method name="generateMethod" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are generating&lt;/p>
</summary></parameter><parameter name="parameters" type="dojo/_base/array" usage="required"><summary>&lt;p>the array of parameters for this call.&lt;/p>
</summary></parameter><parameter name="url" type="string" usage="required"><summary>&lt;p>the service url for this call&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>generate the local bind methods for the remote object&lt;/p>
</summary></method><method name="processSmd" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="object" type="undefined" usage="required"><summary>&lt;p>smd object defining this service.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>callback method for receipt of a smd object.  Parse the smd
and generate functions based on the description&lt;/p>
</summary></method></methods><parameters><parameter name="args" type="object" usage="required"><summary>&lt;p>Takes a number of properties as kwArgs for defining the service.  It also
accepts a string.  When passed a string, it is treated as a url from
which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
object.  It accepts serviceUrl, to manually define a url for the rpc service
allowing the rpc system to be used without an smd definition. strictArgChecks
forces the system to verify that the # of arguments provided in a call
matches those defined in the smd.  smdString allows a developer to pass
a jsonString directly, which will be converted into an object or alternatively
smdObject is accepts an smdObject directly.
&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>TODOC&lt;/p>
</summary></object><object location="dojo/rpc/JsonpService" type="constructor" classlike="true" superclass="dojo/rpc/RpcService"><properties><property name="strictArgChecks" scope="prototype" type="boolean" from="dojo/rpc/JsonpService"/><property name="serviceUrl" scope="prototype" type="string" from="dojo/rpc/RpcService"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/rpc/JsonpService"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="requiredArgs" type="undefined" usage="required"/></parameters><return-types/></method><method name="bind" scope="prototype" type="function" from="dojo/rpc/JsonpService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are calling&lt;/p>
</summary></parameter><parameter name="parameters" type="dojo/_base/array" usage="required"><summary>&lt;p>The parameters we are passing off to the method&lt;/p>
</summary></parameter><parameter name="deferredRequestHandler" type="deferred" usage="required"><summary>&lt;p>The Deferred object for this particular request&lt;/p>
</summary></parameter><parameter name="url" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>JSONP bind method. Takes remote method, parameters,
deferred, and a url, calls createRequest to make a JSON-RPC
envelope and passes that off with bind.&lt;/p>
</summary></method><method name="createRequest" scope="prototype" type="function" from="dojo/rpc/JsonpService"><parameters><parameter name="parameters" type="undefined" usage="required"/></parameters><return-types><return-type type="object"/></return-types><summary>&lt;p>create a JSONP req&lt;/p>
</summary></method><method name="parseResults" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="obj" type="Object" usage="required"><summary>&lt;p>Object that is the return results from an rpc request&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>&lt;p>Object that is the return results from an rpc request&lt;/p>
</return-description><summary>&lt;p>parse the results coming back from an rpc request.  this
base implementation, just returns the full object
subclasses should parse and only return the actual results&lt;/p>
</summary></method><method name="errorCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="function"/></return-types><summary>&lt;p>create callback that calls the Deferred errback method&lt;/p>
</summary></method><method name="resultCallback" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="deferredRequestHandler" type="dojo/_base/Deferred" usage="required"><summary>&lt;p>The deferred object handling a request.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>create callback that calls the Deferred&amp;#39;s callback method&lt;/p>
</summary></method><method name="generateMethod" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="method" type="string" usage="required"><summary>&lt;p>The name of the method we are generating&lt;/p>
</summary></parameter><parameter name="parameters" type="dojo/_base/array" usage="required"><summary>&lt;p>the array of parameters for this call.&lt;/p>
</summary></parameter><parameter name="url" type="string" usage="required"><summary>&lt;p>the service url for this call&lt;/p>
</summary></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>generate the local bind methods for the remote object&lt;/p>
</summary></method><method name="processSmd" scope="prototype" type="function" from="dojo/rpc/RpcService"><parameters><parameter name="object" type="undefined" usage="required"><summary>&lt;p>smd object defining this service.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>callback method for receipt of a smd object.  Parse the smd
and generate functions based on the description&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/rpc/RpcService"/></mixins><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="requiredArgs" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Generic JSONP service.  Minimally extends RpcService to allow
easy definition of nearly any JSONP style service. Example
SMD files exist in dojox.data&lt;/p>
</summary></object><object location="dojo/selector/acme" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/selector/acme"><parameters><parameter name="query" type="String" usage="required"><summary>&lt;p>The CSS3 expression to match against. For details on the syntax of
CSS3 selectors, see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#selectors&quot;>http://www.w3.org/TR/css3-selectors/#selectors&lt;/a>&lt;/p>
</summary></parameter><parameter name="root" type="String|DOMNode" usage="optional"><summary>&lt;p>A DOMNode (or node id) to scope the search from. Optional.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns nodes which match the given CSS3 selector, searching the
entire document by default but optionally taking a node to scope
the search by. Returns an array.&lt;/p>
</summary><description>&lt;p>dojo.query() is the swiss army knife of DOM node manipulation in
Dojo. Much like Prototype&amp;#39;s &amp;quot;$$&amp;quot; (bling-bling) function or JQuery&amp;#39;s
&amp;quot;$&amp;quot; function, dojo.query provides robust, high-performance
CSS-based node selector support with the option of scoping searches
to a particular sub-tree of a document.

&lt;/p>
&lt;h2>Supported Selectors:&lt;/h2>
&lt;p>acme supports a rich set of CSS3 selectors, including:

&lt;/p>
&lt;ul>
&lt;li>class selectors (e.g., &lt;code>.foo&lt;/code>)&lt;/li>
&lt;li>node type selectors like &lt;code>span&lt;/code>&lt;/li>
&lt;li>&lt;code> &lt;/code> descendant selectors&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> child element selectors&lt;/li>
&lt;li>&lt;code>#foo&lt;/code> style ID selectors&lt;/li>
&lt;li>&lt;code>*&lt;/code> universal selector&lt;/li>
&lt;li>&lt;code>~&lt;/code>, the preceded-by sibling selector&lt;/li>
&lt;li>&lt;code>+&lt;/code>, the immediately preceded-by sibling selector&lt;/li>
&lt;li>attribute queries:&lt;/li>
&lt;li>&lt;code>[foo]&lt;/code> attribute presence selector&lt;/li>
&lt;li>&lt;code>[foo=&amp;#39;bar&amp;#39;]&lt;/code> attribute value exact match&lt;/li>
&lt;li>&lt;code>[foo~=&amp;#39;bar&amp;#39;]&lt;/code> attribute value list item match&lt;/li>
&lt;li>&lt;code>[foo^=&amp;#39;bar&amp;#39;]&lt;/code> attribute start match&lt;/li>
&lt;li>&lt;code>[foo$=&amp;#39;bar&amp;#39;]&lt;/code> attribute end match&lt;/li>
&lt;li>&lt;code>[foo*=&amp;#39;bar&amp;#39;]&lt;/code> attribute substring match&lt;/li>
&lt;li>&lt;code>:first-child&lt;/code>, &lt;code>:last-child&lt;/code>, and &lt;code>:only-child&lt;/code> positional selectors&lt;/li>
&lt;li>&lt;code>:empty&lt;/code> content emtpy selector&lt;/li>
&lt;li>&lt;code>:checked&lt;/code> pseudo selector&lt;/li>
&lt;li>&lt;code>:nth-child(n)&lt;/code>, &lt;code>:nth-child(2n+1)&lt;/code> style positional calculations&lt;/li>
&lt;li>&lt;code>:nth-child(even)&lt;/code>, &lt;code>:nth-child(odd)&lt;/code> positional selectors&lt;/li>
&lt;li>&lt;code>:not(...)&lt;/code> negation pseudo selectors&lt;/li>
&lt;/ul>
&lt;p>Any legal combination of these selectors will work with
&lt;code>dojo.query()&lt;/code>, including compound selectors (&amp;quot;,&amp;quot; delimited).
Very complex and useful searches can be constructed with this
palette of selectors and when combined with functions for
manipulation presented by dojo/NodeList, many types of DOM
manipulation operations become very straightforward.

&lt;/p>
&lt;h2>Unsupported Selectors:&lt;/h2>
&lt;p>While dojo.query handles many CSS3 selectors, some fall outside of
what&amp;#39;s reasonable for a programmatic node querying engine to
handle. Currently unsupported selectors include:

&lt;/p>
&lt;ul>
&lt;li>namespace-differentiated selectors of any form&lt;/li>
&lt;li>all &lt;code>::&lt;/code> pseduo-element selectors&lt;/li>
&lt;li>certain pseudo-selectors which don&amp;#39;t get a lot of day-to-day use:&lt;/li>
&lt;li>&lt;code>:root&lt;/code>, &lt;code>:lang()&lt;/code>, &lt;code>:target&lt;/code>, &lt;code>:focus&lt;/code>&lt;/li>
&lt;li>all visual and state selectors:&lt;/li>
&lt;li>&lt;code>:root&lt;/code>, &lt;code>:active&lt;/code>, &lt;code>:hover&lt;/code>, &lt;code>:visited&lt;/code>, &lt;code>:link&lt;/code>,
&lt;code>:enabled&lt;/code>, &lt;code>:disabled&lt;/code>&lt;/li>
&lt;li>&lt;code>:*-of-type&lt;/code> pseudo selectors&lt;/li>
&lt;/ul>
&lt;h2>dojo.query and XML Documents:&lt;/h2>
&lt;p>&lt;code>dojo.query&lt;/code> (as of dojo 1.2) supports searching XML documents
in a case-sensitive manner. If an HTML document is served with
a doctype that forces case-sensitivity (e.g., XHTML 1.1
Strict), dojo.query() will detect this and &amp;quot;do the right
thing&amp;quot;. Case sensitivity is dependent upon the document being
searched and not the query used. It is therefore possible to
use case-sensitive queries on strict sub-documents (iframes,
etc.) or XML documents while still assuming case-insensitivity
for a host/root document.

&lt;/p>
&lt;h2>Non-selector Queries:&lt;/h2>
&lt;p>If something other than a String is passed for the query,
&lt;code>dojo.query&lt;/code> will return a new &lt;code>dojo/NodeList&lt;/code> instance
constructed from that parameter alone and all further
processing will stop. This means that if you have a reference
to a node or NodeList, you can quickly construct a new NodeList
from the original by calling &lt;code>dojo.query(node)&lt;/code> or
&lt;code>dojo.query(list)&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>search the entire document for elements with the class &amp;quot;foo&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>these elements will match:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;span class=&amp;quot;foo bar&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;p class=&amp;quot;thud foo&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>search the entire document for elements with the classes &amp;quot;foo&amp;quot; &lt;em>and&lt;/em> &amp;quot;bar&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo.bar&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>these elements will match:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo bar&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code>&lt;/pre>
&lt;p>while these will not:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;p class=&amp;quot;thud foo&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>find &lt;code>&amp;lt;span&amp;gt;&lt;/code> elements which are descendants of paragraphs and
which have a &amp;quot;highlighted&amp;quot; class:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;p span.highlighted&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>the innermost span in this fragment matches:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;p class=&amp;quot;foo&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;...
      &amp;lt;span class=&amp;quot;highlighted foo bar&amp;quot;&amp;gt;...&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
  &amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>set an &amp;quot;odd&amp;quot; class on all odd table rows inside of the table
&lt;code>#tabular_data&lt;/code>, using the &lt;code>&amp;gt;&lt;/code> (direct child) selector to avoid
affecting any nested tables:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;#tabular_data &amp;gt; tbody &amp;gt; tr:nth-child(odd)&amp;quot;).addClass(&amp;quot;odd&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>remove all elements with the class &amp;quot;error&amp;quot; from the document
and store them in a list:&lt;/p>
&lt;pre>&lt;code>  var errors = dojo.query(&amp;quot;.error&amp;quot;).orphan();&lt;/code>&lt;/pre>
</example><example>&lt;p>add an onclick handler to every submit button in the document
which causes the form to be sent via Ajax instead:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;input[type=&amp;#39;submit&amp;#39;]&amp;quot;).onclick(function(e){
    dojo.stopEvent(e); // prevent sending the form
    var btn = e.target;
    dojo.xhrPost({
      form: btn.form,
      load: function(data){
        // replace the form with the response
        var div = dojo.doc.createElement(&amp;quot;div&amp;quot;);
        dojo.place(div, btn.form, &amp;quot;after&amp;quot;);
        div.innerHTML = data;
        dojo.style(btn.form, &amp;quot;display&amp;quot;, &amp;quot;none&amp;quot;);
      }
    });
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="filter" scope="normal" type="function" from="dojo/selector/acme"><parameters><parameter name="nodeList" type="Node[]" usage="required"/><parameter name="filter" type="String" usage="required"/><parameter name="root" type="String|DOMNode" usage="optional"/></parameters><return-types/><summary>&lt;p>function for filtering a NodeList based on a selector, optimized for simple selectors&lt;/p>
</summary></method></methods><parameters><parameter name="query" type="String" usage="required"><summary>&lt;p>The CSS3 expression to match against. For details on the syntax of
CSS3 selectors, see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#selectors&quot;>http://www.w3.org/TR/css3-selectors/#selectors&lt;/a>&lt;/p>
</summary></parameter><parameter name="root" type="String|DOMNode" usage="optional"><summary>&lt;p>A DOMNode (or node id) to scope the search from. Optional.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Array"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns nodes which match the given CSS3 selector, searching the
entire document by default but optionally taking a node to scope
the search by. Returns an array.&lt;/p>
</summary><description>&lt;p>dojo.query() is the swiss army knife of DOM node manipulation in
Dojo. Much like Prototype&amp;#39;s &amp;quot;$$&amp;quot; (bling-bling) function or JQuery&amp;#39;s
&amp;quot;$&amp;quot; function, dojo.query provides robust, high-performance
CSS-based node selector support with the option of scoping searches
to a particular sub-tree of a document.

&lt;/p>
&lt;h2>Supported Selectors:&lt;/h2>
&lt;p>acme supports a rich set of CSS3 selectors, including:

&lt;/p>
&lt;ul>
&lt;li>class selectors (e.g., &lt;code>.foo&lt;/code>)&lt;/li>
&lt;li>node type selectors like &lt;code>span&lt;/code>&lt;/li>
&lt;li>&lt;code> &lt;/code> descendant selectors&lt;/li>
&lt;li>&lt;code>&amp;gt;&lt;/code> child element selectors&lt;/li>
&lt;li>&lt;code>#foo&lt;/code> style ID selectors&lt;/li>
&lt;li>&lt;code>*&lt;/code> universal selector&lt;/li>
&lt;li>&lt;code>~&lt;/code>, the preceded-by sibling selector&lt;/li>
&lt;li>&lt;code>+&lt;/code>, the immediately preceded-by sibling selector&lt;/li>
&lt;li>attribute queries:&lt;/li>
&lt;li>&lt;code>[foo]&lt;/code> attribute presence selector&lt;/li>
&lt;li>&lt;code>[foo=&amp;#39;bar&amp;#39;]&lt;/code> attribute value exact match&lt;/li>
&lt;li>&lt;code>[foo~=&amp;#39;bar&amp;#39;]&lt;/code> attribute value list item match&lt;/li>
&lt;li>&lt;code>[foo^=&amp;#39;bar&amp;#39;]&lt;/code> attribute start match&lt;/li>
&lt;li>&lt;code>[foo$=&amp;#39;bar&amp;#39;]&lt;/code> attribute end match&lt;/li>
&lt;li>&lt;code>[foo*=&amp;#39;bar&amp;#39;]&lt;/code> attribute substring match&lt;/li>
&lt;li>&lt;code>:first-child&lt;/code>, &lt;code>:last-child&lt;/code>, and &lt;code>:only-child&lt;/code> positional selectors&lt;/li>
&lt;li>&lt;code>:empty&lt;/code> content emtpy selector&lt;/li>
&lt;li>&lt;code>:checked&lt;/code> pseudo selector&lt;/li>
&lt;li>&lt;code>:nth-child(n)&lt;/code>, &lt;code>:nth-child(2n+1)&lt;/code> style positional calculations&lt;/li>
&lt;li>&lt;code>:nth-child(even)&lt;/code>, &lt;code>:nth-child(odd)&lt;/code> positional selectors&lt;/li>
&lt;li>&lt;code>:not(...)&lt;/code> negation pseudo selectors&lt;/li>
&lt;/ul>
&lt;p>Any legal combination of these selectors will work with
&lt;code>dojo.query()&lt;/code>, including compound selectors (&amp;quot;,&amp;quot; delimited).
Very complex and useful searches can be constructed with this
palette of selectors and when combined with functions for
manipulation presented by dojo/NodeList, many types of DOM
manipulation operations become very straightforward.

&lt;/p>
&lt;h2>Unsupported Selectors:&lt;/h2>
&lt;p>While dojo.query handles many CSS3 selectors, some fall outside of
what&amp;#39;s reasonable for a programmatic node querying engine to
handle. Currently unsupported selectors include:

&lt;/p>
&lt;ul>
&lt;li>namespace-differentiated selectors of any form&lt;/li>
&lt;li>all &lt;code>::&lt;/code> pseduo-element selectors&lt;/li>
&lt;li>certain pseudo-selectors which don&amp;#39;t get a lot of day-to-day use:&lt;/li>
&lt;li>&lt;code>:root&lt;/code>, &lt;code>:lang()&lt;/code>, &lt;code>:target&lt;/code>, &lt;code>:focus&lt;/code>&lt;/li>
&lt;li>all visual and state selectors:&lt;/li>
&lt;li>&lt;code>:root&lt;/code>, &lt;code>:active&lt;/code>, &lt;code>:hover&lt;/code>, &lt;code>:visited&lt;/code>, &lt;code>:link&lt;/code>,
&lt;code>:enabled&lt;/code>, &lt;code>:disabled&lt;/code>&lt;/li>
&lt;li>&lt;code>:*-of-type&lt;/code> pseudo selectors&lt;/li>
&lt;/ul>
&lt;h2>dojo.query and XML Documents:&lt;/h2>
&lt;p>&lt;code>dojo.query&lt;/code> (as of dojo 1.2) supports searching XML documents
in a case-sensitive manner. If an HTML document is served with
a doctype that forces case-sensitivity (e.g., XHTML 1.1
Strict), dojo.query() will detect this and &amp;quot;do the right
thing&amp;quot;. Case sensitivity is dependent upon the document being
searched and not the query used. It is therefore possible to
use case-sensitive queries on strict sub-documents (iframes,
etc.) or XML documents while still assuming case-insensitivity
for a host/root document.

&lt;/p>
&lt;h2>Non-selector Queries:&lt;/h2>
&lt;p>If something other than a String is passed for the query,
&lt;code>dojo.query&lt;/code> will return a new &lt;code>dojo/NodeList&lt;/code> instance
constructed from that parameter alone and all further
processing will stop. This means that if you have a reference
to a node or NodeList, you can quickly construct a new NodeList
from the original by calling &lt;code>dojo.query(node)&lt;/code> or
&lt;code>dojo.query(list)&lt;/code>.
&lt;/p>
</description><examples><example>&lt;p>search the entire document for elements with the class &amp;quot;foo&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>these elements will match:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;span class=&amp;quot;foo bar&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;p class=&amp;quot;thud foo&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>search the entire document for elements with the classes &amp;quot;foo&amp;quot; &lt;em>and&lt;/em> &amp;quot;bar&amp;quot;:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;.foo.bar&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>these elements will match:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo bar&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code>&lt;/pre>
&lt;p>while these will not:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;span class=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;p class=&amp;quot;thud foo&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>find &lt;code>&amp;lt;span&amp;gt;&lt;/code> elements which are descendants of paragraphs and
which have a &amp;quot;highlighted&amp;quot; class:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;p span.highlighted&amp;quot;);&lt;/code>&lt;/pre>
&lt;p>the innermost span in this fragment matches:&lt;/p>
&lt;pre>&lt;code>  &amp;lt;p class=&amp;quot;foo&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;...
      &amp;lt;span class=&amp;quot;highlighted foo bar&amp;quot;&amp;gt;...&amp;lt;/span&amp;gt;
    &amp;lt;/span&amp;gt;
  &amp;lt;/p&amp;gt;&lt;/code>&lt;/pre>
</example><example>&lt;p>set an &amp;quot;odd&amp;quot; class on all odd table rows inside of the table
&lt;code>#tabular_data&lt;/code>, using the &lt;code>&amp;gt;&lt;/code> (direct child) selector to avoid
affecting any nested tables:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;#tabular_data &amp;gt; tbody &amp;gt; tr:nth-child(odd)&amp;quot;).addClass(&amp;quot;odd&amp;quot;);&lt;/code>&lt;/pre>
</example><example>&lt;p>remove all elements with the class &amp;quot;error&amp;quot; from the document
and store them in a list:&lt;/p>
&lt;pre>&lt;code>  var errors = dojo.query(&amp;quot;.error&amp;quot;).orphan();&lt;/code>&lt;/pre>
</example><example>&lt;p>add an onclick handler to every submit button in the document
which causes the form to be sent via Ajax instead:&lt;/p>
&lt;pre>&lt;code>  dojo.query(&amp;quot;input[type=&amp;#39;submit&amp;#39;]&amp;quot;).onclick(function(e){
    dojo.stopEvent(e); // prevent sending the form
    var btn = e.target;
    dojo.xhrPost({
      form: btn.form,
      load: function(data){
        // replace the form with the response
        var div = dojo.doc.createElement(&amp;quot;div&amp;quot;);
        dojo.place(div, btn.form, &amp;quot;after&amp;quot;);
        div.innerHTML = data;
        dojo.style(btn.form, &amp;quot;display&amp;quot;, &amp;quot;none&amp;quot;);
      }
    });
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/selector/lite" type="function"><properties><property name="match" scope="normal" type="undefined" from="dojo/selector/lite"/></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/selector/lite"><parameters><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="Array"/></return-types><summary>&lt;p>A small lightweight query selector engine that implements CSS2.1 selectors
minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors&lt;/p>
</summary></method></methods><parameters><parameter name="selector" type="undefined" usage="required"/><parameter name="root" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/><return-type type="Array"/></return-types><summary>&lt;p>A small lightweight query selector engine that implements CSS2.1 selectors
minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors&lt;/p>
</summary></object><object location="dojo/store/Cache" type="constructor" classlike="true" superclass="dojo/store/api/Store"><properties><property name="idProperty" scope="prototype" type="String" from="dojo/store/api/Store"><summary>&lt;p>If the store has a single primary key, this indicates the property to use as the
identity property. The values of this property should be unique.&lt;/p>
</summary></property><property name="queryEngine" scope="prototype" type="Function" from="dojo/store/api/Store"><summary>&lt;p>If the store can be queried locally (on the client side in JS), this defines
the query engine to use for querying the data store.
This takes a query and query options and returns a function that can execute
the provided query on a JavaScript array. The queryEngine may be replace to
provide more sophisticated querying capabilities. For example:&lt;/p>
&lt;pre>&lt;code> var query = store.queryEngine({foo:&amp;quot;bar&amp;quot;}, {count:10});
 query(someArray) -&amp;gt; filtered array&lt;/code>&lt;/pre>
&lt;p>The returned query function may have a &amp;quot;matches&amp;quot; property that can be
used to determine if an object matches the query. For example:&lt;/p>
&lt;pre>&lt;code> query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;bar&amp;quot;}) -&amp;gt; true
 query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;something else&amp;quot;}) -&amp;gt; false&lt;/code>&lt;/pre>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="masterStore" type="undefined" usage="required"><summary>&lt;p>This is the authoritative store, all uncached requests or non-safe requests will
be made against this store.&lt;/p>
</summary></parameter><parameter name="cachingStore" type="undefined" usage="required"><summary>&lt;p>This is the caching store that will be used to store responses for quick access.
Typically this should be a local store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>These are additional options for how caching is handled.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>isLoaded (Function, optional): &lt;p>This is a function that will be called for each item in a query response to determine
if it is cacheable. If isLoaded returns true, the item will be cached, otherwise it
will not be cached. If isLoaded is not provided, all items will be cached.&lt;/p>&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/></method><method name="query" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="query" type="Object|String" usage="required"><summary>&lt;p>The object or string containing query information. Dependent on the query engine used.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>An optional keyword arguments object with additional parameters describing the query.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A QueryResults object that can be used to iterate over.</return-description><summary>&lt;p>Query the underlying master store and cache any results.&lt;/p>
</summary></method><method name="get" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identifier for the object in question.&lt;/p>
</summary></parameter><parameter name="directives" type="Object" usage="optional"><summary>&lt;p>Any additional parameters needed to describe how the get should be performed.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A QueryResults object.</return-description><summary>&lt;p>Get the object with the specific id.&lt;/p>
</summary></method><method name="add" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to add to the store.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.AddOptions" usage="optional"><summary>&lt;p>Any additional parameters needed to describe how the add should be performed.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/></return-types><return-description>The new id for the object.</return-description><summary>&lt;p>Add the given object to the store.&lt;/p>
</summary></method><method name="put" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to put to the store.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Any additional parameters needed to describe how the put should be performed.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/></return-types><return-description>The new id for the object.</return-description><summary>&lt;p>Put the object into the store (similar to an HTTP PUT).&lt;/p>
</summary></method><method name="remove" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identifier for the object in question.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove the object with the specific id.&lt;/p>
</summary></method><method name="evict" scope="prototype" type="function" from="dojo/store/Cache"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identifier for the object in question.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove the object with the given id from the underlying caching store.&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to get the identity from&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String|Number"/></return-types><summary>&lt;p>Returns an object&amp;#39;s identity&lt;/p>
</summary></method><method name="transaction" scope="prototype" type="function" from="dojo/store/api/Store"><parameters/><return-types><return-type type="dojo/store/api/Store.Transaction"/></return-types><return-description>This represents the new current transaction.</return-description><summary>&lt;p>Starts a new transaction.
Note that a store user might not call transaction() prior to using put,
delete, etc. in which case these operations effectively could be thought of
as &amp;quot;auto-commit&amp;quot; style actions.&lt;/p>
</summary></method><method name="getChildren" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="parent" type="Object" usage="required"><summary>&lt;p>The object to find the children of.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>Additional options to apply to the retrieval of the children.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A result set of the children of the parent object.</return-description><summary>&lt;p>Retrieves the children of an object.&lt;/p>
</summary></method><method name="getMetadata" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to return metadata for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>An object containing metadata.</return-description><summary>&lt;p>Returns any metadata about the object. This may include attribution,
cache directives, history, or version information.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/store/api/Store"/></mixins><parameters><parameter name="masterStore" type="undefined" usage="required"><summary>&lt;p>This is the authoritative store, all uncached requests or non-safe requests will
be made against this store.&lt;/p>
</summary></parameter><parameter name="cachingStore" type="undefined" usage="required"><summary>&lt;p>This is the caching store that will be used to store responses for quick access.
Typically this should be a local store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>These are additional options for how caching is handled.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>isLoaded (Function, optional): &lt;p>This is a function that will be called for each item in a query response to determine
if it is cacheable. If isLoaded returns true, the item will be cached, otherwise it
will not be cached. If isLoaded is not provided, all items will be cached.&lt;/p>&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>The Cache store wrapper takes a master store and a caching store,
caches data from the master into the caching store for faster
lookup. Normally one would use a memory store for the caching
store and a server store like JsonRest for the master store.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>  var master = new Memory(data);
  var cacher = new Memory();
  var store = new Cache(master, cacher);&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
</example></examples></object><object location="dojo/store/api/Store" type="constructor" classlike="true"><properties><property name="idProperty" scope="prototype" type="String" from="dojo/store/api/Store"><summary>&lt;p>If the store has a single primary key, this indicates the property to use as the
identity property. The values of this property should be unique.&lt;/p>
</summary></property><property name="queryEngine" scope="prototype" type="Function" from="dojo/store/api/Store"><summary>&lt;p>If the store can be queried locally (on the client side in JS), this defines
the query engine to use for querying the data store.
This takes a query and query options and returns a function that can execute
the provided query on a JavaScript array. The queryEngine may be replace to
provide more sophisticated querying capabilities. For example:&lt;/p>
&lt;pre>&lt;code> var query = store.queryEngine({foo:&amp;quot;bar&amp;quot;}, {count:10});
 query(someArray) -&amp;gt; filtered array&lt;/code>&lt;/pre>
&lt;p>The returned query function may have a &amp;quot;matches&amp;quot; property that can be
used to determine if an object matches the query. For example:&lt;/p>
&lt;pre>&lt;code> query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;bar&amp;quot;}) -&amp;gt; true
 query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;something else&amp;quot;}) -&amp;gt; false&lt;/code>&lt;/pre>
</summary></property></properties><methods><method name="get" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to lookup the object&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>The object in the store that matches the given id.</return-description><summary>&lt;p>Retrieves an object by its identity&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to get the identity from&lt;/p>
</summary></parameter></parameters><return-types><return-type type="String|Number"/></return-types><summary>&lt;p>Returns an object&amp;#39;s identity&lt;/p>
</summary></method><method name="put" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Additional directives for storing objects.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number|String"/></return-types><summary>&lt;p>Stores an object&lt;/p>
</summary></method><method name="add" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Additional directives for creating objects.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number|String"/></return-types><summary>&lt;p>Creates an object, throws an error if the object already exists&lt;/p>
</summary></method><method name="remove" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to delete the object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deletes an object by its identity&lt;/p>
</summary></method><method name="query" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="query" type="String|Object|Function" usage="required"><summary>&lt;p>The query to use for retrieving objects from the store.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="required"><summary>&lt;p>The optional arguments to apply to the resultset.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>The results of the query, extended with iterative methods.
</return-description><summary>&lt;p>Queries the store for objects. This does not alter the store, but returns a
set of data from the store.&lt;/p>
</summary><examples><example>&lt;p>Given the following store:

&lt;/p>
&lt;p>...find all items where &amp;quot;prime&amp;quot; is true:

&lt;/p>
&lt;pre>&lt;code>  store.query({ prime: true }).forEach(function(object){
    // handle each object
  });&lt;/code>&lt;/pre>
</example></examples></method><method name="transaction" scope="prototype" type="function" from="dojo/store/api/Store"><parameters/><return-types><return-type type="dojo/store/api/Store.Transaction"/></return-types><return-description>This represents the new current transaction.</return-description><summary>&lt;p>Starts a new transaction.
Note that a store user might not call transaction() prior to using put,
delete, etc. in which case these operations effectively could be thought of
as &amp;quot;auto-commit&amp;quot; style actions.&lt;/p>
</summary></method><method name="getChildren" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="parent" type="Object" usage="required"><summary>&lt;p>The object to find the children of.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>Additional options to apply to the retrieval of the children.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A result set of the children of the parent object.</return-description><summary>&lt;p>Retrieves the children of an object.&lt;/p>
</summary></method><method name="getMetadata" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to return metadata for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>An object containing metadata.</return-description><summary>&lt;p>Returns any metadata about the object. This may include attribution,
cache directives, history, or version information.&lt;/p>
</summary></method><method name="PutDirectives" scope="normal" type="constructor" from="dojo/store/api/Store"><parameters/><return-types/></method><method name="SortInformation" scope="normal" type="constructor" from="dojo/store/api/Store"><parameters/><return-types/></method><method name="QueryOptions" scope="normal" type="constructor" from="dojo/store/api/Store"><parameters/><return-types/></method><method name="QueryResults" scope="normal" type="constructor" from="dojo/store/api/Store"><parameters/><return-types/></method><method name="Transaction" scope="normal" type="constructor" from="dojo/store/api/Store"><parameters/><return-types/></method></methods><summary>&lt;p>This is an abstract API that data provider implementations conform to.
This file defines methods signatures and intentionally leaves all the
methods unimplemented.  For more information on the ,
please visit: &lt;a href=&quot;http://dojotoolkit.org/reference-guide/dojo/store.html&quot;>http://dojotoolkit.org/reference-guide/dojo/store.html&lt;/a>
Every method and property is optional, and is only needed if the functionality
it provides is required.
Every method may return a promise for the specified return value if the
execution of the operation is asynchronous (except
for query() which already defines an async return value).&lt;/p>
</summary></object><object location="dojo/store/DataStore" type="constructor" classlike="true" superclass="dojo/store/api/Store"><properties><property name="target" scope="prototype" type="string" from="dojo/store/DataStore"/><property name="idProperty" scope="prototype" type="String" from="dojo/store/DataStore"><summary>&lt;p>The object property to use to store the identity of the store items.&lt;/p>
</summary></property><property name="store" scope="prototype" type="null" from="dojo/store/DataStore"><summary>&lt;p>The object store to convert to a data store&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="options" type="Object" usage="optional"><summary>&lt;p>This provides any configuration information that will be mixed into the store,
including a reference to the Dojo data store under the property &amp;quot;store&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types/></method><method name="queryEngine" scope="prototype" type="Function" from="dojo/store/DataStore"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>An object hash with fields that may match fields of items in the store.
Values in the hash will be compared by normal == operator, but regular expressions
or any object that provides a test() method are also supported and can be
used to match strings by more complex expressions
(and then the regex&amp;#39;s or object&amp;#39;s test() method will be used to match values).
&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>An object that contains optional information such as sort, start, and count.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Function"/><return-type type="function"/></return-types><return-description>A function that caches the passed query under the field &quot;matches&quot;.  See any
of the &quot;query&quot; methods on dojo.stores.
</return-description><summary>&lt;p>Defines the query engine to use for querying the data store&lt;/p>
</summary><description>&lt;p>The SimpleQueryEngine provides a way of getting a QueryResults through
the use of a simple object hash as a filter.  The hash will be used to
match properties on data objects with the corresponding value given. In
other words, only exact matches will be returned.

&lt;/p>
&lt;p>This function can be used as a template for more complex query engines;
for example, an engine can be created that accepts an object hash that
contains filtering functions, or a string that gets evaluated, etc.

&lt;/p>
&lt;p>When creating a new dojo.store, simply set the store&amp;#39;s queryEngine
field as a reference to this function.
&lt;/p>
</description><examples><example>&lt;p>Define a store with a reference to this engine, and set up a query method.

&lt;/p>
&lt;pre>&lt;code>  var myStore = function(options){
    //  ...more properties here
    this.queryEngine = SimpleQueryEngine;
    //  define our query method
    this.query = function(query, options){
      return QueryResults(this.queryEngine(query, options)(this.data));
    };
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="_objectConverter" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="callback" type="undefined" usage="required"/></parameters><return-types><return-type type="function"/></return-types></method><method name="get" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="id" type="Object" usage="optional"><summary>&lt;p>The identity to use to lookup the object&lt;/p>
</summary></parameter><parameter name="options" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Retrieves an object by it&amp;#39;s identity. This will trigger a fetchItemByIdentity&lt;/p>
</summary></method><method name="put" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>Additional metadata for storing the data.  Includes a reference to an id
that the object may be stored with (i.e. { id: &amp;quot;foo&amp;quot; }).&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Stores an object by its identity.&lt;/p>
</summary></method><method name="remove" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="id" type="Object" usage="required"><summary>&lt;p>The identity to use to delete the object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deletes an object by its identity.&lt;/p>
</summary></method><method name="query" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>The query to use for retrieving objects from the store&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>Optional options object as used by the underlying dojo.data Store.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/><return-type type="undefined"/></return-types><return-description>A query results object that can be used to iterate over results.</return-description><summary>&lt;p>Queries the store for objects.&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/store/DataStore"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The data object to get the identity from.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="undefined"/></return-types><return-description>The id of the given object.</return-description><summary>&lt;p>Fetch the identity for the given object.&lt;/p>
</summary></method><method name="add" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="directives" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Additional directives for creating objects.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number|String"/></return-types><summary>&lt;p>Creates an object, throws an error if the object already exists&lt;/p>
</summary></method><method name="transaction" scope="prototype" type="function" from="dojo/store/api/Store"><parameters/><return-types><return-type type="dojo/store/api/Store.Transaction"/></return-types><return-description>This represents the new current transaction.</return-description><summary>&lt;p>Starts a new transaction.
Note that a store user might not call transaction() prior to using put,
delete, etc. in which case these operations effectively could be thought of
as &amp;quot;auto-commit&amp;quot; style actions.&lt;/p>
</summary></method><method name="getChildren" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="parent" type="Object" usage="required"><summary>&lt;p>The object to find the children of.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>Additional options to apply to the retrieval of the children.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A result set of the children of the parent object.</return-description><summary>&lt;p>Retrieves the children of an object.&lt;/p>
</summary></method><method name="getMetadata" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to return metadata for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>An object containing metadata.</return-description><summary>&lt;p>Returns any metadata about the object. This may include attribution,
cache directives, history, or version information.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/store/api/Store"/></mixins><parameters><parameter name="options" type="Object" usage="optional"><summary>&lt;p>This provides any configuration information that will be mixed into the store,
including a reference to the Dojo data store under the property &amp;quot;store&amp;quot;.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This is an adapter for using Dojo Data stores with an object store consumer.
You can provide a Dojo data store and use this adapter to interact with it through
the Dojo object store API&lt;/p>
</summary></object><object location="dojo/store/util/QueryResults" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/util/QueryResults"><parameters><parameter name="results" type="Array|dojo/promise/Promise" usage="required"><summary>&lt;p>The result set as an array, or a promise for an array.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Array|dojo/promise/Promise"/><return-type type="undefined"/></return-types><return-description>An array-like object that can be used for iterating over.</return-description><summary>&lt;p>A function that wraps the results of a store query with additional
methods.&lt;/p>
</summary><description>&lt;p>QueryResults is a basic wrapper that allows for array-like iteration
over any kind of returned data from a query.  While the simplest store
will return a plain array of data, other stores may return deferreds or
promises; this wrapper makes sure that &lt;em>all&lt;/em> results can be treated
the same.

&lt;/p>
&lt;p>Additional methods include &lt;code>forEach&lt;/code>, &lt;code>filter&lt;/code> and &lt;code>map&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Query a store and iterate over the results.

&lt;/p>
&lt;pre>&lt;code>  store.query({ prime: true }).forEach(function(item){
    //  do something
  });&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="results" type="Array|dojo/promise/Promise" usage="required"><summary>&lt;p>The result set as an array, or a promise for an array.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Array|dojo/promise/Promise"/><return-type type="undefined"/></return-types><return-description>An array-like object that can be used for iterating over.</return-description><summary>&lt;p>A function that wraps the results of a store query with additional
methods.&lt;/p>
</summary><description>&lt;p>QueryResults is a basic wrapper that allows for array-like iteration
over any kind of returned data from a query.  While the simplest store
will return a plain array of data, other stores may return deferreds or
promises; this wrapper makes sure that &lt;em>all&lt;/em> results can be treated
the same.

&lt;/p>
&lt;p>Additional methods include &lt;code>forEach&lt;/code>, &lt;code>filter&lt;/code> and &lt;code>map&lt;/code>.&lt;/p>
</description><examples><example>&lt;p>Query a store and iterate over the results.

&lt;/p>
&lt;pre>&lt;code>  store.query({ prime: true }).forEach(function(item){
    //  do something
  });&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/store/util/SimpleQueryEngine" type="Function"><properties/><methods><method name="constructor" scope="prototype" type="Function" from="dojo/store/util/SimpleQueryEngine"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>An object hash with fields that may match fields of items in the store.
Values in the hash will be compared by normal == operator, but regular expressions
or any object that provides a test() method are also supported and can be
used to match strings by more complex expressions
(and then the regex&amp;#39;s or object&amp;#39;s test() method will be used to match values).
&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>An object that contains optional information such as sort, start, and count.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Function"/><return-type type="function"/></return-types><return-description>A function that caches the passed query under the field &quot;matches&quot;.  See any
of the &quot;query&quot; methods on dojo.stores.
</return-description><summary>&lt;p>Defines the query engine to use for querying the data store&lt;/p>
</summary><description>&lt;p>The SimpleQueryEngine provides a way of getting a QueryResults through
the use of a simple object hash as a filter.  The hash will be used to
match properties on data objects with the corresponding value given. In
other words, only exact matches will be returned.

&lt;/p>
&lt;p>This function can be used as a template for more complex query engines;
for example, an engine can be created that accepts an object hash that
contains filtering functions, or a string that gets evaluated, etc.

&lt;/p>
&lt;p>When creating a new dojo.store, simply set the store&amp;#39;s queryEngine
field as a reference to this function.
&lt;/p>
</description><examples><example>&lt;p>Define a store with a reference to this engine, and set up a query method.

&lt;/p>
&lt;pre>&lt;code>  var myStore = function(options){
    //  ...more properties here
    this.queryEngine = SimpleQueryEngine;
    //  define our query method
    this.query = function(query, options){
      return QueryResults(this.queryEngine(query, options)(this.data));
    };
  };&lt;/code>&lt;/pre>
</example></examples></method></methods><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>An object hash with fields that may match fields of items in the store.
Values in the hash will be compared by normal == operator, but regular expressions
or any object that provides a test() method are also supported and can be
used to match strings by more complex expressions
(and then the regex&amp;#39;s or object&amp;#39;s test() method will be used to match values).
&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>An object that contains optional information such as sort, start, and count.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Function"/><return-type type="function"/></return-types><return-description>A function that caches the passed query under the field &quot;matches&quot;.  See any
of the &quot;query&quot; methods on dojo.stores.
</return-description><summary>&lt;p>Defines the query engine to use for querying the data store&lt;/p>
</summary><description>&lt;p>The SimpleQueryEngine provides a way of getting a QueryResults through
the use of a simple object hash as a filter.  The hash will be used to
match properties on data objects with the corresponding value given. In
other words, only exact matches will be returned.

&lt;/p>
&lt;p>This function can be used as a template for more complex query engines;
for example, an engine can be created that accepts an object hash that
contains filtering functions, or a string that gets evaluated, etc.

&lt;/p>
&lt;p>When creating a new dojo.store, simply set the store&amp;#39;s queryEngine
field as a reference to this function.
&lt;/p>
</description><examples><example>&lt;p>Define a store with a reference to this engine, and set up a query method.

&lt;/p>
&lt;pre>&lt;code>  var myStore = function(options){
    //  ...more properties here
    this.queryEngine = SimpleQueryEngine;
    //  define our query method
    this.query = function(query, options){
      return QueryResults(this.queryEngine(query, options)(this.data));
    };
  };&lt;/code>&lt;/pre>
</example></examples></object><object location="dojo/store/JsonRest" type="constructor" classlike="true" superclass="dojo/store/api/Store"><properties><property name="headers" scope="prototype" type="Object" from="dojo/store/JsonRest"><summary>&lt;p>Additional headers to pass in all requests to the server. These can be overridden
by passing additional headers to calls to the store.&lt;/p>
</summary></property><property name="target" scope="prototype" type="String" from="dojo/store/JsonRest"><summary>&lt;p>The target base URL to use for all requests to the server. This string will be
prepended to the id to generate the URL (relative or absolute) for requests
sent to the server&lt;/p>
</summary></property><property name="idProperty" scope="prototype" type="String" from="dojo/store/JsonRest"><summary>&lt;p>Indicates the property to use as the identity property. The values of this
property should be unique.&lt;/p>
</summary></property><property name="accepts" scope="prototype" type="String" from="dojo/store/JsonRest"><summary>&lt;p>Defines the Accept header to use on HTTP requests&lt;/p>
</summary></property><property name="queryEngine" scope="prototype" type="Function" from="dojo/store/api/Store"><summary>&lt;p>If the store can be queried locally (on the client side in JS), this defines
the query engine to use for querying the data store.
This takes a query and query options and returns a function that can execute
the provided query on a JavaScript array. The queryEngine may be replace to
provide more sophisticated querying capabilities. For example:&lt;/p>
&lt;pre>&lt;code> var query = store.queryEngine({foo:&amp;quot;bar&amp;quot;}, {count:10});
 query(someArray) -&amp;gt; filtered array&lt;/code>&lt;/pre>
&lt;p>The returned query function may have a &amp;quot;matches&amp;quot; property that can be
used to determine if an object matches the query. For example:&lt;/p>
&lt;pre>&lt;code> query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;bar&amp;quot;}) -&amp;gt; true
 query.matches({id:&amp;quot;some-object&amp;quot;, foo:&amp;quot;something else&amp;quot;}) -&amp;gt; false&lt;/code>&lt;/pre>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="options" type="dojo/store/JsonRest" usage="required"><summary>&lt;p>This provides any configuration information that will be mixed into the store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This is a basic store for RESTful communicating with a server through JSON
formatted data.&lt;/p>
</summary></method><method name="get" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to lookup the object&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>HTTP headers. For consistency with other methods, if a &lt;code>headers&lt;/code> key exists on this object, it will be
used to provide HTTP headers instead.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><return-description>The object in the store that matches the given id.</return-description><summary>&lt;p>Retrieves an object by its identity. This will trigger a GET request to the server using
the url &lt;code>this.target + id&lt;/code>.&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to get the identity from&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object&amp;#39;s identity&lt;/p>
</summary></method><method name="put" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
property if a specific id is to be used.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional headers to send along with the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String|Number, optional): &lt;p>Indicates the identity of the object if a new object is created&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>before (Object, optional): &lt;p>If the collection of objects in the store has a natural ordering,
this indicates that the created or updated object should be placed before the
object specified by the value of this property. A value of null indicates that the
object should be last.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>parent: &lt;p>If the store is hierarchical (with single parenting) this property indicates the
new parent of the created or updated object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>overwrite (Boolean, optional): &lt;p>If this is provided as a boolean it indicates that the object should or should not
overwrite an existing object. A value of true indicates that a new object
should not be created, the operation should update an existing object. A
value of false indicates that an existing object should not be updated, a new
object should be created (which is the same as an add() operation). When
this property is not provided, either an update or creation is acceptable.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sort (dojo/store/api/Store.SortInformation[], optional): &lt;p>A list of attributes to sort on, as well as direction
For example:&lt;/p>&lt;/p>
&lt;pre>&lt;code> [{attribute:&amp;quot;price, descending: true}].&lt;/code>&lt;/pre>
&lt;p>If the sort parameter is omitted, then the natural order of the store may be
applied if there is a natural order.&lt;/p>
&lt;/li>
&lt;li>&lt;p>start (Number, optional): &lt;p>The first result to begin iteration on&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>count (Number, optional): &lt;p>The number of how many results should be returned.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="dojo/_base/Deferred"/><return-type type="undefined"/></return-types><summary>&lt;p>Stores an object. This will trigger a PUT request to the server
if the object has an id, otherwise it will trigger a POST request.&lt;/p>
</summary></method><method name="add" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
property if a specific id is to be used.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional headers to send along with the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String|Number, optional): &lt;p>Indicates the identity of the object if a new object is created&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>before (Object, optional): &lt;p>If the collection of objects in the store has a natural ordering,
this indicates that the created or updated object should be placed before the
object specified by the value of this property. A value of null indicates that the
object should be last.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>parent: &lt;p>If the store is hierarchical (with single parenting) this property indicates the
new parent of the created or updated object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>overwrite (Boolean, optional): &lt;p>If this is provided as a boolean it indicates that the object should or should not
overwrite an existing object. A value of true indicates that a new object
should not be created, the operation should update an existing object. A
value of false indicates that an existing object should not be updated, a new
object should be created (which is the same as an add() operation). When
this property is not provided, either an update or creation is acceptable.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sort (dojo/store/api/Store.SortInformation[], optional): &lt;p>A list of attributes to sort on, as well as direction
For example:&lt;/p>&lt;/p>
&lt;pre>&lt;code> [{attribute:&amp;quot;price, descending: true}].&lt;/code>&lt;/pre>
&lt;p>If the sort parameter is omitted, then the natural order of the store may be
applied if there is a natural order.&lt;/p>
&lt;/li>
&lt;li>&lt;p>start (Number, optional): &lt;p>The first result to begin iteration on&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>count (Number, optional): &lt;p>The number of how many results should be returned.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Adds an object. This will trigger a PUT request to the server
if the object has an id, otherwise it will trigger a POST request.&lt;/p>
</summary></method><method name="remove" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to delete the object&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>HTTP headers.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional headers to send along with the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String|Number, optional): &lt;p>Indicates the identity of the object if a new object is created&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>before (Object, optional): &lt;p>If the collection of objects in the store has a natural ordering,
this indicates that the created or updated object should be placed before the
object specified by the value of this property. A value of null indicates that the
object should be last.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>parent: &lt;p>If the store is hierarchical (with single parenting) this property indicates the
new parent of the created or updated object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>overwrite (Boolean, optional): &lt;p>If this is provided as a boolean it indicates that the object should or should not
overwrite an existing object. A value of true indicates that a new object
should not be created, the operation should update an existing object. A
value of false indicates that an existing object should not be updated, a new
object should be created (which is the same as an add() operation). When
this property is not provided, either an update or creation is acceptable.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sort (dojo/store/api/Store.SortInformation[], optional): &lt;p>A list of attributes to sort on, as well as direction
For example:&lt;/p>&lt;/p>
&lt;pre>&lt;code> [{attribute:&amp;quot;price, descending: true}].&lt;/code>&lt;/pre>
&lt;p>If the sort parameter is omitted, then the natural order of the store may be
applied if there is a natural order.&lt;/p>
&lt;/li>
&lt;li>&lt;p>start (Number, optional): &lt;p>The first result to begin iteration on&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>count (Number, optional): &lt;p>The number of how many results should be returned.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Deletes an object by its identity. This will trigger a DELETE request to the server.&lt;/p>
</summary></method><method name="query" scope="prototype" type="function" from="dojo/store/JsonRest"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>The query to use for retrieving objects from the store.&lt;/p>
</summary></parameter><parameter name="options" type="Object" usage="optional"><summary>&lt;p>The optional arguments to apply to the resultset.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>headers (Object, optional): &lt;p>Additional headers to send along with the request.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>id (String|Number, optional): &lt;p>Indicates the identity of the object if a new object is created&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>before (Object, optional): &lt;p>If the collection of objects in the store has a natural ordering,
this indicates that the created or updated object should be placed before the
object specified by the value of this property. A value of null indicates that the
object should be last.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>parent: &lt;p>If the store is hierarchical (with single parenting) this property indicates the
new parent of the created or updated object.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>overwrite (Boolean, optional): &lt;p>If this is provided as a boolean it indicates that the object should or should not
overwrite an existing object. A value of true indicates that a new object
should not be created, the operation should update an existing object. A
value of false indicates that an existing object should not be updated, a new
object should be created (which is the same as an add() operation). When
this property is not provided, either an update or creation is acceptable.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>sort (dojo/store/api/Store.SortInformation[], optional): &lt;p>A list of attributes to sort on, as well as direction
For example:&lt;/p>&lt;/p>
&lt;pre>&lt;code> [{attribute:&amp;quot;price, descending: true}].&lt;/code>&lt;/pre>
&lt;p>If the sort parameter is omitted, then the natural order of the store may be
applied if there is a natural order.&lt;/p>
&lt;/li>
&lt;li>&lt;p>start (Number, optional): &lt;p>The first result to begin iteration on&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>count (Number, optional): &lt;p>The number of how many results should be returned.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/><return-type type="undefined"/></return-types><return-description>The results of the query, extended with iterative methods.</return-description><summary>&lt;p>Queries the store for objects. This will trigger a GET request to the server, with the
query added as a query string.&lt;/p>
</summary></method><method name="transaction" scope="prototype" type="function" from="dojo/store/api/Store"><parameters/><return-types><return-type type="dojo/store/api/Store.Transaction"/></return-types><return-description>This represents the new current transaction.</return-description><summary>&lt;p>Starts a new transaction.
Note that a store user might not call transaction() prior to using put,
delete, etc. in which case these operations effectively could be thought of
as &amp;quot;auto-commit&amp;quot; style actions.&lt;/p>
</summary></method><method name="getChildren" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="parent" type="Object" usage="required"><summary>&lt;p>The object to find the children of.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>Additional options to apply to the retrieval of the children.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A result set of the children of the parent object.</return-description><summary>&lt;p>Retrieves the children of an object.&lt;/p>
</summary></method><method name="getMetadata" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to return metadata for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>An object containing metadata.</return-description><summary>&lt;p>Returns any metadata about the object. This may include attribution,
cache directives, history, or version information.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/store/api/Store"/></mixins><parameters><parameter name="options" type="dojo/store/JsonRest" usage="required"><summary>&lt;p>This provides any configuration information that will be mixed into the store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This is a basic store for RESTful communicating with a server through JSON
formatted data. It implements dojo/store/api/Store.&lt;/p>
</summary></object><object location="dojo/store/Memory" type="constructor" classlike="true" superclass="dojo/store/api/Store"><properties><property name="data" scope="prototype" type="Array" from="dojo/store/Memory"><summary>&lt;p>The array of all the objects in the memory store&lt;/p>
</summary></property><property name="idProperty" scope="prototype" type="String" from="dojo/store/Memory"><summary>&lt;p>Indicates the property to use as the identity property. The values of this
property should be unique.&lt;/p>
</summary></property><property name="index" scope="prototype" type="Object" from="dojo/store/Memory"><summary>&lt;p>An index of data indices into the data array by id&lt;/p>
</summary></property></properties><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="options" type="dojo/store/Memory" usage="required"><summary>&lt;p>This provides any configuration information that will be mixed into the store.
This should generally include the data property to provide the starting set of data.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Creates a memory object store.&lt;/p>
</summary></method><method name="queryEngine" scope="prototype" type="Function" from="dojo/store/Memory"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>An object hash with fields that may match fields of items in the store.
Values in the hash will be compared by normal == operator, but regular expressions
or any object that provides a test() method are also supported and can be
used to match strings by more complex expressions
(and then the regex&amp;#39;s or object&amp;#39;s test() method will be used to match values).
&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>An object that contains optional information such as sort, start, and count.
&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Function"/><return-type type="function"/></return-types><return-description>A function that caches the passed query under the field &quot;matches&quot;.  See any
of the &quot;query&quot; methods on dojo.stores.
</return-description><summary>&lt;p>Defines the query engine to use for querying the data store&lt;/p>
</summary><description>&lt;p>The SimpleQueryEngine provides a way of getting a QueryResults through
the use of a simple object hash as a filter.  The hash will be used to
match properties on data objects with the corresponding value given. In
other words, only exact matches will be returned.

&lt;/p>
&lt;p>This function can be used as a template for more complex query engines;
for example, an engine can be created that accepts an object hash that
contains filtering functions, or a string that gets evaluated, etc.

&lt;/p>
&lt;p>When creating a new dojo.store, simply set the store&amp;#39;s queryEngine
field as a reference to this function.
&lt;/p>
</description><examples><example>&lt;p>Define a store with a reference to this engine, and set up a query method.

&lt;/p>
&lt;pre>&lt;code>  var myStore = function(options){
    //  ...more properties here
    this.queryEngine = SimpleQueryEngine;
    //  define our query method
    this.query = function(query, options){
      return QueryResults(this.queryEngine(query, options)(this.data));
    };
  };&lt;/code>&lt;/pre>
</example></examples></method><method name="get" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to lookup the object&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/><return-type type="undefined"/></return-types><return-description>The object in the store that matches the given id.</return-description><summary>&lt;p>Retrieves an object by its identity&lt;/p>
</summary></method><method name="getIdentity" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to get the identity from&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="undefined"/></return-types><summary>&lt;p>Returns an object&amp;#39;s identity&lt;/p>
</summary></method><method name="put" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
property if a specific id is to be used.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="undefined"/></return-types><summary>&lt;p>Stores an object&lt;/p>
</summary></method><method name="add" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to store.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.PutDirectives" usage="optional"><summary>&lt;p>Additional metadata for storing the data.  Includes an &amp;quot;id&amp;quot;
property if a specific id is to be used.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Number"/><return-type type="undefined"/></return-types><summary>&lt;p>Creates an object, throws an error if the object already exists&lt;/p>
</summary></method><method name="remove" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="id" type="Number" usage="required"><summary>&lt;p>The identity to use to delete the object&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Boolean"/><return-type type="boolean"/></return-types><return-description>Returns true if an object was removed, falsy (undefined) if no object matched the id</return-description><summary>&lt;p>Deletes an object by its identity&lt;/p>
</summary></method><method name="query" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="query" type="Object" usage="required"><summary>&lt;p>The query to use for retrieving objects from the store.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>The optional arguments to apply to the resultset.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/><return-type type="undefined"/></return-types><return-description>The results of the query, extended with iterative methods.
</return-description><summary>&lt;p>Queries the store for objects.&lt;/p>
</summary><examples><example>&lt;p>Given the following store:

&lt;/p>
&lt;pre>&lt;code>  var store = new Memory({
    data: [
      {id: 1, name: &amp;quot;one&amp;quot;, prime: false },
      {id: 2, name: &amp;quot;two&amp;quot;, even: true, prime: true},
      {id: 3, name: &amp;quot;three&amp;quot;, prime: true},
      {id: 4, name: &amp;quot;four&amp;quot;, even: true, prime: false},
      {id: 5, name: &amp;quot;five&amp;quot;, prime: true}
    ]
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>...find all items where &amp;quot;prime&amp;quot; is true:

&lt;/p>
&lt;pre>&lt;code>  var results = store.query({ prime: true });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>...or find all items where &amp;quot;even&amp;quot; is true:

&lt;/p>
&lt;pre>&lt;code>  var results = store.query({ even: true });&lt;/code>&lt;/pre>
</example></examples></method><method name="setData" scope="prototype" type="function" from="dojo/store/Memory"><parameters><parameter name="data" type="Object[]" usage="required"><summary>&lt;p>An array of objects to use as the source of data.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sets the given data as the source for this store, and indexes it&lt;/p>
</summary></method><method name="transaction" scope="prototype" type="function" from="dojo/store/api/Store"><parameters/><return-types><return-type type="dojo/store/api/Store.Transaction"/></return-types><return-description>This represents the new current transaction.</return-description><summary>&lt;p>Starts a new transaction.
Note that a store user might not call transaction() prior to using put,
delete, etc. in which case these operations effectively could be thought of
as &amp;quot;auto-commit&amp;quot; style actions.&lt;/p>
</summary></method><method name="getChildren" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="parent" type="Object" usage="required"><summary>&lt;p>The object to find the children of.&lt;/p>
</summary></parameter><parameter name="options" type="dojo/store/api/Store.QueryOptions" usage="optional"><summary>&lt;p>Additional options to apply to the retrieval of the children.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="dojo/store/api/Store.QueryResults"/></return-types><return-description>A result set of the children of the parent object.</return-description><summary>&lt;p>Retrieves the children of an object.&lt;/p>
</summary></method><method name="getMetadata" scope="prototype" type="function" from="dojo/store/api/Store"><parameters><parameter name="object" type="Object" usage="required"><summary>&lt;p>The object to return metadata for.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="Object"/></return-types><return-description>An object containing metadata.</return-description><summary>&lt;p>Returns any metadata about the object. This may include attribution,
cache directives, history, or version information.&lt;/p>
</summary></method></methods><mixins><mixin location="dojo/store/api/Store"/></mixins><parameters><parameter name="options" type="dojo/store/Memory" usage="required"><summary>&lt;p>This provides any configuration information that will be mixed into the store.
This should generally include the data property to provide the starting set of data.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This is a basic in-memory object store. It implements dojo/store/api/Store.&lt;/p>
</summary></object><object location="dojo/store/Observable" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="dojo/store/Observable"><parameters><parameter name="store" type="dojo/store/api/Store" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The Observable store wrapper takes a store and sets an observe method on query()
results that can be used to monitor results for changes.
&lt;/p>
</summary><description>&lt;p>Observable wraps an existing store so that notifications can be made when a query
is performed.
&lt;/p>
</description><examples><example>&lt;p>Create a Memory store that returns an observable query, and then log some
information about that query.

&lt;/p>
&lt;pre>&lt;code>  var store = Observable(new Memory({
    data: [
      {id: 1, name: &amp;quot;one&amp;quot;, prime: false},
      {id: 2, name: &amp;quot;two&amp;quot;, even: true, prime: true},
      {id: 3, name: &amp;quot;three&amp;quot;, prime: true},
      {id: 4, name: &amp;quot;four&amp;quot;, even: true, prime: false},
      {id: 5, name: &amp;quot;five&amp;quot;, prime: true}
    ]
  }));
  var changes = [], results = store.query({ prime: true });
  var observer = results.observe(function(object, previousIndex, newIndex){
    changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>See the Observable tests for more information.&lt;/p>
</example></examples></method></methods><parameters><parameter name="store" type="dojo/store/api/Store" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>The Observable store wrapper takes a store and sets an observe method on query()
results that can be used to monitor results for changes.
&lt;/p>
</summary><description>&lt;p>Observable wraps an existing store so that notifications can be made when a query
is performed.
&lt;/p>
</description><examples><example>&lt;p>Create a Memory store that returns an observable query, and then log some
information about that query.

&lt;/p>
&lt;pre>&lt;code>  var store = Observable(new Memory({
    data: [
      {id: 1, name: &amp;quot;one&amp;quot;, prime: false},
      {id: 2, name: &amp;quot;two&amp;quot;, even: true, prime: true},
      {id: 3, name: &amp;quot;three&amp;quot;, prime: true},
      {id: 4, name: &amp;quot;four&amp;quot;, even: true, prime: false},
      {id: 5, name: &amp;quot;five&amp;quot;, prime: true}
    ]
  }));
  var changes = [], results = store.query({ prime: true });
  var observer = results.observe(function(object, previousIndex, newIndex){
    changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
  });&lt;/code>&lt;/pre>
&lt;p>&lt;/p>
&lt;p>See the Observable tests for more information.&lt;/p>
</example></examples></object><object location="dojo/uacss" type="object"><properties/><methods/><summary>&lt;p>Applies pre-set CSS classes to the top-level HTML node, based on:

&lt;/p>
&lt;ul>
&lt;li>browser (ex: dj_ie)&lt;/li>
&lt;li>browser version (ex: dj_ie6)&lt;/li>
&lt;li>box model (ex: dj_contentBox)&lt;/li>
&lt;li>text direction (ex: dijitRtl)&lt;/li>
&lt;/ul>
&lt;p>In addition, browser, browser version, and box model are
combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.

&lt;/p>
&lt;p>Returns the has() method.&lt;/p>
</summary></object>


</javascript>